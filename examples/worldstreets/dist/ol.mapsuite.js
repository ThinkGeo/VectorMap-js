/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/filter/geoFilter.ts":
/*!*********************************!*\
  !*** ./src/filter/geoFilter.ts ***!
  \*********************************/
/*! exports provided: GeoFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoFilter\", function() { return GeoFilter; });\nvar GeoFilter = /** @class */ (function () {\r\n    function GeoFilter(filterItems) {\r\n        this.filterItems = filterItems || [];\r\n        this.replacedValueToIndex = false;\r\n    }\r\n    GeoFilter.prototype.addFilterItem = function (filterItem) {\r\n        this.filterItems.push(filterItem);\r\n    };\r\n    GeoFilter.prototype.initialize = function () {\r\n        this.initializeCore();\r\n        this.initialized = true;\r\n    };\r\n    GeoFilter.prototype.initializeCore = function () { };\r\n    GeoFilter.prototype.matchOLFeature = function (feature, zoom) {\r\n        if (!this.initialized) {\r\n            this.initialize();\r\n        }\r\n        return this.matchFeatureCore(feature, zoom);\r\n    };\r\n    GeoFilter.prototype.replaceVaulesToPbfIndex = function (pbfLayer) {\r\n        this.replaceVaulesToPbfIndexCore(pbfLayer);\r\n    };\r\n    return GeoFilter;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack:///./src/filter/geoFilter.ts?");

/***/ }),

/***/ "./src/filter/geoFilterItem.ts":
/*!*************************************!*\
  !*** ./src/filter/geoFilterItem.ts ***!
  \*************************************/
/*! exports provided: GeoFilterItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoFilterItem\", function() { return GeoFilterItem; });\nvar GeoFilterItem = /** @class */ (function () {\r\n    function GeoFilterItem(key, operator, value) {\r\n        this.key = key;\r\n        this.operator = operator;\r\n        this.value = value;\r\n    }\r\n    GeoFilterItem.createFilterItem = function (filterItemString) {\r\n        var operator = filterItemString.match(this.operatorRegex)[0];\r\n        var parts = filterItemString.split(operator);\r\n        var item = new GeoFilterItem(parts[0], operator, parts[1]);\r\n        return item;\r\n    };\r\n    GeoFilterItem.operatorRegex = new RegExp(\"[<>!=]+\", \"g\");\r\n    return GeoFilterItem;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack:///./src/filter/geoFilterItem.ts?");

/***/ }),

/***/ "./src/filter/geoNumberAttributeFilter.ts":
/*!************************************************!*\
  !*** ./src/filter/geoNumberAttributeFilter.ts ***!
  \************************************************/
/*! exports provided: GeoNumberAttributeFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoNumberAttributeFilter\", function() { return GeoNumberAttributeFilter; });\n/* harmony import */ var _geoRangeFilter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoRangeFilter */ \"./src/filter/geoRangeFilter.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar GeoNumberAttributeFilter = /** @class */ (function (_super) {\r\n    __extends(GeoNumberAttributeFilter, _super);\r\n    function GeoNumberAttributeFilter(filterItems) {\r\n        return _super.call(this, filterItems) || this;\r\n    }\r\n    return GeoNumberAttributeFilter;\r\n}(_geoRangeFilter__WEBPACK_IMPORTED_MODULE_0__[\"GeoRangeFilter\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/filter/geoNumberAttributeFilter.ts?");

/***/ }),

/***/ "./src/filter/geoRangeFilter.ts":
/*!**************************************!*\
  !*** ./src/filter/geoRangeFilter.ts ***!
  \**************************************/
/*! exports provided: GeoRangeFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoRangeFilter\", function() { return GeoRangeFilter; });\n/* harmony import */ var _geoFilter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoFilter */ \"./src/filter/geoFilter.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar GeoRangeFilter = /** @class */ (function (_super) {\r\n    __extends(GeoRangeFilter, _super);\r\n    function GeoRangeFilter(filterItems) {\r\n        var _this = _super.call(this, filterItems) || this;\r\n        _this.ranges = [];\r\n        _this.allowedValues = [];\r\n        _this.disallowedValues = [];\r\n        return _this;\r\n    }\r\n    GeoRangeFilter.prototype.initializeCore = function () {\r\n        this.filterItems.sort(function (a, b) { return +a.value - +b.value; });\r\n        for (var i = 0; i < this.filterItems.length; i++) {\r\n            var filterItem = this.filterItems[i];\r\n            this.key = filterItem.key;\r\n            var value = +filterItem.value;\r\n            switch (filterItem.operator) {\r\n                case \">\":\r\n                    this.ranges.push([value + 0.00001, Number.POSITIVE_INFINITY]);\r\n                    break;\r\n                case \">=\":\r\n                    this.ranges.push([value, Number.POSITIVE_INFINITY]);\r\n                    break;\r\n                case \"!=\":\r\n                    this.disallowedValues.push(value);\r\n                    break;\r\n                case \"=\":\r\n                    this.allowedValues.push(value);\r\n                    break;\r\n            }\r\n        }\r\n        for (var i = 0; i < this.filterItems.length; i++) {\r\n            var filterItem = this.filterItems[i];\r\n            var value = +filterItem.value;\r\n            var range = GeoRangeFilter.getRange(this.ranges, value);\r\n            switch (filterItem.operator) {\r\n                case \"<\":\r\n                    if (range) {\r\n                        range[1] = value + 0.00001;\r\n                    }\r\n                    else {\r\n                        range = [Number.NEGATIVE_INFINITY, value + 0.00001];\r\n                        this.ranges.push(range);\r\n                    }\r\n                    break;\r\n                case \"<=\":\r\n                    if (range) {\r\n                        range[1] = value;\r\n                    }\r\n                    else {\r\n                        range = [Number.NEGATIVE_INFINITY, value];\r\n                        this.ranges.push(range);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n    GeoRangeFilter.prototype.matchFeatureCore = function (feature, zoom) {\r\n        var currentValue;\r\n        if (this.replacedValueToIndex) {\r\n            currentValue = feature.properties[this.key];\r\n        }\r\n        else {\r\n            currentValue = feature.properties[this.key];\r\n        }\r\n        return this.isInRange(+currentValue);\r\n    };\r\n    GeoRangeFilter.prototype.replaceVaulesToPbfIndexCore = function (pbfLayer) {\r\n        this.replacedValueToIndex = true;\r\n    };\r\n    GeoRangeFilter.prototype.isInRange = function (currentValue) {\r\n        if (this.disallowedValues.includes(currentValue)) {\r\n            return false;\r\n        }\r\n        if (this.allowedValues.includes(currentValue)) {\r\n            return true;\r\n        }\r\n        for (var i = 0; i < this.ranges.length; i++) {\r\n            var range = this.ranges[i];\r\n            if (range.length === 1) {\r\n                if (currentValue >= range[0]) {\r\n                    return true;\r\n                }\r\n            }\r\n            else {\r\n                if (currentValue >= range[0] && currentValue <= range[1]) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    GeoRangeFilter.getRange = function (ranges, value) {\r\n        for (var i = 0; i < ranges.length; i++) {\r\n            var range = ranges[i];\r\n            if (value >= range[0] && value <= range[1]) {\r\n                return range;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    return GeoRangeFilter;\r\n}(_geoFilter__WEBPACK_IMPORTED_MODULE_0__[\"GeoFilter\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/filter/geoRangeFilter.ts?");

/***/ }),

/***/ "./src/filter/geoRegexFilter.ts":
/*!**************************************!*\
  !*** ./src/filter/geoRegexFilter.ts ***!
  \**************************************/
/*! exports provided: GeoRegexFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoRegexFilter\", function() { return GeoRegexFilter; });\n/* harmony import */ var _geoFilter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoFilter */ \"./src/filter/geoFilter.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar GeoRegexFilter = /** @class */ (function (_super) {\r\n    __extends(GeoRegexFilter, _super);\r\n    function GeoRegexFilter(filterItems) {\r\n        return _super.call(this, filterItems) || this;\r\n    }\r\n    GeoRegexFilter.prototype.initializeCore = function () {\r\n        var value = this.filterItems[0].value;\r\n        value = value.slice(2, value.length - 1);\r\n        this.regex = new RegExp(value, \"g\");\r\n        this.key = this.filterItems[0].key;\r\n    };\r\n    GeoRegexFilter.prototype.matchFeatureCore = function (feature, zoom) {\r\n        var currentValue;\r\n        if (this.replacedValueToIndex) {\r\n            currentValue = feature.properties[this.key];\r\n        }\r\n        else {\r\n            currentValue = feature.properties[this.key];\r\n        }\r\n        if (!currentValue) {\r\n            return false;\r\n        }\r\n        return currentValue.toString().match(this.regex) !== null;\r\n    };\r\n    GeoRegexFilter.prototype.replaceVaulesToPbfIndexCore = function (pbfLayer) {\r\n        this.replacedValueToIndex = true;\r\n    };\r\n    return GeoRegexFilter;\r\n}(_geoFilter__WEBPACK_IMPORTED_MODULE_0__[\"GeoFilter\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/filter/geoRegexFilter.ts?");

/***/ }),

/***/ "./src/filter/geoStringAttributeFilter.ts":
/*!************************************************!*\
  !*** ./src/filter/geoStringAttributeFilter.ts ***!
  \************************************************/
/*! exports provided: GeoStringAttributeFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoStringAttributeFilter\", function() { return GeoStringAttributeFilter; });\n/* harmony import */ var _geoFilter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoFilter */ \"./src/filter/geoFilter.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar GeoStringAttributeFilter = /** @class */ (function (_super) {\r\n    __extends(GeoStringAttributeFilter, _super);\r\n    function GeoStringAttributeFilter(filterItems) {\r\n        return _super.call(this, filterItems) || this;\r\n    }\r\n    GeoStringAttributeFilter.prototype.initializeCore = function () {\r\n        var expectedValue = this.filterItems[0].value;\r\n        expectedValue = expectedValue.slice(1, expectedValue.length - 1);\r\n        this.expectedValues = expectedValue.split(\",\");\r\n        this.key = this.filterItems[0].key;\r\n    };\r\n    GeoStringAttributeFilter.prototype.matchFeatureCore = function (feature, zoom) {\r\n        var currentValue;\r\n        var currentExpectedValues;\r\n        if (this.replacedValueToIndex) {\r\n            currentValue = feature.propertiesIndex[this.keyIndex];\r\n            currentExpectedValues = this.expectedValueIndexs;\r\n        }\r\n        else {\r\n            currentValue = feature.properties[this.key];\r\n            currentExpectedValues = this.expectedValues;\r\n        }\r\n        switch (this.filterItems[0].operator) {\r\n            case \"=\":\r\n                return currentExpectedValues.includes(currentValue);\r\n            case \"!=\":\r\n            default:\r\n                return !currentExpectedValues.includes(currentValue);\r\n        }\r\n    };\r\n    GeoStringAttributeFilter.prototype.replaceVaulesToPbfIndexCore = function (pbfLayer) {\r\n        if (!this.initialized) {\r\n            this.initialize();\r\n        }\r\n        this.keyIndex = pbfLayer.keys.indexOf(this.key);\r\n        var replacedExpectedVaules = [];\r\n        for (var j = 0, jj = this.expectedValues.length; j < jj; j++) {\r\n            var numberValue = +this.expectedValues[j];\r\n            if (isNaN(numberValue)) {\r\n                replacedExpectedVaules.push(pbfLayer.values.indexOf(this.expectedValues[j]));\r\n            }\r\n            else {\r\n                replacedExpectedVaules.push(pbfLayer.values.indexOf(numberValue));\r\n            }\r\n        }\r\n        this.expectedValueIndexs = replacedExpectedVaules;\r\n        this.replacedValueToIndex = true;\r\n    };\r\n    return GeoStringAttributeFilter;\r\n}(_geoFilter__WEBPACK_IMPORTED_MODULE_0__[\"GeoFilter\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/filter/geoStringAttributeFilter.ts?");

/***/ }),

/***/ "./src/filter/geoZoomFilter.ts":
/*!*************************************!*\
  !*** ./src/filter/geoZoomFilter.ts ***!
  \*************************************/
/*! exports provided: GeoZoomFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoZoomFilter\", function() { return GeoZoomFilter; });\n/* harmony import */ var _geoRangeFilter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoRangeFilter */ \"./src/filter/geoRangeFilter.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar GeoZoomFilter = /** @class */ (function (_super) {\r\n    __extends(GeoZoomFilter, _super);\r\n    function GeoZoomFilter(filterItems) {\r\n        return _super.call(this, filterItems) || this;\r\n    }\r\n    GeoZoomFilter.prototype.matchFeatureCore = function (feature, zoom) {\r\n        return this.isInRange(zoom);\r\n    };\r\n    GeoZoomFilter.prototype.replaceVaulesToPbfIndexCore = function (pbfLayer) {\r\n        this.replacedValueToIndex = true;\r\n    };\r\n    return GeoZoomFilter;\r\n}(_geoRangeFilter__WEBPACK_IMPORTED_MODULE_0__[\"GeoRangeFilter\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/filter/geoZoomFilter.ts?");

/***/ }),

/***/ "./src/format/geoMvt.ts":
/*!******************************!*\
  !*** ./src/format/geoMvt.ts ***!
  \******************************/
/*! exports provided: GeoMVTFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoMVTFormat\", function() { return GeoMVTFormat; });\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar GeoMVTFormat = /** @class */ (function (_super) {\r\n    __extends(GeoMVTFormat, _super);\r\n    function GeoMVTFormat(styleJSonCache, options) {\r\n        var _this = this;\r\n        options.layerName = options.layerName ? options.layerName : \"layerName\";\r\n        _this = _super.call(this, options) || this;\r\n        _this.isMultithread = options.multithread;\r\n        _this.minimalist = options.minimalist;\r\n        _this.maxDataZoom = options.maxDataZoom ? options.maxDataZoom : 14;\r\n        _this.layerName = options.layerName;\r\n        _this.styleJsonCache = styleJSonCache;\r\n        _this.maxDataZoomCache = {};\r\n        _this.registeredLoadEvents = {};\r\n        _this.lruCache = new ol.structs.LRUCache(15);\r\n        _this.sourceCache = {};\r\n        return _this;\r\n    }\r\n    GeoMVTFormat.prototype.getLayerName = function () {\r\n        return this.layerName;\r\n    };\r\n    GeoMVTFormat.prototype.registerTileLoadEvent = function (tile, success, failure, callback) {\r\n        var hasRequested = true;\r\n        var requestKey = tile.requestTileCoord.join(\",\") + \",\" + tile.tileCoord[0];\r\n        var loadEventInfo = {\r\n            tile: tile,\r\n            successFunction: success,\r\n            failureFunction: failure,\r\n            callback: callback\r\n        };\r\n        if (this.registeredLoadEvents[requestKey] === undefined) {\r\n            this.registeredLoadEvents[requestKey] = [];\r\n            hasRequested = false;\r\n        }\r\n        this.registeredLoadEvents[requestKey].push(loadEventInfo);\r\n        return hasRequested;\r\n    };\r\n    GeoMVTFormat.prototype.readFeaturesAndCreateInstructsNew = function (source, requestTileCoord, tileCoord) {\r\n        var pbf = new ol.ext.PBF((source));\r\n        var pbfLayers = pbf.readFields(ol.format.MVT.pbfReaders_.layers, {});\r\n        var pbfLayer;\r\n        var features = [];\r\n        var featureIndex = -1;\r\n        var zoomMatchedGeoStylesGroupByLayerId = this.styleJsonCache.geoStyleGroupByZoom[tileCoord[0]];\r\n        if (!zoomMatchedGeoStylesGroupByLayerId) {\r\n            return features;\r\n        }\r\n        var pbfLayerNamesWithGeoStyle = [];\r\n        for (var pbfLayerName in zoomMatchedGeoStylesGroupByLayerId) {\r\n            pbfLayerNamesWithGeoStyle.push(pbfLayerName);\r\n        }\r\n        var instructsCache = [];\r\n        for (var name_1 in pbfLayers) {\r\n            if (this.layers_ && this.layers_.indexOf(name_1) === -1) {\r\n                continue;\r\n            }\r\n            if (pbfLayerNamesWithGeoStyle.indexOf(name_1) === -1) {\r\n                continue;\r\n            }\r\n            pbfLayer = pbfLayers[name_1];\r\n            var cacheTrees = zoomMatchedGeoStylesGroupByLayerId[name_1];\r\n            if (cacheTrees && cacheTrees.length > 0) {\r\n                this.replaceFiltersToIndexOfPbfLayer(cacheTrees, pbfLayer);\r\n                var _loop_1 = function (i) {\r\n                    var rawFeature = ol.format.MVT.readRawFeature_(pbf, pbfLayer, i);\r\n                    var feature_1 = void 0;\r\n                    var _loop_2 = function (j) {\r\n                        var cacheTree = cacheTrees[j];\r\n                        var treeIndex = cacheTree.treeIndex;\r\n                        if (instructsCache[treeIndex] === undefined) {\r\n                            instructsCache[treeIndex] = {\r\n                                min: 10,\r\n                                max: -10\r\n                            };\r\n                        }\r\n                        var matchedNode;\r\n                        var checkNodeMatched = function (node) {\r\n                            var styleJsonCacheItem = node.data;\r\n                            var matched = false;\r\n                            if (styleJsonCacheItem.filterGroup.length > 0) {\r\n                                for (var i_1 = 0; i_1 < styleJsonCacheItem.filterGroup.length; i_1++) {\r\n                                    var filters = styleJsonCacheItem.filterGroup[i_1];\r\n                                    var groupMatched = true;\r\n                                    for (var j_1 = 0; j_1 < filters.length; j_1++) {\r\n                                        var filter = filters[j_1];\r\n                                        if (!filter.matchOLFeature(rawFeature, tileCoord[0])) {\r\n                                            groupMatched = false;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (groupMatched) {\r\n                                        matched = true;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                matched = true;\r\n                            }\r\n                            return matched;\r\n                        };\r\n                        var selectNode = function (node) {\r\n                            matchedNode = node.data;\r\n                        };\r\n                        cacheTree.traverseNode(checkNodeMatched, selectNode);\r\n                        if (matchedNode) {\r\n                            if (feature_1 === undefined) {\r\n                                feature_1 = this_1.createFeature_(pbf, rawFeature);\r\n                                features.push(feature_1);\r\n                                featureIndex += 1;\r\n                            }\r\n                            var zindex = void 0;\r\n                            if (cacheTree.root.data.zIndex) {\r\n                                zindex = rawFeature.properties[cacheTree.root.data.zIndex];\r\n                                feature_1.properties_[cacheTree.root.data.zIndex] = zindex;\r\n                            }\r\n                            if (isNaN(zindex)) {\r\n                                zindex = 0;\r\n                            }\r\n                            if (instructsCache[treeIndex][zindex] === undefined) {\r\n                                instructsCache[treeIndex][zindex] = [];\r\n                                if (zindex < instructsCache[treeIndex][\"min\"]) {\r\n                                    instructsCache[treeIndex][\"min\"] = zindex;\r\n                                }\r\n                                if (zindex > instructsCache[treeIndex][\"max\"]) {\r\n                                    instructsCache[treeIndex][\"max\"] = zindex;\r\n                                }\r\n                            }\r\n                            instructsCache[treeIndex][zindex].push([featureIndex, matchedNode]);\r\n                            feature_1.extent_ = undefined;\r\n                        }\r\n                    };\r\n                    for (var j = 0; j < cacheTrees.length; j++) {\r\n                        _loop_2(j);\r\n                    }\r\n                };\r\n                var this_1 = this;\r\n                for (var i = 0; i < pbfLayer.length; i++) {\r\n                    _loop_1(i);\r\n                }\r\n            }\r\n            this.extent_ = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;\r\n        }\r\n        var instructs = [];\r\n        for (var i = 0; i < instructsCache.length; i++) {\r\n            var instructsInOneTree = instructsCache[i];\r\n            if (instructsInOneTree) {\r\n                for (var j = instructsInOneTree.min, jj = instructsInOneTree.max; j <= jj; j++) {\r\n                    var instructsInOneZIndex = instructsInOneTree[j];\r\n                    if (instructsInOneZIndex) {\r\n                        var childrenInstructs = [];\r\n                        for (var h = 0; h < instructsInOneZIndex.length; h++) {\r\n                            var instruct = instructsInOneZIndex[h];\r\n                            var feature = features[instruct[0]];\r\n                            feature.styleId = feature.styleId ? feature.styleId : {};\r\n                            if (instruct[1].geoStyle) {\r\n                                feature.styleId[instruct[1].geoStyle.id] = 0;\r\n                                instructs.push([instruct[0], instruct[1].geoStyle, i]);\r\n                            }\r\n                            if (instruct[1].childrenGeoStyles) {\r\n                                for (var k = 0; k < instruct[1].childrenGeoStyles.length; k++) {\r\n                                    feature.styleId[instruct[1].childrenGeoStyles[k].id] = 1;\r\n                                    childrenInstructs.push([instruct[0], instruct[1].childrenGeoStyles[k], i]);\r\n                                }\r\n                            }\r\n                        }\r\n                        Array.prototype.push.apply(instructs, childrenInstructs);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var subTileCachedInstruct = {};\r\n        var offsetZ = tileCoord[0] - requestTileCoord[0];\r\n        // TODO Get Extent \r\n        var tileSize = 4096 / Math.pow(2, offsetZ);\r\n        var tileRange = this.getTileRange(requestTileCoord, tileCoord[0]);\r\n        var tiles = {};\r\n        for (var x = tileRange[0]; x <= tileRange[2]; x++) {\r\n            var minX = (x - tileRange[0]) * tileSize;\r\n            var maxX = (x - tileRange[0] + 1) * tileSize;\r\n            for (var y = tileRange[3]; y >= tileRange[1]; y--) {\r\n                var minY = (tileRange[3] - y) * tileSize;\r\n                var maxY = (tileRange[3] - y + 1) * tileSize;\r\n                tiles[\"\" + [x, y]] = [minX, minY, maxX, maxY];\r\n            }\r\n        }\r\n        for (var i = 0; i < instructs.length; i++) {\r\n            var instruct = instructs[i];\r\n            var feature_2 = features[instruct[0]];\r\n            var featureExtent = feature_2.getExtent();\r\n            var featureTileRange = this.getFeatureTileRange(featureExtent, 4096, tileSize, requestTileCoord, offsetZ);\r\n            for (var x = tileRange[0] > featureTileRange[0] ? tileRange[0] : featureTileRange[0], xx = featureTileRange[2] > tileRange[2] ? tileRange[2] : featureTileRange[2]; x <= xx; x++) {\r\n                for (var y = tileRange[1] > featureTileRange[1] ? tileRange[1] : featureTileRange[1], yy = featureTileRange[3] > tileRange[3] ? tileRange[3] : featureTileRange[3]; y <= yy; y++) {\r\n                    var tileKey = \"\" + [x, y];\r\n                    var tileExtent = tiles[tileKey];\r\n                    if (subTileCachedInstruct[tileKey] === undefined) {\r\n                        subTileCachedInstruct[tileKey] = [];\r\n                    }\r\n                    subTileCachedInstruct[tileKey].push(instruct);\r\n                }\r\n            }\r\n        }\r\n        return [features, subTileCachedInstruct];\r\n    };\r\n    GeoMVTFormat.prototype.getCachedSource = function (tileCoord) {\r\n        return this.sourceCache[tileCoord];\r\n    };\r\n    GeoMVTFormat.prototype.tryLoadTileFromCacheOrRegosterLoadEvent = function (tileCoord, originalZoom, cacheTileInfo) {\r\n        var hasRequested = true;\r\n        var tileCoordKey = tileCoord.join(\",\") + \",\" + originalZoom;\r\n        if (this.lruCache.containsKey(tileCoordKey)) {\r\n            var oTile = this.lruCache.get(tileCoordKey);\r\n            this.cachedTileCallback(oTile, [cacheTileInfo]);\r\n        }\r\n        else {\r\n            if (this.registeredLoadEvents[tileCoordKey] === undefined) {\r\n                this.registeredLoadEvents[tileCoordKey] = [];\r\n                hasRequested = false;\r\n            }\r\n            this.registeredLoadEvents[tileCoordKey].push(cacheTileInfo);\r\n        }\r\n        return hasRequested;\r\n    };\r\n    GeoMVTFormat.prototype.addSourceToCache = function (source, zoom, options) {\r\n        if (this.sourceCache[options.tileCoord] === undefined) {\r\n            this.sourceCache[options.tileCoord] = source;\r\n        }\r\n        var instructsTree = this.readFeaturesAndCreateInstructTrees(source, zoom, options);\r\n        var instructs = this.getInstructs(instructsTree);\r\n        var subTileInstructCaches = this.createSubTileInstructCaches(instructs, options);\r\n        var sourceProject = this.readProjection(source);\r\n        var tileCoordKey = options.tileCoord.join(\",\") + \",\" + zoom;\r\n        var lastExtent = this.getLastExtent();\r\n        var oTile = { subTileInstructCaches: subTileInstructCaches, sourceProject: sourceProject, lastExtent: lastExtent };\r\n        this.lruCache.set(tileCoordKey, oTile);\r\n        var cachedTileInfo = this.registeredLoadEvents[tileCoordKey];\r\n        delete this.registeredLoadEvents[tileCoordKey];\r\n        this.cachedTileCallback(oTile, cachedTileInfo);\r\n    };\r\n    GeoMVTFormat.prototype.readFeaturesAndCreateInstructTrees = function (source, zoom, options) {\r\n        var pbf = new ol.ext.PBF((source));\r\n        var pbfLayers = pbf.readFields(ol.format.MVT.pbfReaders_.layers, {});\r\n        var features = [];\r\n        var pbfLayer;\r\n        var zoomMatchedGeoStylesGroupByLayerId = this.styleJsonCache.geoStyleGroupByZoom[zoom];\r\n        if (!zoomMatchedGeoStylesGroupByLayerId) {\r\n            return features;\r\n        }\r\n        var pbfLayerNamesWithGeoStyle = [];\r\n        for (var pbfLayerName in zoomMatchedGeoStylesGroupByLayerId) {\r\n            pbfLayerNamesWithGeoStyle.push(pbfLayerName);\r\n        }\r\n        var instructsCache = [];\r\n        for (var name_2 in pbfLayers) {\r\n            if (this.layers_ && this.layers_.indexOf(name_2) === -1) {\r\n                continue;\r\n            }\r\n            if (pbfLayerNamesWithGeoStyle.indexOf(name_2) === -1) {\r\n                continue;\r\n            }\r\n            pbfLayer = pbfLayers[name_2];\r\n            options[\"extent\"] = pbfLayer.extent;\r\n            var cacheTrees = zoomMatchedGeoStylesGroupByLayerId[name_2];\r\n            if (cacheTrees && cacheTrees.length > 0) {\r\n                this.replaceFiltersToIndexOfPbfLayer(cacheTrees, pbfLayer);\r\n                var _loop_3 = function (i) {\r\n                    var rawFeature = ol.format.MVT.readRawFeature_(pbf, pbfLayer, i);\r\n                    var feature = void 0;\r\n                    var _loop_4 = function (j) {\r\n                        var cacheTree = cacheTrees[j];\r\n                        var treeIndex = cacheTree.treeIndex;\r\n                        if (instructsCache[treeIndex] === undefined) {\r\n                            instructsCache[treeIndex] = {\r\n                                min: 10,\r\n                                max: -10\r\n                            };\r\n                        }\r\n                        var matchedNode;\r\n                        var checkNodeMatched = function (node) {\r\n                            var styleJsonCacheItem = node.data;\r\n                            var matched = false;\r\n                            if (styleJsonCacheItem.filterGroup.length > 0) {\r\n                                for (var i_2 = 0; i_2 < styleJsonCacheItem.filterGroup.length; i_2++) {\r\n                                    var filters = styleJsonCacheItem.filterGroup[i_2];\r\n                                    var groupMatched = true;\r\n                                    for (var j_2 = 0; j_2 < filters.length; j_2++) {\r\n                                        var filter = filters[j_2];\r\n                                        if (!filter.matchOLFeature(rawFeature, zoom)) {\r\n                                            groupMatched = false;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (groupMatched) {\r\n                                        matched = true;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                matched = true;\r\n                            }\r\n                            return matched;\r\n                        };\r\n                        var selectNode = function (node) {\r\n                            matchedNode = node.data;\r\n                        };\r\n                        cacheTree.traverseNode(checkNodeMatched, selectNode);\r\n                        if (matchedNode) {\r\n                            if (feature === undefined) {\r\n                                feature = this_2.createFeature_(pbf, rawFeature);\r\n                                if (this_2.minimalist) {\r\n                                    feature.properties_ = {};\r\n                                }\r\n                            }\r\n                            var zindex = void 0;\r\n                            if (cacheTree.root.data.zIndex) {\r\n                                zindex = rawFeature.properties[cacheTree.root.data.zIndex];\r\n                                feature.properties_[cacheTree.root.data.zIndex] = zindex;\r\n                            }\r\n                            if (isNaN(zindex)) {\r\n                                zindex = 0;\r\n                            }\r\n                            if (instructsCache[treeIndex][zindex] === undefined) {\r\n                                instructsCache[treeIndex][zindex] = [];\r\n                                if (zindex < instructsCache[treeIndex][\"min\"]) {\r\n                                    instructsCache[treeIndex][\"min\"] = zindex;\r\n                                }\r\n                                if (zindex > instructsCache[treeIndex][\"max\"]) {\r\n                                    instructsCache[treeIndex][\"max\"] = zindex;\r\n                                }\r\n                            }\r\n                            instructsCache[treeIndex][zindex].push([feature, matchedNode]);\r\n                            if (this_2.minimalist) {\r\n                                if (matchedNode.geoStyle && (matchedNode.geoStyle.constructor.name === \"GeoTextStyle\" || matchedNode.geoStyle.constructor.name === \"GeoShieldStyle\")) {\r\n                                    feature.properties_[matchedNode.geoStyle.name] = rawFeature.properties[matchedNode.geoStyle.name];\r\n                                }\r\n                                if (matchedNode.childrenGeoStyles && matchedNode.childrenGeoStyles.length > 0) {\r\n                                    for (var i_3 = 0; i_3 < matchedNode.childrenGeoStyles.length; i_3++) {\r\n                                        feature.properties_[matchedNode.childrenGeoStyles[i_3].name] = rawFeature.properties[matchedNode.childrenGeoStyles[i_3].name];\r\n                                    }\r\n                                }\r\n                            }\r\n                            feature.extent_ = undefined;\r\n                        }\r\n                    };\r\n                    for (var j = 0; j < cacheTrees.length; j++) {\r\n                        _loop_4(j);\r\n                    }\r\n                };\r\n                var this_2 = this;\r\n                for (var i = 0; i < pbfLayer.length; i++) {\r\n                    _loop_3(i);\r\n                }\r\n            }\r\n            this.extent_ = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;\r\n        }\r\n        return instructsCache;\r\n    };\r\n    GeoMVTFormat.prototype.getInstructs = function (instructsTree) {\r\n        var instructs = [];\r\n        // the tress index means the index of SyleId.\r\n        for (var i = 0; i < instructsTree.length; i++) {\r\n            var instructsInOneTree = instructsTree[i];\r\n            if (instructsInOneTree) {\r\n                for (var j = instructsInOneTree.min, jj = instructsInOneTree.max; j <= jj; j++) {\r\n                    var instructsInOneZIndex = instructsInOneTree[j];\r\n                    if (instructsInOneZIndex) {\r\n                        var childrenInstructs = [];\r\n                        for (var h = 0; h < instructsInOneZIndex.length; h++) {\r\n                            var instruct = instructsInOneZIndex[h];\r\n                            instruct[0].styleId = instruct[0].styleId ? instruct[0].styleId : {};\r\n                            if (instruct[1].geoStyle) {\r\n                                instruct[0].styleId[instruct[1].geoStyle.id] = 0;\r\n                                instructs.push([instruct[0], instruct[1].geoStyle, i]);\r\n                            }\r\n                            if (instruct[1].childrenGeoStyles) {\r\n                                for (var k = 0; k < instruct[1].childrenGeoStyles.length; k++) {\r\n                                    instruct[0].styleId[instruct[1].childrenGeoStyles[k].id] = 1;\r\n                                    childrenInstructs.push([instruct[0], instruct[1].childrenGeoStyles[k], i]);\r\n                                }\r\n                            }\r\n                        }\r\n                        Array.prototype.push.apply(instructs, childrenInstructs);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return instructs;\r\n    };\r\n    GeoMVTFormat.prototype.createSubTileInstructCaches = function (instructs, options) {\r\n        var subTileCachedInstruct = {};\r\n        var offsetZ = options.originalCoord[0] - options.tileCoord[0];\r\n        var tileSize = options.extent / Math.pow(2, offsetZ);\r\n        var tileRange = this.getTileRange(options.tileCoord, options.originalCoord[0]);\r\n        var tiles = {};\r\n        for (var x = tileRange[0]; x <= tileRange[2]; x++) {\r\n            var minX = (x - tileRange[0]) * tileSize;\r\n            var maxX = (x - tileRange[0] + 1) * tileSize;\r\n            for (var y = tileRange[3]; y >= tileRange[1]; y--) {\r\n                var minY = (tileRange[3] - y) * tileSize;\r\n                var maxY = (tileRange[3] - y + 1) * tileSize;\r\n                tiles[\"\" + [x, y]] = [minX, minY, maxX, maxY];\r\n            }\r\n        }\r\n        for (var i = 0; i < instructs.length; i++) {\r\n            var instruct = instructs[i];\r\n            var featureExtent = instruct[0].getGeometry().getExtent();\r\n            var featureTileRange = this.getFeatureTileRange(featureExtent, options.extent, tileSize, options.tileCoord, offsetZ);\r\n            for (var x = tileRange[0] > featureTileRange[0] ? tileRange[0] : featureTileRange[0], xx = featureTileRange[2] > tileRange[2] ? tileRange[2] : featureTileRange[2]; x <= xx; x++) {\r\n                for (var y = tileRange[1] > featureTileRange[1] ? tileRange[1] : featureTileRange[1], yy = featureTileRange[3] > tileRange[3] ? tileRange[3] : featureTileRange[3]; y <= yy; y++) {\r\n                    var tileKey = \"\" + [x, y];\r\n                    var tileExtent = tiles[tileKey];\r\n                    if (subTileCachedInstruct[tileKey] === undefined) {\r\n                        subTileCachedInstruct[tileKey] = [];\r\n                    }\r\n                    subTileCachedInstruct[tileKey].push(instruct);\r\n                }\r\n            }\r\n        }\r\n        return subTileCachedInstruct;\r\n    };\r\n    GeoMVTFormat.prototype.cachedTileCallback = function (oTile, cacheTileInfos) {\r\n        for (var i = 0; i < cacheTileInfos.length; i++) {\r\n            var cacheTileInfo = cacheTileInfos[i];\r\n            var tileKey = \"\" + cacheTileInfo.tile.tileCoord[1] + \",\" + cacheTileInfo.tile.tileCoord[2];\r\n            cacheTileInfo.callback(cacheTileInfo.tile, cacheTileInfo.successFunction, [], oTile.subTileInstructCaches[tileKey], oTile.sourceProject, oTile.lastExtent);\r\n        }\r\n    };\r\n    GeoMVTFormat.prototype.getTileRange = function (tileCoord, zoom) {\r\n        var x = tileCoord[1];\r\n        var y = tileCoord[2];\r\n        var minX = x;\r\n        var maxX = x;\r\n        var minY = y;\r\n        var maxY = y;\r\n        for (var i = tileCoord[0]; i < zoom; i++) {\r\n            minX = minX * 2;\r\n            maxX = maxX * 2 + 1;\r\n            minY = minY * 2;\r\n            maxY = maxY * 2 + 1;\r\n        }\r\n        return [minX, minY, maxX, maxY];\r\n    };\r\n    GeoMVTFormat.prototype.getFeatureTileRange = function (featureExtent, extent, tileSize, requestTileCoord, offsetZ) {\r\n        var minX = requestTileCoord[1] * Math.pow(2, offsetZ) + Math.floor(featureExtent[0] / tileSize);\r\n        var maxX = requestTileCoord[1] * Math.pow(2, offsetZ) + Math.floor(featureExtent[2] / tileSize);\r\n        var minY = requestTileCoord[2] * Math.pow(2, offsetZ) + Math.floor((extent - featureExtent[3]) / tileSize);\r\n        var maxY = requestTileCoord[2] * Math.pow(2, offsetZ) + Math.floor((extent - featureExtent[1]) / tileSize);\r\n        return [minX, minY, maxX, maxY];\r\n    };\r\n    GeoMVTFormat.prototype.getExtent = function (originalCoord, tilecoord, extent) {\r\n        var ox = originalCoord[1];\r\n        var x = tilecoord[1];\r\n        var xPath = [];\r\n        while (ox !== x) {\r\n            var remainder = ox % 2;\r\n            xPath.push(remainder);\r\n            ox = Math.floor(ox / 2);\r\n        }\r\n        var newExtent = extent;\r\n        var offsetX = 0;\r\n        for (var i = xPath.length - 1; i >= 0; i--) {\r\n            newExtent = newExtent / 2;\r\n            if (xPath[i] === 1) {\r\n                offsetX += newExtent;\r\n            }\r\n        }\r\n        var oy = originalCoord[2];\r\n        var y = tilecoord[2];\r\n        var yPath = [];\r\n        while (oy !== y) {\r\n            var remainder = oy % 2;\r\n            yPath.push(remainder);\r\n            oy = Math.floor(oy / 2);\r\n        }\r\n        newExtent = extent;\r\n        var offsetY = 0;\r\n        for (var i = yPath.length - 1; i >= 0; i--) {\r\n            newExtent = newExtent / 2;\r\n            if (yPath[i] === 0) {\r\n                offsetY += newExtent;\r\n            }\r\n        }\r\n        // TODO: add the buffer\r\n        return [offsetX, offsetY, offsetX + newExtent, offsetY + newExtent];\r\n    };\r\n    GeoMVTFormat.prototype.replaceFiltersToIndexOfPbfLayer = function (cacheTrees, pbfLayer) {\r\n        for (var i = 0, ii = cacheTrees.length; i < ii; i++) {\r\n            var cacheTree = cacheTrees[i];\r\n            this.replaceCacheItemFiltersToIndexOfPbfLayer(cacheTree.root, pbfLayer);\r\n        }\r\n    };\r\n    GeoMVTFormat.prototype.replaceCacheItemFiltersToIndexOfPbfLayer = function (node, pbfLayer) {\r\n        var data = node.data;\r\n        for (var i = 0; i < data.filterGroup.length; i++) {\r\n            var filters = data.filterGroup[i];\r\n            var geoFilter = void 0;\r\n            for (var j = 0; j < filters.length; j++) {\r\n                geoFilter = filters[j];\r\n                geoFilter.replaceVaulesToPbfIndex(pbfLayer);\r\n            }\r\n        }\r\n        if (node.children) {\r\n            for (var i = 0, ii = node.children.length; i < ii; i++) {\r\n                this.replaceCacheItemFiltersToIndexOfPbfLayer(node.children[i], pbfLayer);\r\n            }\r\n        }\r\n    };\r\n    GeoMVTFormat.prototype.readFeaturesAndCreateInstructs = function (source, zoom, options) {\r\n        var pbf = new ol.ext.PBF((source));\r\n        var pbfLayers = pbf.readFields(ol.format.MVT.pbfReaders_.layers, {});\r\n        var features = [];\r\n        var pbfLayer;\r\n        var zoomMatchedGeoStylesGroupByLayerId = this.styleJsonCache.geoStyleGroupByZoom[zoom];\r\n        if (!zoomMatchedGeoStylesGroupByLayerId) {\r\n            return features;\r\n        }\r\n        var pbfLayerNamesWithGeoStyle = [];\r\n        for (var pbfLayerName in zoomMatchedGeoStylesGroupByLayerId) {\r\n            pbfLayerNamesWithGeoStyle.push(pbfLayerName);\r\n        }\r\n        var instructsCache = [];\r\n        for (var name_3 in pbfLayers) {\r\n            if (this.layers_ && this.layers_.indexOf(name_3) === -1) {\r\n                continue;\r\n            }\r\n            if (pbfLayerNamesWithGeoStyle.indexOf(name_3) === -1) {\r\n                continue;\r\n            }\r\n            pbfLayer = pbfLayers[name_3];\r\n            var cacheTrees = zoomMatchedGeoStylesGroupByLayerId[name_3];\r\n            if (cacheTrees && cacheTrees.length > 0) {\r\n                this.replaceFiltersToIndexOfPbfLayer(cacheTrees, pbfLayer);\r\n                var _loop_5 = function (i) {\r\n                    var rawFeature = ol.format.MVT.readRawFeature_(pbf, pbfLayer, i);\r\n                    var feature = void 0;\r\n                    var _loop_6 = function (j) {\r\n                        var cacheTree = cacheTrees[j];\r\n                        var treeIndex = cacheTree.treeIndex;\r\n                        if (instructsCache[treeIndex] === undefined) {\r\n                            instructsCache[treeIndex] = {\r\n                                min: 10,\r\n                                max: -10\r\n                            };\r\n                        }\r\n                        var matchedNode;\r\n                        var checkNodeMatched = function (node) {\r\n                            var styleJsonCacheItem = node.data;\r\n                            var matched = false;\r\n                            if (styleJsonCacheItem.filterGroup.length > 0) {\r\n                                for (var i_4 = 0; i_4 < styleJsonCacheItem.filterGroup.length; i_4++) {\r\n                                    var filters = styleJsonCacheItem.filterGroup[i_4];\r\n                                    var groupMatched = true;\r\n                                    for (var j_3 = 0; j_3 < filters.length; j_3++) {\r\n                                        var filter = filters[j_3];\r\n                                        if (!filter.matchOLFeature(rawFeature, zoom)) {\r\n                                            groupMatched = false;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (groupMatched) {\r\n                                        matched = true;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                matched = true;\r\n                            }\r\n                            return matched;\r\n                        };\r\n                        var selectNode = function (node) {\r\n                            matchedNode = node.data;\r\n                        };\r\n                        cacheTree.traverseNode(checkNodeMatched, selectNode);\r\n                        if (matchedNode) {\r\n                            if (feature === undefined) {\r\n                                feature = this_3.createFeature_(pbf, rawFeature);\r\n                                if (this_3.minimalist) {\r\n                                    feature.properties_ = {};\r\n                                }\r\n                            }\r\n                            var zindex = void 0;\r\n                            if (cacheTree.root.data.zIndex) {\r\n                                zindex = rawFeature.properties[cacheTree.root.data.zIndex];\r\n                                feature.properties_[cacheTree.root.data.zIndex] = zindex;\r\n                            }\r\n                            if (isNaN(zindex)) {\r\n                                zindex = 0;\r\n                            }\r\n                            if (instructsCache[treeIndex][zindex] === undefined) {\r\n                                instructsCache[treeIndex][zindex] = [];\r\n                                if (zindex < instructsCache[treeIndex][\"min\"]) {\r\n                                    instructsCache[treeIndex][\"min\"] = zindex;\r\n                                }\r\n                                if (zindex > instructsCache[treeIndex][\"max\"]) {\r\n                                    instructsCache[treeIndex][\"max\"] = zindex;\r\n                                }\r\n                            }\r\n                            instructsCache[treeIndex][zindex].push([feature, matchedNode]);\r\n                            if (this_3.minimalist) {\r\n                                if (matchedNode.geoStyle && matchedNode.geoStyle.constructor.name === \"GeoTextStyle\") {\r\n                                    feature.properties_[matchedNode.geoStyle.name] = rawFeature.properties[matchedNode.geoStyle.name];\r\n                                }\r\n                                if (matchedNode.childrenGeoStyles && matchedNode.childrenGeoStyles.length > 0) {\r\n                                    for (var i_5 = 0; i_5 < matchedNode.childrenGeoStyles.length; i_5++) {\r\n                                        feature.properties_[matchedNode.childrenGeoStyles[i_5].name] = rawFeature.properties[matchedNode.childrenGeoStyles[i_5].name];\r\n                                    }\r\n                                }\r\n                            }\r\n                            feature.extent_ = undefined;\r\n                        }\r\n                    };\r\n                    for (var j = 0; j < cacheTrees.length; j++) {\r\n                        _loop_6(j);\r\n                    }\r\n                };\r\n                var this_3 = this;\r\n                for (var i = 0; i < pbfLayer.length; i++) {\r\n                    _loop_5(i);\r\n                }\r\n            }\r\n            this.extent_ = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;\r\n        }\r\n        var instructs = [];\r\n        // the tress index means the index of SyleId.\r\n        for (var i = 0; i < instructsCache.length; i++) {\r\n            var instructsInOneTree = instructsCache[i];\r\n            if (instructsInOneTree) {\r\n                for (var j = instructsInOneTree.min, jj = instructsInOneTree.max; j <= jj; j++) {\r\n                    var instructsInOneZIndex = instructsInOneTree[j];\r\n                    if (instructsInOneZIndex) {\r\n                        var childrenInstructs = [];\r\n                        for (var h = 0; h < instructsInOneZIndex.length; h++) {\r\n                            var instruct = instructsInOneZIndex[h];\r\n                            instruct[0].styleId = instruct[0].styleId ? instruct[0].styleId : {};\r\n                            if (instruct[1].geoStyle) {\r\n                                instruct[0].styleId[instruct[1].geoStyle.id] = 0;\r\n                                instructs.push([instruct[0], instruct[1].geoStyle, i]);\r\n                            }\r\n                            if (instruct[1].childrenGeoStyles) {\r\n                                for (var k = 0; k < instruct[1].childrenGeoStyles.length; k++) {\r\n                                    instruct[0].styleId[instruct[1].childrenGeoStyles[k].id] = 1;\r\n                                    childrenInstructs.push([instruct[0], instruct[1].childrenGeoStyles[k], i]);\r\n                                }\r\n                            }\r\n                        }\r\n                        Array.prototype.push.apply(instructs, childrenInstructs);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return [features, instructs];\r\n    };\r\n    GeoMVTFormat.readRawFeature_ = function (pbf, layer, i) {\r\n        pbf.pos = layer.features[i];\r\n        var end = pbf.readVarint() + pbf.pos;\r\n        var feature = {\r\n            layer: layer,\r\n            type: 0,\r\n            properties: {},\r\n            propertiesIndex: {}\r\n        };\r\n        pbf.readFields(ol.format.MVT.pbfReaders_.featureColumnValue, feature, end);\r\n        return feature;\r\n    };\r\n    GeoMVTFormat.featureColumnValue = function (tag, feature, pbf) {\r\n        if (tag === 1) {\r\n            feature.id = pbf.readVarint();\r\n        }\r\n        else if (tag === 2) {\r\n            var end = pbf.readVarint() + pbf.pos;\r\n            while (pbf.pos < end) {\r\n                var key = pbf.readVarint();\r\n                var value = pbf.readVarint();\r\n                feature.propertiesIndex[key] = value;\r\n                key = feature.layer.keys[key];\r\n                value = feature.layer.values[value];\r\n                feature.properties[key] = value;\r\n            }\r\n        }\r\n        else if (tag === 3) {\r\n            feature.type = pbf.readVarint();\r\n        }\r\n        else if (tag === 4) {\r\n            feature.geometry = pbf.pos;\r\n        }\r\n    };\r\n    return GeoMVTFormat;\r\n}(ol.format.MVT));\r\n\r\nol.format.MVT.readRawFeature_ = GeoMVTFormat.readRawFeature_;\r\nol.format.MVT.pbfReaders_[\"featureColumnValue\"] = GeoMVTFormat.featureColumnValue;\r\n\n\n//# sourceURL=webpack:///./src/format/geoMvt.ts?");

/***/ }),

/***/ "./src/geoVectorTile.ts":
/*!******************************!*\
  !*** ./src/geoVectorTile.ts ***!
  \******************************/
/*! exports provided: GeoVectorTile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoVectorTile\", function() { return GeoVectorTile; });\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar GeoVectorTile = /** @class */ (function (_super) {\r\n    __extends(GeoVectorTile, _super);\r\n    function GeoVectorTile(tileCoord, state, src, format, tileLoadFunction) {\r\n        var _this = _super.call(this, tileCoord, state, src, format, tileLoadFunction) || this;\r\n        _this.disposeInternal = _this.disposeInternalCustom;\r\n        return _this;\r\n    }\r\n    GeoVectorTile.prototype.disposeInternalCustom = function () {\r\n        this.features_ = null;\r\n        this.replayGroups_ = {};\r\n        // this.state = ol.TileState.ABORT;\r\n        this.state = ol.TileState.IDLE;\r\n        this.changed();\r\n        if (this[\"xhr\"] != undefined) {\r\n            this[\"xhr\"].abort();\r\n        }\r\n        if (this.workerId !== undefined) {\r\n            var disposeInfo = {\r\n                formatId: ol.getUid(this.getFormat()),\r\n                maxDataZoom: this.getFormat().maxDataZoom,\r\n                tileCoord: this.tileCoord,\r\n                requestTileCoord: this.requestTileCoord\r\n            };\r\n            this.getFormat().workerManager.postMessage(this.tileCoord + ol.getUid(disposeInfo), \"vectorTileDispose\", disposeInfo, null, this.workerId);\r\n        }\r\n        ol.Tile.prototype.disposeInternal.call(this);\r\n    };\r\n    GeoVectorTile.prototype.onLoad = function (dataProjection, extent) {\r\n        this.setProjection(dataProjection);\r\n        this.setFeatures();\r\n        this.setExtent(extent);\r\n    };\r\n    GeoVectorTile.prototype.setRenderFeatureInstructs = function (instructs) {\r\n        this.instructs = instructs;\r\n    };\r\n    GeoVectorTile.prototype.getRenderFeatureInstructs = function (instructs) {\r\n        return this.instructs;\r\n    };\r\n    return GeoVectorTile;\r\n}(ol.VectorTile));\r\n\r\n\n\n//# sourceURL=webpack:///./src/geoVectorTile.ts?");

/***/ }),

/***/ "./src/layer/vectorTileLayer.ts":
/*!**************************************!*\
  !*** ./src/layer/vectorTileLayer.ts ***!
  \**************************************/
/*! exports provided: VectorTileLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VectorTileLayer\", function() { return VectorTileLayer; });\n/* harmony import */ var _source_geoVectorTileSource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../source/geoVectorTileSource */ \"./src/source/geoVectorTileSource.ts\");\n/* harmony import */ var _geoVectorTile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geoVectorTile */ \"./src/geoVectorTile.ts\");\n/* harmony import */ var _style_geoStyle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../style/geoStyle */ \"./src/style/geoStyle.ts\");\n/* harmony import */ var _format_geoMvt__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../format/geoMvt */ \"./src/format/geoMvt.ts\");\n/* harmony import */ var _tree_styleJsonCache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tree/styleJsonCache */ \"./src/tree/styleJsonCache.ts\");\n/* harmony import */ var _tree_styleJsonCacheItem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tree/styleJsonCacheItem */ \"./src/tree/styleJsonCacheItem.ts\");\n/* harmony import */ var _render_geoVectorTilelayerRender__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../render/geoVectorTilelayerRender */ \"./src/render/geoVectorTilelayerRender.ts\");\n/* harmony import */ var _tree_TreeNode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tree/TreeNode */ \"./src/tree/TreeNode.ts\");\n/* harmony import */ var _tree_tree__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tree/tree */ \"./src/tree/tree.ts\");\n/* harmony import */ var _worker_workerManager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../worker/workerManager */ \"./src/worker/workerManager.ts\");\n/* harmony import */ var _worker_vectorTileLayerThreadMode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../worker/vectorTileLayerThreadMode */ \"./src/worker/vectorTileLayerThreadMode.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar VectorTileLayer = /** @class */ (function (_super) {\r\n    __extends(VectorTileLayer, _super);\r\n    function VectorTileLayer(styleJson, opt_options) {\r\n        var _this = this;\r\n        // default\r\n        if (opt_options !== undefined) {\r\n            opt_options[\"declutter\"] = opt_options[\"declutter\"] === undefined ? true : opt_options[\"declutter\"];\r\n            opt_options[\"minimalist\"] = opt_options[\"minimalist\"] === undefined ? true : opt_options[\"minimalist\"];\r\n            _this = _super.call(this, opt_options) || this;\r\n        }\r\n        else {\r\n            var options = {};\r\n            options[\"declutter\"] = true;\r\n            options[\"minimalist\"] = true;\r\n            _this = _super.call(this, options) || this;\r\n        }\r\n        if (opt_options !== undefined) {\r\n            // temp Emil\r\n            var tempIsMultithread = opt_options[\"multithread\"] === undefined ? true : opt_options[\"multithread\"];\r\n            _this.threadMode = opt_options[\"threadMode\"] === undefined ? true : opt_options[\"threadMode\"];\r\n            _this.isMultithread = _this.threadMode !== _worker_vectorTileLayerThreadMode__WEBPACK_IMPORTED_MODULE_10__[\"VectorTileLayerThreadMode\"].SingleThread;\r\n            _this.backgroundWorkerCount = opt_options[\"backgroundWorkerCount\"];\r\n            // temp Emil\r\n            if (tempIsMultithread) {\r\n                _this.threadMode = _worker_vectorTileLayerThreadMode__WEBPACK_IMPORTED_MODULE_10__[\"VectorTileLayerThreadMode\"].Default;\r\n                _this.backgroundWorkerCount = 1;\r\n            }\r\n            _this.minimalist = opt_options[\"minimalist\"] === undefined ? true : opt_options[\"minimalist\"];\r\n            _this.maxDataZoom = opt_options[\"maxDataZoom\"] === undefined ? 14 : opt_options[\"maxDataZoom\"];\r\n            _this.proxy = opt_options[\"proxy\"];\r\n            _this.clientId = opt_options[\"clientId\"];\r\n            _this.clientSecret = opt_options[\"clientSecret\"];\r\n            _this.apiKey = opt_options[\"apiKey\"];\r\n        }\r\n        else {\r\n            _this.isMultithread = true;\r\n            _this.minimalist = true;\r\n            _this.maxDataZoom = 14;\r\n        }\r\n        _this.registerGeoVector();\r\n        if (_this.isStyleJsonUrl(styleJson)) {\r\n            _this.loadStyleJsonAsyn(styleJson);\r\n        }\r\n        else {\r\n            _this.loadStyleJson(styleJson);\r\n        }\r\n        _this.type = ol.LayerType.MAPSUITE_VECTORTILE;\r\n        return _this;\r\n    }\r\n    VectorTileLayer.prototype.loadStyleJsonAsyn = function (styleJsonUrl) {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open(\"GET\", styleJsonUrl, false);\r\n        xhr.onload = function (event) {\r\n            if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {\r\n                var source = void 0;\r\n                source = xhr.responseText;\r\n                this.styleJson = JSON.parse(source);\r\n                this.loadStyleJson(JSON.parse(source));\r\n            }\r\n        }.bind(this);\r\n        xhr.onerror = function () {\r\n        }.bind(this);\r\n        xhr.send();\r\n    };\r\n    VectorTileLayer.prototype.loadStyleJson = function (inputStyleJson) {\r\n        var styleJson = this.styleJson = JSON.parse(JSON.stringify(inputStyleJson));\r\n        this.version = styleJson[\"version\"];\r\n        this.owner = styleJson[\"owner\"];\r\n        this.dateTime = styleJson[\"dateTime\"];\r\n        this.variables = this.getVariables(styleJson[\"variables\"]);\r\n        this.background = styleJson[\"background\"];\r\n        this.replaceVariables(styleJson, this.variables);\r\n        this.geoSources = {};\r\n        if (styleJson[\"layers\"] && styleJson[\"layers\"].length > 0) {\r\n            var layerJson = styleJson[\"layers\"][0];\r\n            var sourceId = layerJson[\"source\"];\r\n            var source = this.getGeoSource(sourceId);\r\n            if (source) {\r\n                this.setSource(source);\r\n                if (this.background) {\r\n                    var backgroundColor = _style_geoStyle__WEBPACK_IMPORTED_MODULE_2__[\"GeoStyle\"].toRGBAColor(this.background);\r\n                    if (backgroundColor) {\r\n                        this[\"background\"] = backgroundColor;\r\n                    }\r\n                }\r\n                var styleJsons = styleJson[\"styles\"];\r\n                var styleIds = layerJson[\"styles\"];\r\n                var minZoom = 0;\r\n                var maxZoom = 22;\r\n                var layerName = source.getGeoFormat().getLayerName();\r\n                var styleJsonCache = new _tree_styleJsonCache__WEBPACK_IMPORTED_MODULE_4__[\"StyleJsonCache\"]();\r\n                var styleIdIndex = 0;\r\n                for (var _i = 0, styleIds_1 = styleIds; _i < styleIds_1.length; _i++) {\r\n                    var styleId = styleIds_1[_i];\r\n                    var styleJson_1 = void 0;\r\n                    for (var index = 0; index < styleJsons.length; index++) {\r\n                        if (styleJsons[index].id === styleId) {\r\n                            styleJson_1 = styleJsons[index];\r\n                        }\r\n                    }\r\n                    if (styleJson_1) {\r\n                        styleJsonCache.styleJson[styleId] = styleJson_1;\r\n                        var item = new _tree_styleJsonCacheItem__WEBPACK_IMPORTED_MODULE_5__[\"StyleJsonCacheItem\"](styleJson_1, minZoom, maxZoom, layerName);\r\n                        for (var zoom = item.minZoom; zoom <= item.maxZoom; zoom++) {\r\n                            var treeNode = new _tree_TreeNode__WEBPACK_IMPORTED_MODULE_7__[\"TreeNode\"](item);\r\n                            this.createChildrenNode(treeNode, item, zoom);\r\n                            styleJsonCache.add(zoom, item.dataLayerName, new _tree_tree__WEBPACK_IMPORTED_MODULE_8__[\"Tree\"](treeNode, styleIdIndex));\r\n                        }\r\n                        styleIdIndex += 1;\r\n                    }\r\n                }\r\n                var geoFormat = source.getGeoFormat();\r\n                geoFormat[\"styleJsonCache\"] = styleJsonCache;\r\n                if (this.isMultithread) {\r\n                    if (this.workerManager) {\r\n                        var messageData = {\r\n                            formatId: ol.getUid(geoFormat),\r\n                            styleJson: styleJsonCache.styleJson,\r\n                            geoTextStyleInfos: styleJsonCache.geoTextStyleInfo\r\n                        };\r\n                        for (var i = 0; i < this.workerManager.workerCount; i++) {\r\n                            this.workerManager.postMessage(ol.getUid(messageData), \"initStyleJSON\", messageData, undefined, i);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    VectorTileLayer.prototype.getGeoSource = function (sourceId) {\r\n        var _this = this;\r\n        if (this.geoSources && this.geoSources[sourceId]) {\r\n            return this.geoSources[sourceId];\r\n        }\r\n        if (this.styleJson[\"sources\"]) {\r\n            this.styleJson['sources'].forEach(function (sourceJson) {\r\n                if (sourceId === sourceJson['id']) {\r\n                    if (!sourceJson['urls'] && sourceJson['url']) {\r\n                        sourceJson['urls'] = [sourceJson['url']];\r\n                        delete sourceJson['url'];\r\n                    }\r\n                    sourceJson['urls'] = sourceJson['urls'].map(function (url) {\r\n                        if (url.indexOf('http') === -1 && url.indexOf('https') === -1) {\r\n                            var host = location.host;\r\n                            var protocol = location.protocol;\r\n                            if (url.indexOf('/') !== 0) {\r\n                                url = protocol + '//' + host + '/' + url;\r\n                            }\r\n                            else if (url.indexOf('/') === 0) {\r\n                                url = protocol + '//' + host + url;\r\n                            }\r\n                        }\r\n                        // apiKey\r\n                        if (url.indexOf('apiKey') === -1 && _this.apiKey) {\r\n                            url = url + '?apiKey=' + _this.apiKey;\r\n                        }\r\n                        // proxy\r\n                        if (_this.proxy) {\r\n                            url = _this.proxy + encodeURIComponent(url);\r\n                        }\r\n                        return url;\r\n                    });\r\n                    _this.geoSources[sourceJson[\"id\"]] = _this.createVectorTileSource(sourceJson);\r\n                    return true;\r\n                }\r\n            });\r\n            return this.geoSources[sourceId];\r\n        }\r\n        return false;\r\n    };\r\n    VectorTileLayer.prototype.createVectorTileSource = function (sourceJson) {\r\n        if (sourceJson[\"type\"] === \"MVT\") {\r\n            var format = this.getVectorSourceFormat();\r\n            var source = new _source_geoVectorTileSource__WEBPACK_IMPORTED_MODULE_0__[\"GeoVectorTileSource\"]({\r\n                tileClass: _geoVectorTile__WEBPACK_IMPORTED_MODULE_1__[\"GeoVectorTile\"],\r\n                urls: sourceJson[\"urls\"],\r\n                clientId: this.clientId,\r\n                clientSecret: this.clientSecret,\r\n                format: format,\r\n                projection: \"EPSG:3857\",\r\n                tileGrid: this.createVectorTileGrid(),\r\n                cacheSize: 1024,\r\n                multithread: this.isMultithread,\r\n                minimalist: this.minimalist,\r\n                maxDataZoom: this.maxDataZoom\r\n            });\r\n            format['source'] = source;\r\n            return source;\r\n        }\r\n    };\r\n    VectorTileLayer.prototype.getVectorSourceFormat = function () {\r\n        var format = new _format_geoMvt__WEBPACK_IMPORTED_MODULE_3__[\"GeoMVTFormat\"](undefined, { multithread: this.isMultithread, minimalist: this.minimalist });\r\n        if (this.isMultithread) {\r\n            if (!this.workerManager || !this.workerManager.inited) {\r\n                this.workerManager = new _worker_workerManager__WEBPACK_IMPORTED_MODULE_9__[\"WorkerManager\"](this.threadMode, this.backgroundWorkerCount);\r\n                this.workerManager.initWorkers();\r\n            }\r\n            if (this.workerManager.inited) {\r\n                format[\"workerManager\"] = this.workerManager;\r\n            }\r\n        }\r\n        return format;\r\n    };\r\n    VectorTileLayer.prototype.createVectorTileGrid = function () {\r\n        return ol.tilegrid.createXYZ({ tileSize: 512, maxZoom: 22 });\r\n    };\r\n    VectorTileLayer.prototype.getVariables = function (variablesJson) {\r\n        var variables = {};\r\n        for (var variablesName in variablesJson) {\r\n            if (variablesName.indexOf(\",\") > 0) {\r\n                var variableNames = variablesName.split(\",\");\r\n                for (var i = 0; i < variableNames.length; i++) {\r\n                    variables[variableNames[i]] = variablesJson[variablesName];\r\n                }\r\n            }\r\n            else {\r\n                variables[variablesName] = variablesJson[variablesName];\r\n            }\r\n        }\r\n        return variables;\r\n    };\r\n    VectorTileLayer.prototype.replaceVariables = function (styleJson, variables) {\r\n        for (var propertyName in styleJson) {\r\n            var property = styleJson[propertyName];\r\n            if (typeof property === \"object\") {\r\n                this.replaceVariables(property, variables);\r\n            }\r\n            else if (typeof property === \"string\") {\r\n                var keyWordIndex = property.indexOf(\"@\");\r\n                if (keyWordIndex >= 0) {\r\n                    var lines = property.split(\" \");\r\n                    if (lines.length > 1) {\r\n                        var tempWord = void 0;\r\n                        var results = [];\r\n                        for (var i = 0; i < lines.length; i++) {\r\n                            tempWord = lines[i];\r\n                            if (tempWord.indexOf(\"@\") === 0) {\r\n                                tempWord = variables[tempWord];\r\n                            }\r\n                            results.push(tempWord);\r\n                        }\r\n                        styleJson[propertyName] = results.join(\" \");\r\n                    }\r\n                    else {\r\n                        styleJson[propertyName] = variables[lines[0]];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    VectorTileLayer.prototype.createChildrenNode = function (currentNode, item, zoom) {\r\n        if (item.subStyleCacheItems && item.subStyleCacheItems.length > 0) {\r\n            for (var i = 0, ii = item.subStyleCacheItems.length; i < ii; i++) {\r\n                var subStyleItem = item.subStyleCacheItems[i];\r\n                if (zoom >= subStyleItem.minZoom && zoom <= subStyleItem.maxZoom) {\r\n                    var node = new _tree_TreeNode__WEBPACK_IMPORTED_MODULE_7__[\"TreeNode\"](subStyleItem);\r\n                    currentNode.children.push(node);\r\n                    this.createChildrenNode(node, subStyleItem, zoom);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    VectorTileLayer.prototype.isStyleJsonUrl = function (styleJson) {\r\n        if (styleJson) {\r\n            if (typeof styleJson !== \"object\") {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    VectorTileLayer.prototype.registerGeoVector = function () {\r\n        ol.LayerType[\"GEOVECTORTILE\"] = \"GEOVECTORTILE\";\r\n        // TODO: check the plugin had been registed.\r\n        ol.plugins.register(ol.PluginType.LAYER_RENDERER, _render_geoVectorTilelayerRender__WEBPACK_IMPORTED_MODULE_6__[\"GeoVectorTileLayerRender\"]);\r\n        // (<any>ol.VectorTile).Event = function (type, xhr) {\r\n        //     ol.events.Event.call(this, type);\r\n        //     this.xhr = xhr;\r\n        // };\r\n        // ol.inherits((<any>ol.VectorTile), (<any>ol.events).Event);\r\n        ol.VectorImageTile.prototype.disposeInternal = function () {\r\n            for (var i = 0, ii = this.tileKeys.length; i < ii; ++i) {\r\n                var sourceTileKey = this.tileKeys[i];\r\n                var sourceTile = this.getTile(sourceTileKey);\r\n                sourceTile.consumers--;\r\n                if (sourceTile.consumers == 0) {\r\n                    delete this.sourceTiles_[sourceTileKey];\r\n                    sourceTile.dispose();\r\n                }\r\n            }\r\n            this.sourceTiles_ = null;\r\n            this.loadListenerKeys_.forEach(ol.events.unlistenByKey);\r\n            this.loadListenerKeys_.length = 0;\r\n            if (this.interimTile) {\r\n                this.interimTile.dispose();\r\n            }\r\n            this.state = ol.TileState.ABORT;\r\n            this.changed();\r\n            // for the disposeInternal\r\n            this.tileKeys.length = 0;\r\n            this.sourceTileListenerKeys_.forEach(ol.events.unlistenByKey);\r\n            this.sourceTileListenerKeys_.length = 0;\r\n            ol.Tile.prototype.disposeInternal.call(this);\r\n        };\r\n        ol.TileQueue.prototype.handleTileChange = function (event) {\r\n            var tile = /** @type {ol.Tile} */ (event.target);\r\n            var state = tile.getState();\r\n            if (state === ol.TileState.LOADED || state === ol.TileState.ERROR ||\r\n                state === ol.TileState.EMPTY || state === ol.TileState.ABORT ||\r\n                state === ol.TileState.CANCEL) {\r\n                if (state === ol.TileState.ABORT || state === ol.TileState.ERROR) {\r\n                    ol.events.unlisten(tile, ol.events.EventType.CHANGE, this.handleTileChange, this);\r\n                }\r\n                var tileKey = tile.getKey();\r\n                if (tileKey in this.tilesLoadingKeys_) {\r\n                    delete this.tilesLoadingKeys_[tileKey];\r\n                    --this.tilesLoading_;\r\n                }\r\n                // Remove the enqueue records, if the tile has been dispose before load\r\n                if (tileKey in this.queuedElements_) {\r\n                    delete this.queuedElements_[tileKey];\r\n                }\r\n                this.tileChangeCallback_();\r\n            }\r\n        };\r\n        // remove quickZoom when animation complete\r\n        ol.View.prototype.updateAnimations_ = function () {\r\n            if (this.updateAnimationKey_ !== undefined) {\r\n                cancelAnimationFrame(this.updateAnimationKey_);\r\n                this.updateAnimationKey_ = undefined;\r\n            }\r\n            if (!this.getAnimating()) {\r\n                return;\r\n            }\r\n            var now = Date.now();\r\n            var more = false;\r\n            for (var i = this.animations_.length - 1; i >= 0; --i) {\r\n                var series = this.animations_[i];\r\n                var seriesComplete = true;\r\n                for (var j = 0, jj = series.length; j < jj; ++j) {\r\n                    var animation = series[j];\r\n                    if (animation.complete) {\r\n                        continue;\r\n                    }\r\n                    var elapsed = now - animation.start;\r\n                    var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;\r\n                    if (fraction >= 1) {\r\n                        animation.complete = true;\r\n                        fraction = 1;\r\n                    }\r\n                    else {\r\n                        seriesComplete = false;\r\n                    }\r\n                    var progress = animation.easing(fraction);\r\n                    if (animation.sourceCenter) {\r\n                        var x0 = animation.sourceCenter[0];\r\n                        var y0 = animation.sourceCenter[1];\r\n                        var x1 = animation.targetCenter[0];\r\n                        var y1 = animation.targetCenter[1];\r\n                        var x = x0 + progress * (x1 - x0);\r\n                        var y = y0 + progress * (y1 - y0);\r\n                        this.set(ol.ViewProperty.CENTER, [x, y]);\r\n                    }\r\n                    if (animation.sourceResolution && animation.targetResolution) {\r\n                        var resolution = progress === 1 ?\r\n                            animation.targetResolution :\r\n                            animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);\r\n                        if (animation.anchor) {\r\n                            this.set(ol.ViewProperty.CENTER, this.calculateCenterZoom(resolution, animation.anchor));\r\n                        }\r\n                        this.set(ol.ViewProperty.RESOLUTION, resolution);\r\n                    }\r\n                    if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {\r\n                        var rotation = progress === 1 ?\r\n                            ol.math.modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI :\r\n                            animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);\r\n                        if (animation.anchor) {\r\n                            this.set(ol.ViewProperty.CENTER, this.calculateCenterRotate(rotation, animation.anchor));\r\n                        }\r\n                        this.set(ol.ViewProperty.ROTATION, rotation);\r\n                    }\r\n                    more = true;\r\n                    if (!animation.complete) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (seriesComplete) {\r\n                    this.animations_[i] = null;\r\n                    this.setHint(ol.ViewHint.ANIMATING, -1);\r\n                    var callback = series[0].callback;\r\n                    if (callback) {\r\n                        callback(true);\r\n                    }\r\n                }\r\n            }\r\n            // prune completed series\r\n            this.animations_ = this.animations_.filter(Boolean);\r\n            if (more && this.updateAnimationKey_ === undefined) {\r\n                this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);\r\n            }\r\n        };\r\n        // Get quickZoom zoom in/out\r\n        ol.View.prototype.animate = function (var_args) {\r\n            var animationCount = arguments.length;\r\n            var callback;\r\n            if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {\r\n                callback = arguments[animationCount - 1];\r\n                --animationCount;\r\n            }\r\n            if (!this.isDef()) {\r\n                // if view properties are not yet set, shortcut to the final state\r\n                var state = arguments[animationCount - 1];\r\n                if (state.center) {\r\n                    this.setCenter(state.center);\r\n                }\r\n                if (state.zoom !== undefined) {\r\n                    this.setZoom(state.zoom);\r\n                }\r\n                if (state.rotation !== undefined) {\r\n                    this.setRotation(state.rotation);\r\n                }\r\n                if (callback) {\r\n                    callback(true);\r\n                }\r\n                return;\r\n            }\r\n            var start = Date.now();\r\n            var center = this.getCenter().slice();\r\n            var resolution = this.getResolution();\r\n            var rotation = this.getRotation();\r\n            var series = [];\r\n            var quickZoom = false;\r\n            for (var i = 0; i < animationCount; ++i) {\r\n                var options = /** @type {olx.AnimationOptions} */ (arguments[i]);\r\n                var animation = /** @type {ol.ViewAnimation} */ ({\r\n                    start: start,\r\n                    complete: false,\r\n                    anchor: options.anchor,\r\n                    duration: options.duration !== undefined ? options.duration : 1000,\r\n                    easing: options.easing || ol.easing.inAndOut\r\n                });\r\n                if (options.center) {\r\n                    animation[\"sourceCenter\"] = center;\r\n                    animation[\"targetCenter\"] = options.center;\r\n                    center = animation[\"targetCenter\"];\r\n                }\r\n                if (options.zoom !== undefined) {\r\n                    animation[\"sourceResolution\"] = resolution;\r\n                    animation[\"targetResolution\"] = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_, 0);\r\n                    resolution = animation[\"targetResolution\"];\r\n                    if (!quickZoom) {\r\n                        quickZoom = Math.abs(animation[\"sourceResolution\"] - animation[\"targetResolution\"]) * 2 >= animation[\"sourceResolution\"];\r\n                    }\r\n                }\r\n                else if (options.resolution) {\r\n                    animation[\"sourceResolution\"] = resolution;\r\n                    animation[\"targetResolution\"] = options.resolution;\r\n                    resolution = animation[\"targetResolution\"];\r\n                    if (!quickZoom) {\r\n                        quickZoom = Math.abs(animation[\"sourceResolution\"] - animation[\"targetResolution\"]) * 2 >= animation[\"sourceResolution\"];\r\n                    }\r\n                }\r\n                if (options.rotation !== undefined) {\r\n                    animation[\"sourceRotation\"] = rotation;\r\n                    var delta = ol.math.modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\r\n                    animation[\"targetRotation\"] = rotation + delta;\r\n                    rotation = animation[\"targetRotation\"];\r\n                }\r\n                animation[\"callback\"] = callback;\r\n                // check if animation is a no-op\r\n                if (ol.View.isNoopAnimation(animation)) {\r\n                    animation.complete = true;\r\n                    // we still push it onto the series for callback handling\r\n                }\r\n                else {\r\n                    start += animation.duration;\r\n                }\r\n                series.push(animation);\r\n            }\r\n            this.animations_.push(series);\r\n            this[\"quickZoom\"] = quickZoom;\r\n            this.setHint(ol.ViewHint.ANIMATING, 1);\r\n            this.updateAnimations_();\r\n        };\r\n        // add quickZoom into frameState\r\n        ol.PluggableMap.prototype.renderFrame_ = function (time) {\r\n            var i, ii, viewState;\r\n            var size = this.getSize();\r\n            var view = this.getView();\r\n            var extent = ol.extent.createEmpty();\r\n            var previousFrameState = this.frameState_;\r\n            /** @type {?olx.FrameState} */\r\n            var frameState = null;\r\n            if (size !== undefined && ol.size.hasArea(size) && view && view.isDef()) {\r\n                var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\r\n                var quickZoom = view[\"quickZoom\"];\r\n                var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\r\n                var layerStates = {};\r\n                for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {\r\n                    layerStates[ol.getUid(layerStatesArray[i].layer)] = layerStatesArray[i];\r\n                }\r\n                viewState = view.getState();\r\n                var center = viewState.center;\r\n                var pixelResolution = viewState.resolution / this.pixelRatio_;\r\n                center[0] = Math.round(center[0] / pixelResolution) * pixelResolution;\r\n                center[1] = Math.round(center[1] / pixelResolution) * pixelResolution;\r\n                frameState = /** @type {olx.FrameState} */ ({\r\n                    animate: false,\r\n                    coordinateToPixelTransform: this.coordinateToPixelTransform_,\r\n                    extent: extent,\r\n                    focus: !this.focus_ ? center : this.focus_,\r\n                    index: this.frameIndex_++,\r\n                    layerStates: layerStates,\r\n                    layerStatesArray: layerStatesArray,\r\n                    logos: ol.obj.assign({}, this.logos_),\r\n                    pixelRatio: this.pixelRatio_,\r\n                    pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\r\n                    postRenderFunctions: [],\r\n                    size: size,\r\n                    skippedFeatureUids: this.skippedFeatureUids_,\r\n                    tileQueue: this.tileQueue_,\r\n                    time: time,\r\n                    usedTiles: {},\r\n                    viewState: viewState,\r\n                    viewHints: viewHints,\r\n                    quickZoom: quickZoom,\r\n                    currentResolution: viewState.resolution,\r\n                    wantedTiles: {}\r\n                });\r\n            }\r\n            if (frameState) {\r\n                frameState.extent = ol.extent.getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, frameState.size, extent);\r\n            }\r\n            this.frameState_ = frameState;\r\n            this.renderer_.renderFrame(frameState);\r\n            if (frameState) {\r\n                if (frameState.animate) {\r\n                    this.render();\r\n                }\r\n                Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\r\n                if (previousFrameState) {\r\n                    var moveStart = !this.previousExtent_ ||\r\n                        (!ol.extent.isEmpty(this.previousExtent_) &&\r\n                            !ol.extent.equals(frameState.extent, this.previousExtent_));\r\n                    if (moveStart) {\r\n                        this.dispatchEvent(new ol.MapEvent(ol.MapEventType.MOVESTART, this, previousFrameState));\r\n                        this.previousExtent_ = ol.extent.createOrUpdateEmpty(this.previousExtent_);\r\n                    }\r\n                }\r\n                var idle = this.previousExtent_ &&\r\n                    !frameState.viewHints[ol.ViewHint.ANIMATING] &&\r\n                    !frameState.viewHints[ol.ViewHint.INTERACTING] &&\r\n                    !ol.extent.equals(frameState.extent, this.previousExtent_);\r\n                if (idle) {\r\n                    this.dispatchEvent(new ol.MapEvent(ol.MapEventType.MOVEEND, this, frameState));\r\n                    ol.extent.clone(frameState.extent, this.previousExtent_);\r\n                }\r\n            }\r\n            this.dispatchEvent(new ol.MapEvent(ol.MapEventType.POSTRENDER, this, frameState));\r\n            setTimeout(this.handlePostRender.bind(this), 0);\r\n        };\r\n        // refine drawImage performance\r\n        ol.renderer.canvas.TileLayer.prototype.drawTileImage = function (tile, frameState, layerState, x, y, w, h, gutter, transition) {\r\n            var image = tile.getImage(this.getLayer());\r\n            if (!image) {\r\n                return;\r\n            }\r\n            var uid = ol.getUid(this);\r\n            var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\r\n            if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {\r\n                this.context.clearRect(x, y, w, h);\r\n            }\r\n            var alphaChanged = alpha !== this.context.globalAlpha;\r\n            if (alphaChanged) {\r\n                this.context.save();\r\n                this.context.globalAlpha = alpha;\r\n            }\r\n            // // before\r\n            this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\r\n            // console.log(gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h)\r\n            // // after\r\n            // this.context.save();\r\n            // var ptrn = this.context.createPattern(image, 'repeat');\r\n            // this.context.fillStyle = ptrn;\r\n            // this.context.fillRect(x, y, w, h);\r\n            // this.context.restore();\r\n            if (alphaChanged) {\r\n                this.context.restore();\r\n            }\r\n            if (alpha !== 1) {\r\n                frameState.animate = true;\r\n            }\r\n            else if (transition) {\r\n                tile.endTransition(uid);\r\n            }\r\n        };\r\n        //refine drawing, and remove instructions after using\r\n        ol.render.canvas.Replay.prototype.replay_ = function (context, transform, skippedFeaturesHash, instructions, featureCallback, opt_hitExtent) {\r\n            /** @type {Array.<number>} */\r\n            var pixelCoordinates;\r\n            if (this.instructions != instructions) {\r\n                // hit instructions\r\n                if (this.pixelCoordinates_ && ol.array.equals(transform, this.renderedTransform_)) {\r\n                    pixelCoordinates = this.pixelCoordinates_;\r\n                }\r\n                else {\r\n                    pixelCoordinates = ol.geom.flat.transform.transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, []);\r\n                }\r\n            }\r\n            else {\r\n                // instructions\r\n                if (this.pixelCoordinates_ && ol.array.equals(transform, this.renderedTransform_)) {\r\n                    pixelCoordinates = this.pixelCoordinates_;\r\n                }\r\n                else {\r\n                    if (!this.pixelCoordinates_) {\r\n                        this.pixelCoordinates_ = [];\r\n                    }\r\n                    pixelCoordinates = ol.geom.flat.transform.transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\r\n                    ol.transform.setFromArray(this.renderedTransform_, transform);\r\n                }\r\n            }\r\n            var skipFeatures = !ol.obj.isEmpty(skippedFeaturesHash);\r\n            var i = 0; // instruction index\r\n            var ii = instructions.length; // end of instructions\r\n            var d = 0; // data index\r\n            var dd; // end of per-instruction data\r\n            var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\r\n            var pendingFill = 0;\r\n            var pendingStroke = 0;\r\n            var lastFillInstruction = null;\r\n            var lastStrokeInstruction = null;\r\n            var coordinateCache = this.coordinateCache_;\r\n            var viewRotation = this.viewRotation_;\r\n            var state = /** @type {olx.render.State} */ ({\r\n                context: context,\r\n                pixelRatio: this.pixelRatio,\r\n                resolution: this.resolution,\r\n                rotation: viewRotation\r\n            });\r\n            // When the batch size gets too big, performance decreases. 200 is a good\r\n            // balance between batch size and number of fill/stroke instructions.\r\n            var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\r\n            while (i < ii) {\r\n                var instruction = instructions[i];\r\n                var type = /** @type {ol.render.canvas.Instruction} */ (instruction[0]);\r\n                var /** @type {ol.Feature|ol.render.Feature} */ feature, x, y;\r\n                switch (type) {\r\n                    case ol.render.canvas.Instruction.BEGIN_GEOMETRY:\r\n                        feature = /** @type {ol.Feature|ol.render.Feature} */ (instruction[1]);\r\n                        if ((skipFeatures &&\r\n                            skippedFeaturesHash[ol.getUid(feature).toString()]) ||\r\n                            !feature.getGeometry()) {\r\n                            i = /** @type {number} */ (instruction[2]);\r\n                        }\r\n                        else if (opt_hitExtent !== undefined && !ol.extent.intersects(opt_hitExtent, feature.getGeometry().getExtent())) {\r\n                            i = /** @type {number} */ (instruction[2]) + 1;\r\n                        }\r\n                        else {\r\n                            ++i;\r\n                        }\r\n                        break;\r\n                    case ol.render.canvas.Instruction.BEGIN_PATH:\r\n                        if (pendingFill > batchSize) {\r\n                            this.fill_(context);\r\n                            pendingFill = 0;\r\n                        }\r\n                        if (pendingStroke > batchSize) {\r\n                            context.stroke();\r\n                            pendingStroke = 0;\r\n                        }\r\n                        if (!pendingFill && !pendingStroke) {\r\n                            context.beginPath();\r\n                            prevX = prevY = NaN;\r\n                        }\r\n                        ++i;\r\n                        break;\r\n                    case ol.render.canvas.Instruction.CIRCLE:\r\n                        d = /** @type {number} */ (instruction[1]);\r\n                        var x1 = pixelCoordinates[d];\r\n                        var y1 = pixelCoordinates[d + 1];\r\n                        var x2 = pixelCoordinates[d + 2];\r\n                        var y2 = pixelCoordinates[d + 3];\r\n                        var dx = x2 - x1;\r\n                        var dy = y2 - y1;\r\n                        var r = Math.sqrt(dx * dx + dy * dy);\r\n                        context.moveTo(x1 + r, y1);\r\n                        context.arc(x1, y1, r, 0, 2 * Math.PI, true);\r\n                        ++i;\r\n                        break;\r\n                    case ol.render.canvas.Instruction.CLOSE_PATH:\r\n                        context.closePath();\r\n                        ++i;\r\n                        break;\r\n                    case ol.render.canvas.Instruction.CUSTOM:\r\n                        d = /** @type {number} */ (instruction[1]);\r\n                        dd = instruction[2];\r\n                        var geometry = /** @type {ol.geom.SimpleGeometry} */ (instruction[3]);\r\n                        var renderer = instruction[4];\r\n                        var fn = instruction.length == 6 ? instruction[5] : undefined;\r\n                        state[\"geometry\"] = geometry;\r\n                        state[\"feature\"] = feature;\r\n                        if (!(i in coordinateCache)) {\r\n                            coordinateCache[i] = [];\r\n                        }\r\n                        var coords = coordinateCache[i];\r\n                        if (fn) {\r\n                            fn(pixelCoordinates, d, dd, 2, coords);\r\n                        }\r\n                        else {\r\n                            coords[0] = pixelCoordinates[d];\r\n                            coords[1] = pixelCoordinates[d + 1];\r\n                            coords.length = 2;\r\n                        }\r\n                        renderer(coords, state);\r\n                        ++i;\r\n                        break;\r\n                    case ol.render.canvas.Instruction.DRAW_IMAGE:\r\n                        d = /** @type {number} */ (instruction[1]);\r\n                        dd = /** @type {number} */ (instruction[2]);\r\n                        image = /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */\r\n                            (instruction[3]);\r\n                        // Remaining arguments in DRAW_IMAGE are in alphabetical order\r\n                        anchorX = /** @type {number} */ (instruction[4]);\r\n                        anchorY = /** @type {number} */ (instruction[5]);\r\n                        declutterGroup = featureCallback ? null : /** @type {ol.DeclutterGroup} */ (instruction[6]);\r\n                        var height = /** @type {number} */ (instruction[7]);\r\n                        var opacity = /** @type {number} */ (instruction[8]);\r\n                        var originX = /** @type {number} */ (instruction[9]);\r\n                        var originY = /** @type {number} */ (instruction[10]);\r\n                        var rotateWithView = /** @type {boolean} */ (instruction[11]);\r\n                        var rotation = /** @type {number} */ (instruction[12]);\r\n                        var scale = /** @type {number} */ (instruction[13]);\r\n                        var snapToPixel = /** @type {boolean} */ (instruction[14]);\r\n                        var width = /** @type {number} */ (instruction[15]);\r\n                        var padding, backgroundFill, backgroundStroke;\r\n                        if (instruction.length > 16) {\r\n                            padding = /** @type {Array.<number>} */ (instruction[16]);\r\n                            backgroundFill = /** @type {boolean} */ (instruction[17]);\r\n                            backgroundStroke = /** @type {boolean} */ (instruction[18]);\r\n                        }\r\n                        else {\r\n                            padding = ol.render.canvas.defaultPadding;\r\n                            backgroundFill = backgroundStroke = false;\r\n                        }\r\n                        if (rotateWithView) {\r\n                            rotation += viewRotation;\r\n                        }\r\n                        for (; d < dd; d += 2) {\r\n                            this.replayImage_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ? /** @type {Array.<*>} */ (lastFillInstruction) : null, backgroundStroke ? /** @type {Array.<*>} */ (lastStrokeInstruction) : null);\r\n                        }\r\n                        this.renderDeclutter_(declutterGroup, feature);\r\n                        ++i;\r\n                        break;\r\n                    case ol.render.canvas.Instruction.DRAW_CHARS:\r\n                        var begin = /** @type {number} */ (instruction[1]);\r\n                        var end = /** @type {number} */ (instruction[2]);\r\n                        var baseline = /** @type {number} */ (instruction[3]);\r\n                        declutterGroup = featureCallback ? null : /** @type {ol.DeclutterGroup} */ (instruction[4]);\r\n                        var overflow = /** @type {number} */ (instruction[5]);\r\n                        var fillKey = /** @type {string} */ (instruction[6]);\r\n                        var maxAngle = /** @type {number} */ (instruction[7]);\r\n                        var measure = /** @type {function(string):number} */ (instruction[8]);\r\n                        var offsetY = /** @type {number} */ (instruction[9]);\r\n                        var strokeKey = /** @type {string} */ (instruction[10]);\r\n                        var strokeWidth = /** @type {number} */ (instruction[11]);\r\n                        var text = /** @type {string} */ (instruction[12]);\r\n                        var textKey = /** @type {string} */ (instruction[13]);\r\n                        var textScale = /** @type {number} */ (instruction[14]);\r\n                        var pathLength = ol.geom.flat.length.lineString(pixelCoordinates, begin, end, 2);\r\n                        var textLength = measure(text);\r\n                        if (overflow || textLength <= pathLength) {\r\n                            var textAlign = /** @type {ol.render.canvas.TextReplay} */ (this).textStates[textKey].textAlign;\r\n                            var startM = (pathLength - textLength) * ol.render.replay.TEXT_ALIGN[textAlign];\r\n                            var parts = ol.geom.flat.textpath.lineString(pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\r\n                            if (parts) {\r\n                                var c, cc, chars, label, part;\r\n                                if (strokeKey) {\r\n                                    for (c = 0, cc = parts.length; c < cc; ++c) {\r\n                                        part = parts[c]; // x, y, anchorX, rotation, chunk\r\n                                        chars = /** @type {string} */ (part[4]);\r\n                                        label = /** @type {ol.render.canvas.TextReplay} */ (this).getImage(chars, textKey, '', strokeKey);\r\n                                        anchorX = /** @type {number} */ (part[2]) + strokeWidth;\r\n                                        anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;\r\n                                        this.replayImage_(context, \r\n                                        /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, \r\n                                        /** @type {number} */ (part[3]), textScale, false, label.width, ol.render.canvas.defaultPadding, null, null);\r\n                                    }\r\n                                }\r\n                                if (fillKey) {\r\n                                    for (c = 0, cc = parts.length; c < cc; ++c) {\r\n                                        part = parts[c]; // x, y, anchorX, rotation, chunk\r\n                                        chars = /** @type {string} */ (part[4]);\r\n                                        label = /** @type {ol.render.canvas.TextReplay} */ (this).getImage(chars, textKey, fillKey, '');\r\n                                        anchorX = /** @type {number} */ (part[2]);\r\n                                        anchorY = baseline * label.height - offsetY;\r\n                                        this.replayImage_(context, \r\n                                        /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, \r\n                                        /** @type {number} */ (part[3]), textScale, false, label.width, ol.render.canvas.defaultPadding, null, null);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        this.renderDeclutter_(declutterGroup, feature);\r\n                        ++i;\r\n                        break;\r\n                    case ol.render.canvas.Instruction.END_GEOMETRY:\r\n                        if (featureCallback !== undefined) {\r\n                            feature = /** @type {ol.Feature|ol.render.Feature} */ (instruction[1]);\r\n                            var result = featureCallback(feature);\r\n                            if (result) {\r\n                                return result;\r\n                            }\r\n                        }\r\n                        ++i;\r\n                        break;\r\n                    case ol.render.canvas.Instruction.FILL:\r\n                        if (batchSize) {\r\n                            pendingFill++;\r\n                        }\r\n                        else {\r\n                            this.fill_(context);\r\n                        }\r\n                        ++i;\r\n                        break;\r\n                    case ol.render.canvas.Instruction.MOVE_TO_LINE_TO:\r\n                        d = /** @type {number} */ (instruction[1]);\r\n                        dd = /** @type {number} */ (instruction[2]);\r\n                        x = pixelCoordinates[d];\r\n                        y = pixelCoordinates[d + 1];\r\n                        roundX = (x + 0.5) | 0;\r\n                        roundY = (y + 0.5) | 0;\r\n                        if (roundX !== prevX || roundY !== prevY) {\r\n                            context.moveTo(x, y);\r\n                            prevX = roundX;\r\n                            prevY = roundY;\r\n                        }\r\n                        for (d += 2; d < dd; d += 2) {\r\n                            x = pixelCoordinates[d];\r\n                            y = pixelCoordinates[d + 1];\r\n                            roundX = (x + 0.5) | 0;\r\n                            roundY = (y + 0.5) | 0;\r\n                            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\r\n                                context.lineTo(x, y);\r\n                                prevX = roundX;\r\n                                prevY = roundY;\r\n                            }\r\n                        }\r\n                        ++i;\r\n                        break;\r\n                    case ol.render.canvas.Instruction.SET_FILL_STYLE:\r\n                        lastFillInstruction = instruction;\r\n                        this.fillOrigin_ = instruction[2];\r\n                        if (pendingFill) {\r\n                            this.fill_(context);\r\n                            pendingFill = 0;\r\n                            if (pendingStroke) {\r\n                                context.stroke();\r\n                                pendingStroke = 0;\r\n                            }\r\n                        }\r\n                        context.fillStyle = /** @type {ol.ColorLike} */ (instruction[1]);\r\n                        ++i;\r\n                        break;\r\n                    case ol.render.canvas.Instruction.SET_STROKE_STYLE:\r\n                        lastStrokeInstruction = instruction;\r\n                        if (pendingStroke) {\r\n                            context.stroke();\r\n                            pendingStroke = 0;\r\n                        }\r\n                        this.setStrokeStyle_(context, /** @type {Array.<*>} */ (instruction));\r\n                        ++i;\r\n                        break;\r\n                    case ol.render.canvas.Instruction.STROKE:\r\n                        if (batchSize) {\r\n                            pendingStroke++;\r\n                        }\r\n                        else {\r\n                            context.stroke();\r\n                        }\r\n                        ++i;\r\n                        break;\r\n                    default:\r\n                        ++i; // consume the instruction anyway, to avoid an infinite loop\r\n                        break;\r\n                }\r\n            }\r\n            if (pendingFill) {\r\n                this.fill_(context);\r\n            }\r\n            if (pendingStroke) {\r\n                context.stroke();\r\n            }\r\n            //release instructions\r\n            // if (this.resolution < 2445.98490512564 && this.instructions === instructions && !(this instanceof (<any>ol).render.canvas.ImageReplay)) {\r\n            //     this.instructions.length = 0;\r\n            //     this.pixelCoordinates_ = null;\r\n            // }\r\n            return undefined;\r\n        };\r\n        ol.renderer.canvas.VectorTileLayer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {\r\n            var resolution = frameState.viewState.resolution;\r\n            var rotation = frameState.viewState.rotation;\r\n            hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\r\n            var layer = this.getLayer();\r\n            /** @type {Object.<string, boolean>} */\r\n            var features = {};\r\n            /** @type {Array.<ol.VectorImageTile>} */\r\n            var renderedTiles = this.renderedTiles;\r\n            var source = /** @type {ol.source.VectorTile} */ (layer.getSource());\r\n            var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\r\n            var bufferedExtent, found;\r\n            var i, ii, replayGroup;\r\n            var tile, tileCoord, tileExtent;\r\n            for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\r\n                tile = renderedTiles[i];\r\n                tileCoord = tile.wrappedTileCoord;\r\n                tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\r\n                bufferedExtent = ol.extent.buffer(tileExtent, hitTolerance * resolution, bufferedExtent);\r\n                if (!ol.extent.containsCoordinate(bufferedExtent, coordinate)) {\r\n                    continue;\r\n                }\r\n                for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\r\n                    var sourceTile = tile.getTile(tile.tileKeys[t]);\r\n                    if (sourceTile.getState() == ol.TileState.ERROR) {\r\n                        continue;\r\n                    }\r\n                    replayGroup = sourceTile.getReplayGroup(layer, tileCoord.toString());\r\n                    found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {}, \r\n                    /**\r\n                     * @param {ol.Feature|ol.render.Feature} feature Feature.\r\n                     * @return {?} Callback result.\r\n                     */\r\n                    function (feature) {\r\n                        var key = ol.getUid(feature).toString();\r\n                        if (!(key in features)) {\r\n                            features[key] = true;\r\n                            return callback.call(thisArg, feature, layer);\r\n                        }\r\n                    }, null);\r\n                }\r\n            }\r\n            return found;\r\n        };\r\n    };\r\n    return VectorTileLayer;\r\n}(ol.layer.VectorTile));\r\n\r\n\n\n//# sourceURL=webpack:///./src/layer/vectorTileLayer.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _layer_vectorTileLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layer/vectorTileLayer */ \"./src/layer/vectorTileLayer.ts\");\n/* harmony import */ var _worker_vectorTileLayerThreadMode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker/vectorTileLayerThreadMode */ \"./src/worker/vectorTileLayerThreadMode.ts\");\n\r\n\r\nol.mapsuite = {};\r\nol.mapsuite[\"VectorTileLayer\"] = _layer_vectorTileLayer__WEBPACK_IMPORTED_MODULE_0__[\"VectorTileLayer\"];\r\nol.mapsuite[\"VectorTileLayerThreadMode\"] = _worker_vectorTileLayerThreadMode__WEBPACK_IMPORTED_MODULE_1__[\"VectorTileLayerThreadMode\"];\r\nwindow[\"ol\"] = ol;\r\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/render/geoVectorTilelayerRender.ts":
/*!************************************************!*\
  !*** ./src/render/geoVectorTilelayerRender.ts ***!
  \************************************************/
/*! exports provided: GeoVectorTileLayerRender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoVectorTileLayerRender\", function() { return GeoVectorTileLayerRender; });\n/* harmony import */ var _replayGroupCustom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./replayGroupCustom */ \"./src/render/replayGroupCustom.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar GeoVectorTileLayerRender = /** @class */ (function (_super) {\r\n    __extends(GeoVectorTileLayerRender, _super);\r\n    function GeoVectorTileLayerRender(layer) {\r\n        var _this = _super.call(this, layer) || this;\r\n        _this.VECTOR_REPLAYS_CUSTOM = {\r\n            \"image\": [ol.render.ReplayType.DEFAULT],\r\n            \"hybrid\": [ol.render.ReplayType.IMAGE, ol.render.ReplayType.TEXT, ol.render.ReplayType.DEFAULT],\r\n            \"vector\": ol.render.replay.ORDER\r\n        };\r\n        _this.VECTOR_REPLAYS = _this.VECTOR_REPLAYS_CUSTOM;\r\n        _this.prepareFrame = _this.prepareFrameCustom;\r\n        _this.renderTileImage_ = _this.renderTileImageCustom;\r\n        return _this;\r\n    }\r\n    GeoVectorTileLayerRender.prototype.tileLayerPrepareFrameCustom = function (frameState, layerState) {\r\n        var pixelRatio = frameState.pixelRatio;\r\n        var size = frameState.size;\r\n        var viewState = frameState.viewState;\r\n        var projection = viewState.projection;\r\n        var viewResolution = viewState.resolution;\r\n        var viewCenter = viewState.center;\r\n        var tileLayer = this.getLayer();\r\n        var tileSource = /** @type {ol.source.Tile} */ (tileLayer.getSource());\r\n        var sourceRevision = tileSource.getRevision();\r\n        var tileGrid = tileSource.getTileGridForProjection(projection);\r\n        var z = tileGrid.getZForResolution(viewResolution, this.zDirection);\r\n        var tileResolution = tileGrid.getResolution(z);\r\n        var oversampling = Math.round(viewResolution / tileResolution) || 1;\r\n        var extent = frameState.extent;\r\n        if (layerState.extent !== undefined) {\r\n            extent = ol.extent.getIntersection(extent, layerState.extent);\r\n        }\r\n        if (ol.extent.isEmpty(extent)) {\r\n            // Return false to prevent the rendering of the layer.\r\n            return false;\r\n        }\r\n        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\r\n        // Adjust tile cache size according to tile Range, TODO: add a property for that\r\n        var xOffset = (tileRange.maxX - tileRange.minX);\r\n        var yOffset = (tileRange.maxY - tileRange.minY);\r\n        xOffset = xOffset <= 0 ? 1 : xOffset * 2 + 3;\r\n        yOffset = yOffset <= 0 ? 1 : yOffset * 2 + 3;\r\n        var cacheSize = xOffset * yOffset;\r\n        tileSource.tileCache.highWaterMark = cacheSize <= 15 ? 15 : cacheSize;\r\n        //// Adjust vectorTileData cache size according to the tile Range in data max zoom. it will pass \r\n        var dataTileRand = tileGrid.getTileRangeForExtentAndZ(extent, tileSource.maxDataZoom);\r\n        var offsetX = dataTileRand.maxX - dataTileRand.minX;\r\n        var offsetY = dataTileRand.maxY - dataTileRand.minY;\r\n        offsetX = offsetX <= 0 ? 1 : offsetX + 3;\r\n        offsetY = offsetY <= 0 ? 1 : offsetY + 3;\r\n        var vectorTileDataCahceSize = offsetX * offsetY;\r\n        tileSource[\"vectorTileDataCahceSize\"] = vectorTileDataCahceSize;\r\n        tileSource.getGeoFormat()[\"vectorTileDataCahceSize\"] = vectorTileDataCahceSize;\r\n        var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\r\n        var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\r\n        /**\r\n         * @type {Object.<number, Object.<string, ol.Tile>>}\r\n         */\r\n        var tilesToDrawByZ = {};\r\n        tilesToDrawByZ[z] = {};\r\n        var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\r\n        var tmpExtent = this.tmpExtent;\r\n        var tmpTileRange = this.tmpTileRange_;\r\n        var newTiles = false;\r\n        var tile, x, y;\r\n        for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n            for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n                tile = tileSource.getTile(z, x, y, pixelRatio, projection);\r\n                // FIXME Eric\r\n                tile.tileRange = tileRange;\r\n                if (tile.getState() === ol.TileState.ERROR) {\r\n                    if (!tileLayer.getUseInterimTilesOnError()) {\r\n                        // When useInterimTilesOnError is false, we consider the error tile as loaded.\r\n                        tile.setState(ol.TileState.LOADED);\r\n                    }\r\n                    else if (tileLayer.getPreload() > 0) {\r\n                        // Preloaded tiles for lower resolutions might have finished loading.\r\n                        newTiles = true;\r\n                    }\r\n                }\r\n                if (!this.isDrawableTile_(tile)) {\r\n                    tile = tile.getInterimTile();\r\n                }\r\n                if (this.isDrawableTile_(tile)) {\r\n                    var uid = ol.getUid(this);\r\n                    if (tile.getState() === ol.TileState.LOADED) {\r\n                        tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\r\n                        var inTransition = tile.inTransition(uid);\r\n                        if (!newTiles && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\r\n                            newTiles = true;\r\n                        }\r\n                    }\r\n                    if (tile.getAlpha(uid, frameState.time) === 1) {\r\n                        // don't look for alt tiles if alpha is 1\r\n                        continue;\r\n                    }\r\n                }\r\n                var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\r\n                var covered = false;\r\n                if (childTileRange) {\r\n                    covered = findLoadedTiles(z + 1, childTileRange);\r\n                }\r\n                if (!covered) {\r\n                    tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\r\n                }\r\n            }\r\n        }\r\n        var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\r\n        var hints = frameState.viewHints;\r\n        var animatingOrInteracting = hints[ol.ViewHint.ANIMATING] || hints[ol.ViewHint.INTERACTING];\r\n        if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (newTiles ||\r\n            !(this.renderedExtent_ && ol.extent.containsExtent(this.renderedExtent_, extent)) ||\r\n            this.renderedRevision !== sourceRevision ||\r\n            oversampling !== this.oversampling_ ||\r\n            !animatingOrInteracting && renderedResolution !== this.renderedResolution)) {\r\n            var context = this.context;\r\n            if (context) {\r\n                var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\r\n                var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\r\n                var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\r\n                var canvas = context.canvas;\r\n                if (canvas.width !== width || canvas.height !== height) {\r\n                    this.oversampling_ = oversampling;\r\n                    canvas.width = width;\r\n                    canvas.height = height;\r\n                }\r\n                else {\r\n                    if (this.renderedExtent_ && !ol.extent.equals(imageExtent, this.renderedExtent_)) {\r\n                        context.clearRect(0, 0, width, height);\r\n                    }\r\n                    oversampling = this.oversampling_;\r\n                }\r\n            }\r\n            this.renderedTiles.length = 0;\r\n            /** @type {Array.<number>} */\r\n            var zs = Object.keys(tilesToDrawByZ).map(Number);\r\n            zs.sort(function (a, b) {\r\n                if (a === z) {\r\n                    return 1;\r\n                }\r\n                else if (b === z) {\r\n                    return -1;\r\n                }\r\n                else {\r\n                    return a > b ? 1 : a < b ? -1 : 0;\r\n                }\r\n            });\r\n            var currentResolution = void 0, currentScale = void 0, currentTilePixelSize = void 0, currentZ = void 0, i = void 0, ii = void 0;\r\n            var tileExtent = void 0, tileGutter = void 0, tilesToDraw = void 0, w = void 0, h = void 0;\r\n            for (i = 0, ii = zs.length; i < ii; ++i) {\r\n                currentZ = zs[i];\r\n                currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\r\n                currentResolution = tileGrid.getResolution(currentZ);\r\n                currentScale = currentResolution / tileResolution;\r\n                tileGutter = tilePixelRatio * tileSource.getGutter(projection);\r\n                tilesToDraw = tilesToDrawByZ[currentZ];\r\n                for (var tileCoordKey in tilesToDraw) {\r\n                    tile = tilesToDraw[tileCoordKey];\r\n                    tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\r\n                    x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\r\n                    y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\r\n                    w = currentTilePixelSize[0] * currentScale / oversampling;\r\n                    h = currentTilePixelSize[1] * currentScale / oversampling;\r\n                    this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\r\n                    this.renderedTiles.push(tile);\r\n                }\r\n            }\r\n            this.renderedRevision = sourceRevision;\r\n            this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\r\n            this.renderedExtent_ = imageExtent;\r\n        }\r\n        var scale = this.renderedResolution / viewResolution;\r\n        var transform = ol.transform.compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\r\n        ol.transform.compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);\r\n        this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\r\n        this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\r\n        this.scheduleExpireCache(frameState, tileSource);\r\n        this.updateLogos(frameState, tileSource);\r\n        return this.renderedTiles.length > 0;\r\n    };\r\n    // public manageTilePyramidCustom = function (\r\n    //     frameState, tileSource, tileGrid, pixelRatio, projection, extent,\r\n    //     currentZ, preload, opt_tileCallback, opt_this) {\r\n    //     var tileSourceKey = (<any>ol).getUid(tileSource).toString();\r\n    //     if (!(tileSourceKey in frameState.wantedTiles)) {\r\n    //         frameState.wantedTiles[tileSourceKey] = {};\r\n    //     }\r\n    //     var wantedTiles = frameState.wantedTiles[tileSourceKey];\r\n    //     var tileQueue = frameState.tileQueue;\r\n    //     var minZoom = tileGrid.getMinZoom();\r\n    //     var tile, tileRange, tileResolution, x, y, z;\r\n    //     for (z = minZoom; z <= currentZ; ++z) {\r\n    //         tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\r\n    //         tileResolution = tileGrid.getResolution(z);\r\n    //         for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n    //             for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n    //                 if (currentZ - z <= preload) {\r\n    //                     tile = tileSource.getTile(z, x, y, pixelRatio, projection);\r\n    //                     // FIXME Eric\r\n    //                     if (tile.getState() == (<any>ol).TileState.IDLE || tile.getState() == (<any>ol).TileState.CANCEL) {\r\n    //                         wantedTiles[tile.getKey()] = true;\r\n    //                         if (!tileQueue.isKeyQueued(tile.getKey())) {\r\n    //                             tileQueue.enqueue([tile, tileSourceKey,\r\n    //                                 tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\r\n    //                         }\r\n    //                     }\r\n    //                     if (opt_tileCallback !== undefined) {\r\n    //                         opt_tileCallback.call(opt_this, tile);\r\n    //                     }\r\n    //                 } else {\r\n    //                     tileSource.useTile(z, x, y, projection);\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //     }\r\n    // };\r\n    GeoVectorTileLayerRender.prototype.prepareFrameCustom = function (frameState, layerState) {\r\n        var layer = this.getLayer();\r\n        var layerRevision = layer.getRevision();\r\n        if (this.renderedLayerRevision_ !== layerRevision) {\r\n            this.renderedTiles.length = 0;\r\n            var renderMode = layer.getRenderMode();\r\n            if (!this.context && renderMode !== ol.layer.VectorTileRenderType.VECTOR) {\r\n                this.context = ol.dom.createCanvasContext2D();\r\n            }\r\n            if (this.context && renderMode === ol.layer.VectorTileRenderType.VECTOR) {\r\n                this.context = null;\r\n            }\r\n        }\r\n        this.renderedLayerRevision_ = layerRevision;\r\n        return this.tileLayerPrepareFrameCustom.apply(this, arguments);\r\n    };\r\n    GeoVectorTileLayerRender.prototype.postCompose = function (context, frameState, layerState) {\r\n        var layer = this.getLayer();\r\n        var declutterReplays = layer.getDeclutter() ? {} : null;\r\n        var source = /** @type {ol.source.VectorTile} */ (layer.getSource());\r\n        var renderMode = layer.getRenderMode();\r\n        var replayTypes = this.VECTOR_REPLAYS_CUSTOM[renderMode];\r\n        var pixelRatio = frameState.pixelRatio;\r\n        var rotation = frameState.viewState.rotation;\r\n        var size = frameState.size;\r\n        var offsetX, offsetY;\r\n        if (rotation) {\r\n            offsetX = Math.round(pixelRatio * size[0] / 2);\r\n            offsetY = Math.round(pixelRatio * size[1] / 2);\r\n            ol.render.canvas.rotateAtOffset(context, -rotation, offsetX, offsetY);\r\n        }\r\n        if (declutterReplays) {\r\n            this.declutterTree_.clear();\r\n        }\r\n        var tiles = this.renderedTiles;\r\n        var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\r\n        var clips = [];\r\n        var zs = [];\r\n        for (var i = tiles.length - 1; i >= 0; --i) {\r\n            var tile = /** @type {ol.VectorImageTile} */ (tiles[i]);\r\n            if (tile.getState() === ol.TileState.ABORT) {\r\n                continue;\r\n            }\r\n            var tileCoord = tile.tileCoord;\r\n            var worldOffset = tileGrid.getTileCoordExtent(tileCoord)[0] -\r\n                tileGrid.getTileCoordExtent(tile.wrappedTileCoord)[0];\r\n            var transform = undefined;\r\n            for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\r\n                var sourceTile = tile.getTile(tile.tileKeys[t]);\r\n                if (sourceTile.getState() === ol.TileState.ERROR) {\r\n                    continue;\r\n                }\r\n                //// reuse replayGroup of source Tile to reduce the memory.\r\n                // let replayGroup = sourceTile.getReplayGroup(layer, tileCoord.toString());\r\n                var replayGroup = sourceTile.getReplayGroup(layer, sourceTile.tileCoord.toString());\r\n                if (renderMode !== ol.layer.VectorTileRenderType.VECTOR && !replayGroup.hasReplays(replayTypes)) {\r\n                    continue;\r\n                }\r\n                if (!transform) {\r\n                    transform = this.getTransform(frameState, worldOffset);\r\n                }\r\n                var currentZ = sourceTile.tileCoord[0];\r\n                var currentClip = replayGroup.getClipCoords(transform);\r\n                context.save();\r\n                context.globalAlpha = layerState.opacity;\r\n                // Create a clip mask for regions in this low resolution tile that are\r\n                // already filled by a higher resolution tile\r\n                for (var j = 0, jj = clips.length; j < jj; ++j) {\r\n                    var clip = clips[j];\r\n                    if (currentZ < zs[j]) {\r\n                        context.beginPath();\r\n                        // counter-clockwise (outer ring) for current tile\r\n                        context.moveTo(currentClip[0], currentClip[1]);\r\n                        context.lineTo(currentClip[2], currentClip[3]);\r\n                        context.lineTo(currentClip[4], currentClip[5]);\r\n                        context.lineTo(currentClip[6], currentClip[7]);\r\n                        // clockwise (inner ring) for higher resolution tile\r\n                        context.moveTo(clip[6], clip[7]);\r\n                        context.lineTo(clip[4], clip[5]);\r\n                        context.lineTo(clip[2], clip[3]);\r\n                        context.lineTo(clip[0], clip[1]);\r\n                        context.clip();\r\n                    }\r\n                }\r\n                replayGroup.replay(context, transform, rotation, {}, replayTypes, declutterReplays);\r\n                context.restore();\r\n                clips.push(currentClip);\r\n                zs.push(currentZ);\r\n            }\r\n        }\r\n        if (declutterReplays) {\r\n            var hints = frameState.viewHints;\r\n            var animatingOrInteracting = hints[ol.ViewHint.ANIMATING] || hints[ol.ViewHint.INTERACTING];\r\n            delete context[\"quickZoom\"];\r\n            if (animatingOrInteracting) {\r\n                context[\"quickZoom\"] = frameState[\"quickZoom\"];\r\n            }\r\n            context[\"currentResolution\"] = frameState[\"currentResolution\"];\r\n            ol.render.canvas.ReplayGroup.replayDeclutter(declutterReplays, context, rotation);\r\n        }\r\n        if (rotation) {\r\n            ol.render.canvas.rotateAtOffset(context, rotation, \r\n            /** @type {number} */ (offsetX), /** @type {number} */ (offsetY));\r\n        }\r\n        ol.renderer.canvas.TileLayer.prototype.postCompose.apply(this, arguments);\r\n    };\r\n    GeoVectorTileLayerRender.prototype.createReplayGroup_ = function (tile, frameState) {\r\n        var layer = this.getLayer();\r\n        var pixelRatio = frameState.pixelRatio;\r\n        var projection = frameState.viewState.projection;\r\n        var revision = layer.getRevision();\r\n        var renderOrder = /** @type {ol.RenderOrderFunction} */ (layer.getRenderOrder()) || null;\r\n        var replayState = tile.getReplayState(layer);\r\n        if (!replayState.dirty && replayState.renderedRevision === revision &&\r\n            replayState.renderedRenderOrder === renderOrder) {\r\n            return;\r\n        }\r\n        var source = /** @type {ol.source.VectorTile} */ (layer.getSource());\r\n        var sourceTileGrid = source.getTileGrid();\r\n        var tileGrid = source.getTileGridForProjection(projection);\r\n        var resolution = tileGrid.getResolution(tile.tileCoord[0]);\r\n        var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\r\n        var zIndexKeys = {};\r\n        var _loop_1 = function (t, tt) {\r\n            var sourceTile = tile.getTile(tile.tileKeys[t]);\r\n            if (sourceTile.getState() === ol.TileState.ERROR) {\r\n                return \"continue\";\r\n            }\r\n            var sourceTileCoord = sourceTile.requestTileCoord;\r\n            var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\r\n            var sharedExtent = ol.extent.getIntersection(tileExtent, sourceTileExtent);\r\n            var bufferedExtent = ol.extent.equals(sourceTileExtent, sharedExtent) ? null :\r\n                ol.extent.buffer(sharedExtent, layer.getRenderBuffer() * resolution);\r\n            var tileProjection = sourceTile.getProjection();\r\n            var reproject = true;\r\n            replayState.dirty = false;\r\n            //// reuse replayGroup of source Tile to reduce the memory.\r\n            var distReplayGroup = sourceTile.getReplayGroup(layer, tile.wrappedTileCoord.toString());\r\n            if (distReplayGroup) {\r\n                // Check replayGroup has  replays\r\n                var replaysZindexCount = 0;\r\n                if (distReplayGroup.replaysByZIndex_) {\r\n                    for (var zindex in distReplayGroup.replaysByZIndex_) {\r\n                        replaysZindexCount++;\r\n                    }\r\n                }\r\n                if (source.isMultithread && replaysZindexCount === 0) {\r\n                    // the replays did not created, it will create after web worker call back\r\n                    if (sourceTile)\r\n                        if (sourceTile[\"reuseVectorImageTile\"] === undefined) {\r\n                            sourceTile[\"reuseVectorImageTile\"] = [];\r\n                        }\r\n                    sourceTile[\"reuseVectorImageTile\"].push(tile);\r\n                }\r\n                else {\r\n                    replayState.renderedRevision = revision;\r\n                    replayState.renderedRenderOrder = renderOrder;\r\n                    replayState.renderedTileLoaded = true;\r\n                }\r\n            }\r\n            else {\r\n                var replayGroup_1 = new _replayGroupCustom__WEBPACK_IMPORTED_MODULE_0__[\"ReplayGroupCustom\"](0, sharedExtent, resolution, pixelRatio, source.getOverlaps(), this_1.declutterTree_, layer.getRenderBuffer());\r\n                var squaredTolerance_1 = ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio);\r\n                var strategyTree_1 = ol.ext.rbush(9);\r\n                /**\r\n                 * @param {ol.Feature|ol.render.Feature} feature Feature.\r\n                 * @this {ol.renderer.canvas.VectorTileLayer}\r\n                 */\r\n                var renderFeature_1 = function (feature, geoStyles, options) {\r\n                    var styles;\r\n                    if (geoStyles) {\r\n                        if (geoStyles && geoStyles.length > 0) {\r\n                            for (var i = 0, ii = geoStyles.length; i < ii; i++) {\r\n                                if (geoStyles[i]) {\r\n                                    var ol4Styles = geoStyles[i].getStyles(feature, resolution, options);\r\n                                    if (styles === undefined) {\r\n                                        styles = [];\r\n                                    }\r\n                                    Array.prototype.push.apply(styles, ol4Styles);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        var styleFunction = feature.getStyleFunction();\r\n                        if (styleFunction) {\r\n                            styles = styleFunction.call(/** @type {ol.Feature} */ (feature), resolution);\r\n                        }\r\n                        else {\r\n                            styleFunction = layer.getStyleFunction();\r\n                            if (styleFunction) {\r\n                                styles = styleFunction(feature, resolution);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (styles) {\r\n                        var dirty = this.renderFeature(feature, squaredTolerance_1, styles, replayGroup_1);\r\n                        this.dirty_ = this.dirty_ || dirty;\r\n                        replayState.dirty = replayState.dirty || dirty;\r\n                    }\r\n                };\r\n                var instructs = void 0;\r\n                var features = void 0;\r\n                if (sourceTile.featuresAndInstructs) {\r\n                    instructs = sourceTile.featuresAndInstructs[\"instructs\"];\r\n                    features = sourceTile.featuresAndInstructs[\"features\"];\r\n                }\r\n                if (source.isMultithread) {\r\n                    var render = this_1;\r\n                    if (tileProjection.getUnits() === ol.proj.Units.TILE_PIXELS) {\r\n                        tileProjection.setWorldExtent(sourceTileExtent);\r\n                        tileProjection.setExtent(sourceTile.getExtent());\r\n                    }\r\n                    var tileProjectionInfo = {};\r\n                    for (var name_1 in tileProjection) {\r\n                        if (typeof tileProjection[name_1] !== \"function\") {\r\n                            tileProjectionInfo[name_1] = tileProjection[name_1];\r\n                        }\r\n                    }\r\n                    var projectInfo = {};\r\n                    for (var name_2 in projection) {\r\n                        if (typeof projection[name_2] !== \"function\") {\r\n                            projectInfo[name_2] = projection[name_2];\r\n                        }\r\n                    }\r\n                    var geoStyles_1 = source.getGeoFormat().styleJsonCache.geoStyles;\r\n                    if (features && instructs) {\r\n                        for (var i = 0; i < instructs.length; i++) {\r\n                            var geoStyleId = instructs[i][1];\r\n                            var geoStyle = geoStyles_1[geoStyleId];\r\n                            var featureInfo = features[instructs[i][0]];\r\n                            var feature = new ol.render.Feature(featureInfo.type_, featureInfo.flatCoordinates_, featureInfo.ends_, featureInfo.properties_);\r\n                            if (featureInfo[\"projected\"] === undefined) {\r\n                                if (tileProjection.getUnits() === ol.proj.Units.TILE_PIXELS) {\r\n                                    // projected tile extent\r\n                                    tileProjection.setWorldExtent(sourceTileExtent);\r\n                                    // tile extent in tile pixel space\r\n                                    tileProjection.setExtent(sourceTile.getExtent());\r\n                                }\r\n                                feature.getGeometry().transform(tileProjection, projection);\r\n                                feature.extent_ = null;\r\n                                featureInfo[\"projected\"] = \"\";\r\n                            }\r\n                            feature[\"tempTreeZindex\"] = instructs[i][2];\r\n                            feature[\"styleId\"] = geoStyleId;\r\n                            renderFeature_1.call(this_1, feature, [geoStyle], { strategyTree: strategyTree_1, frameState: frameState });\r\n                        }\r\n                    }\r\n                    var messageData = [\r\n                        [0, tileExtent, resolution, pixelRatio, source.getOverlaps(), this_1.declutterTree_, layer.getRenderBuffer(), source.getGeoFormat().minimalist],\r\n                        sourceTile.requestTileCoord,\r\n                        sourceTile.tileCoord,\r\n                        tileProjectionInfo,\r\n                        projectInfo,\r\n                        squaredTolerance_1,\r\n                        window.devicePixelRatio,\r\n                        ol.getUid(source.getGeoFormat()),\r\n                        frameState[\"coordinateToPixelTransform\"],\r\n                        source.getGeoFormat().maxDataZoom,\r\n                        source[\"vectorTileDataCahceSize\"]\r\n                    ];\r\n                    rendera = this_1;\r\n                    var callabck = function (messageData) {\r\n                        var replaysByZIndex_ = messageData[\"replays\"];\r\n                        var features = messageData[\"features\"];\r\n                        var instructs = messageData[\"instructs\"];\r\n                        if (features && instructs) {\r\n                            for (var i_1 = 0; i_1 < instructs.length; i_1++) {\r\n                                var geoStyleId = instructs[i_1][1];\r\n                                var geoStyle = geoStyles_1[geoStyleId];\r\n                                var featureInfo = features[instructs[i_1][0]];\r\n                                var feature = new ol.render.Feature(featureInfo.type_, featureInfo.flatCoordinates_, featureInfo.ends_, featureInfo.properties_);\r\n                                feature[\"tempTreeZindex\"] = instructs[i_1][2];\r\n                                feature[\"styleId\"] = geoStyleId;\r\n                                renderFeature_1.call(rendera, feature, [geoStyle], { strategyTree: strategyTree_1, frameState: frameState });\r\n                            }\r\n                        }\r\n                        for (var zindex_1 in replaysByZIndex_) {\r\n                            for (var replayType in replaysByZIndex_[zindex_1]) {\r\n                                var replay = replayGroup_1.getReplayCustom(zindex_1, replayType);\r\n                                var workReplay = replaysByZIndex_[zindex_1][replayType];\r\n                                if (!source.getGeoFormat().minimalist && workReplay.instructions) {\r\n                                    for (var i_2 = 0; i_2 < workReplay.instructions.length; i_2++) {\r\n                                        var instruction = workReplay.instructions[i_2];\r\n                                        if (instruction[0] === ol.render.canvas.Instruction.SET_FILL_STYLE && instruction[1].indexOf(\"hatch\") === 0) {\r\n                                            var hatchInstruction = instruction[1];\r\n                                            var geoStyleId = hatchInstruction.split(\"|\")[1];\r\n                                            var geoStyle = geoStyles_1[geoStyleId];\r\n                                            if (geoStyle) {\r\n                                                geoStyle.initialize();\r\n                                                instruction[1] = geoStyle.geoBrush;\r\n                                            }\r\n                                        }\r\n                                        if (instruction[0] === ol.render.canvas.Instruction.BEGIN_GEOMETRY || instruction[0] === ol.render.canvas.Instruction.END_GEOMETRY) {\r\n                                            var featureInfo = instruction[1];\r\n                                            var feature = new ol.render.Feature(featureInfo.type_, featureInfo.flatCoordinates_, featureInfo.ends_, featureInfo.properties_);\r\n                                            feature[\"styleId\"] = featureInfo.styleId;\r\n                                            instruction[1] = feature;\r\n                                        }\r\n                                    }\r\n                                    for (var i_3 = 0; i_3 < workReplay.hitDetectionInstructions.length; i_3++) {\r\n                                        var hitInstruction = workReplay.hitDetectionInstructions[i_3];\r\n                                        if (hitInstruction[0] === ol.render.canvas.Instruction.SET_FILL_STYLE && hitInstruction[1].indexOf(\"hatch\") === 0) {\r\n                                            var hatchInstruction = hitInstruction[1];\r\n                                            var geoStyleId = hatchInstruction.split(\"|\")[1];\r\n                                            var geoStyle = geoStyles_1[geoStyleId];\r\n                                            if (geoStyle) {\r\n                                                geoStyle.initialize();\r\n                                                hitInstruction[1] = geoStyle.geoBrush;\r\n                                            }\r\n                                        }\r\n                                        if (hitInstruction[0] === ol.render.canvas.Instruction.BEGIN_GEOMETRY || hitInstruction[0] === ol.render.canvas.Instruction.END_GEOMETRY) {\r\n                                            var hitfeatureInfo = hitInstruction[1];\r\n                                            var hitfeature = new ol.render.Feature(hitfeatureInfo.type_, hitfeatureInfo.flatCoordinates_, hitfeatureInfo.ends_, hitfeatureInfo.properties_);\r\n                                            hitfeature[\"styleId\"] = hitfeatureInfo.styleId;\r\n                                            hitInstruction[1] = hitfeature;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                for (var key in workReplay) {\r\n                                    if (key === \"pixelCoordinates_\") {\r\n                                        replay[key] = new Int32Array(workReplay[key]);\r\n                                    }\r\n                                    else {\r\n                                        replay[key] = workReplay[key];\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        for (var r in replayGroup_1.getReplays()) {\r\n                            zIndexKeys[r] = true;\r\n                        }\r\n                        replayState.renderedTileLoaded = true;\r\n                        sourceTile.state = ol.TileState.LOADED;\r\n                        if (sourceTile[\"reuseVectorImageTile\"]) {\r\n                            for (var i = 0; i < sourceTile[\"reuseVectorImageTile\"].length; i++) {\r\n                                var reusedVectorImageTile = sourceTile[\"reuseVectorImageTile\"][i];\r\n                                delete sourceTile[\"reuseVectorImageTile\"][i];\r\n                                var vectorImageTileReplayState = reusedVectorImageTile.getReplayState(layer);\r\n                                vectorImageTileReplayState.renderedRevision = revision;\r\n                                vectorImageTileReplayState.renderedRenderOrder = renderOrder;\r\n                                vectorImageTileReplayState.renderedTileLoaded = true;\r\n                                reusedVectorImageTile.setState(ol.TileState.LOADED);\r\n                            }\r\n                        }\r\n                        tile.setState(ol.TileState.LOADED);\r\n                    };\r\n                    //// reuse replayGroup of source Tile to reduce the memory.\r\n                    sourceTile.setReplayGroup(layer, sourceTile.tileCoord.toString(), replayGroup_1);\r\n                    source.getGeoFormat().workerManager.postMessage(sourceTile.tileCoord + ol.getUid(callabck), \"createReplay\", messageData, callabck, sourceTile.workerId);\r\n                    replayState.renderedRevision = revision;\r\n                    replayState.renderedTileLoaded = false;\r\n                }\r\n                else {\r\n                    if (instructs && instructs.length > 0) {\r\n                        for (var i = 0; i < instructs.length; i++) {\r\n                            var featureIndex = instructs[i][0];\r\n                            var feature = features[featureIndex];\r\n                            if (feature[\"projected\"] === undefined) {\r\n                                if (reproject) {\r\n                                    if (tileProjection.getUnits() === ol.proj.Units.TILE_PIXELS) {\r\n                                        // projected tile extent\r\n                                        tileProjection.setWorldExtent(sourceTileExtent);\r\n                                        // tile extent in tile pixel space\r\n                                        tileProjection.setExtent(sourceTile.getExtent());\r\n                                    }\r\n                                    feature.getGeometry().transform(tileProjection, projection);\r\n                                    feature.extent_ = null;\r\n                                    feature.getExtent();\r\n                                }\r\n                                feature[\"projected\"] = \"\";\r\n                            }\r\n                            feature[\"tempTreeZindex\"] = instructs[i][2];\r\n                            renderFeature_1.call(this_1, feature, [instructs[i][1]], { strategyTree: strategyTree_1, frameState: frameState });\r\n                        }\r\n                    }\r\n                    replayGroup_1.finish();\r\n                    for (var r in replayGroup_1.getReplays()) {\r\n                        zIndexKeys[r] = true;\r\n                    }\r\n                    sourceTile.setReplayGroup(layer, sourceTile.tileCoord.toString(), replayGroup_1);\r\n                    replayState.renderedRevision = revision;\r\n                    replayState.renderedRenderOrder = renderOrder;\r\n                    replayState.renderedTileLoaded = true;\r\n                }\r\n            }\r\n        };\r\n        var this_1 = this, rendera;\r\n        for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\r\n            _loop_1(t, tt);\r\n        }\r\n    };\r\n    GeoVectorTileLayerRender.prototype.renderTileImageCustom = function (tile, frameState, layerState) {\r\n        var layer = this.getLayer();\r\n        var replayState = tile.getReplayState(layer);\r\n        var revision = layer.getRevision();\r\n        var replays = ol.renderer.canvas.VectorTileLayer.IMAGE_REPLAYS[layer.getRenderMode()];\r\n        if (replays && replayState.renderedTileLoaded && replayState.renderedTileRevision !== revision) {\r\n            replayState.renderedTileRevision = revision;\r\n            var tileCoord = tile.wrappedTileCoord;\r\n            var z = tileCoord[0];\r\n            var pixelRatio = frameState.pixelRatio;\r\n            var source = /** @type {ol.source.VectorTile} */ (layer.getSource());\r\n            var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\r\n            var resolution = tileGrid.getResolution(z);\r\n            var context = tile.getContext(layer);\r\n            var size = source.getTilePixelSize(z, pixelRatio, frameState.viewState.projection);\r\n            context.canvas.width = size[0];\r\n            context.canvas.height = size[1];\r\n            var tileExtent = tileGrid.getTileCoordExtent(tileCoord);\r\n            if (layer.background) {\r\n                context.rect(0, 0, size[0], size[1]);\r\n                context.fillStyle = layer.background;\r\n                context.fill();\r\n            }\r\n            for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\r\n                var sourceTile = tile.getTile(tile.tileKeys[i]);\r\n                if (sourceTile.getState() === ol.TileState.ERROR) {\r\n                    continue;\r\n                }\r\n                var pixelScale = pixelRatio / resolution;\r\n                var transform = ol.transform.reset(this.tmpTransform_);\r\n                ol.transform.scale(transform, pixelScale, -pixelScale);\r\n                ol.transform.translate(transform, -tileExtent[0], -tileExtent[3]);\r\n                //// reuse replayGroup of source Tile to reduce the memory.\r\n                var replayGroup = sourceTile.getReplayGroup(layer, tileCoord);\r\n                replayGroup.replay(context, transform, 0, {}, replays);\r\n            }\r\n        }\r\n    };\r\n    GeoVectorTileLayerRender.handles = function (type, layer) {\r\n        return type === ol.renderer.Type.CANVAS && layer.getType() === ol.LayerType.MAPSUITE_VECTORTILE;\r\n    };\r\n    GeoVectorTileLayerRender.create = function (mapRenderer, layer) {\r\n        return new GeoVectorTileLayerRender(layer);\r\n    };\r\n    GeoVectorTileLayerRender.prototype.disposeInternal = function () {\r\n        ol.events.unlisten(ol.render.canvas.labelCache, ol.events.EventType.CLEAR, this.handleFontsChanged_, this);\r\n        var workerManager = this.getLayer().getSource().getGeoFormat().workerManager;\r\n        workerManager.close();\r\n        ol.renderer.canvas.TileLayer.prototype.disposeInternal.call(this);\r\n    };\r\n    ;\r\n    return GeoVectorTileLayerRender;\r\n}(ol.renderer.canvas.VectorTileLayer));\r\n\r\n\n\n//# sourceURL=webpack:///./src/render/geoVectorTilelayerRender.ts?");

/***/ }),

/***/ "./src/render/replayGroupCustom.ts":
/*!*****************************************!*\
  !*** ./src/render/replayGroupCustom.ts ***!
  \*****************************************/
/*! exports provided: ReplayGroupCustom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReplayGroupCustom\", function() { return ReplayGroupCustom; });\n/* harmony import */ var _textReplayCustom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./textReplayCustom */ \"./src/render/textReplayCustom.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar ReplayGroupCustom = /** @class */ (function (_super) {\r\n    __extends(ReplayGroupCustom, _super);\r\n    function ReplayGroupCustom(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {\r\n        var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) || this;\r\n        _this.BATCH_CONSTRUCTORS_CUSTOM = {\r\n            \"Circle\": ol.render.canvas.PolygonReplay,\r\n            \"Default\": ol.render.canvas.Replay,\r\n            \"Image\": ol.render.canvas.ImageReplay,\r\n            \"LineString\": ol.render.canvas.LineStringReplay,\r\n            \"Polygon\": ol.render.canvas.PolygonReplay,\r\n            \"Text\": _textReplayCustom__WEBPACK_IMPORTED_MODULE_0__[\"TextReplayCustom\"]\r\n        };\r\n        _this.getReplay = _this.getReplayCustom;\r\n        _this.BATCH_CONSTRUCTORS_ = _this.BATCH_CONSTRUCTORS_CUSTOM;\r\n        // this.replay = this.replayCustom;\r\n        _this.forEachFeatureAtCoordinate = _this.forEachFeatureAtCoordinateCustom;\r\n        return _this;\r\n    }\r\n    ReplayGroupCustom.prototype.forEachFeatureAtCoordinateCustom = function (coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {\r\n        hitTolerance = Math.round(hitTolerance);\r\n        var contextSize = hitTolerance * 2 + 1;\r\n        var transform = ol.transform.compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\r\n        var context = this.hitDetectionContext_;\r\n        if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\r\n            context.canvas.width = contextSize;\r\n            context.canvas.height = contextSize;\r\n        }\r\n        else {\r\n            context.clearRect(0, 0, contextSize, contextSize);\r\n        }\r\n        /**\r\n         * @type {ol.Extent}\r\n         */\r\n        var hitExtent;\r\n        if (this.renderBuffer_ !== undefined) {\r\n            hitExtent = ol.extent.createEmpty();\r\n            ol.extent.extendCoordinate(hitExtent, coordinate);\r\n            ol.extent.buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\r\n        }\r\n        var mask = ol.render.canvas.ReplayGroup.getCircleArray_(hitTolerance);\r\n        var declutteredFeatures;\r\n        // if (this.declutterTree_) {\r\n        //     declutteredFeatures = this.declutterTree_.all().map(function (entry) {\r\n        //         return entry.value;\r\n        //     });\r\n        // }\r\n        /**\r\n         * @param {ol.Feature|ol.render.Feature} feature Feature.\r\n         * @return {?} Callback result.\r\n         */\r\n        function hitDetectionCallback(feature) {\r\n            var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\r\n            for (var i = 0; i < contextSize; i++) {\r\n                for (var j = 0; j < contextSize; j++) {\r\n                    if (mask[i][j]) {\r\n                        if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\r\n                            var result = void 0;\r\n                            if (!declutteredFeatures || declutteredFeatures.indexOf(feature) !== -1) {\r\n                                result = callback(feature);\r\n                            }\r\n                            if (result) {\r\n                                return result;\r\n                            }\r\n                            else {\r\n                                context.clearRect(0, 0, contextSize, contextSize);\r\n                                return undefined;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return this.replayHitDetection_(context, transform, rotation, skippedFeaturesHash, hitDetectionCallback, hitExtent, declutterReplays);\r\n    };\r\n    ReplayGroupCustom.prototype.replayCustom = function (context, transform, viewRotation, skippedFeaturesHash, opt_replayTypes, opt_declutterReplays) {\r\n        /** @type {Array.<number>} */\r\n        var zs = Object.keys(this.replaysByZIndex_).map(Number);\r\n        zs.sort(ol.array.numberSafeCompareFunction);\r\n        // setup clipping so that the parts of over-simplified geometries are not\r\n        // visible outside the current extent when panning\r\n        context.save();\r\n        this.clip(context, transform);\r\n        var replayTypes = opt_replayTypes ? opt_replayTypes : ol.render.replay.ORDER;\r\n        var i, ii, j, jj, replays, replay;\r\n        for (i = 0, ii = zs.length; i < ii; ++i) {\r\n            var zIndexKey = zs[i].toString();\r\n            replays = this.replaysByZIndex_[zIndexKey];\r\n            for (j = 0, jj = replayTypes.length; j < jj; ++j) {\r\n                var replayType = replayTypes[j];\r\n                replay = replays[replayType];\r\n                if (replay !== undefined) {\r\n                    if (opt_declutterReplays &&\r\n                        (replayType === ol.render.ReplayType.IMAGE || replayType === ol.render.ReplayType.TEXT)) {\r\n                        var declutter = opt_declutterReplays[zIndexKey];\r\n                        if (!declutter) {\r\n                            opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\r\n                        }\r\n                        else {\r\n                            declutter.push(replay, transform.slice(0));\r\n                        }\r\n                    }\r\n                    else {\r\n                        replay.replay(context, transform, viewRotation, skippedFeaturesHash);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        context.restore();\r\n    };\r\n    ReplayGroupCustom.prototype.getReplayCustom = function (zIndex, replayType) {\r\n        var zIndexKey = zIndex !== undefined ? zIndex.toString() : \"0\";\r\n        var replays = this.replaysByZIndex_[zIndexKey];\r\n        if (replays === undefined) {\r\n            replays = {};\r\n            this.replaysByZIndex_[zIndexKey] = replays;\r\n        }\r\n        var replay = replays[replayType];\r\n        if (replay === undefined) {\r\n            var Constructor = this.BATCH_CONSTRUCTORS_[replayType];\r\n            replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);\r\n            replays[replayType] = replay;\r\n        }\r\n        return replay;\r\n    };\r\n    return ReplayGroupCustom;\r\n}(ol.render.canvas.ReplayGroup));\r\n\r\n\n\n//# sourceURL=webpack:///./src/render/replayGroupCustom.ts?");

/***/ }),

/***/ "./src/render/textReplayCustom.ts":
/*!****************************************!*\
  !*** ./src/render/textReplayCustom.ts ***!
  \****************************************/
/*! exports provided: TextReplayCustom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextReplayCustom\", function() { return TextReplayCustom; });\n/* harmony import */ var _style_textLabelingStrategy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../style/textLabelingStrategy */ \"./src/style/textLabelingStrategy.ts\");\n/* harmony import */ var _style_detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style/detectTextLabelingStrategy */ \"./src/style/detectTextLabelingStrategy.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n\r\nvar TextReplayCustom = /** @class */ (function (_super) {\r\n    __extends(TextReplayCustom, _super);\r\n    function TextReplayCustom(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\r\n        var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) || this;\r\n        _this.renderDeclutterChar_ = function (declutterGroup, feature) {\r\n            if (declutterGroup && declutterGroup.length > 5) {\r\n                var groupCount = declutterGroup[4];\r\n                if (groupCount == 1 || groupCount == declutterGroup.length - 5) {\r\n                    /** @type {ol.RBushEntry} */\r\n                    var box = {\r\n                        minX: /** @type {number} */ (declutterGroup[0]),\r\n                        minY: /** @type {number} */ (declutterGroup[1]),\r\n                        maxX: /** @type {number} */ (declutterGroup[2]),\r\n                        maxY: /** @type {number} */ (declutterGroup[3]),\r\n                        value: feature\r\n                    };\r\n                    if (!this.declutterTree.collides(box)) {\r\n                        this.declutterTree.insert(box);\r\n                        var drawImage = ol.render.canvas.drawImage;\r\n                        for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {\r\n                            var declutterData = /** @type {Array} */ (declutterGroup[j]);\r\n                            if (declutterData) {\r\n                                if (declutterData.length > 11) {\r\n                                    this.replayTextBackground_(declutterData[0], declutterData[13], declutterData[14], declutterData[15], declutterData[16], declutterData[11], declutterData[12]);\r\n                                }\r\n                                var labelInfo = declutterData[3];\r\n                                var labelImage = this.getImage(labelInfo[\"text\"], labelInfo[\"textKey\"], labelInfo[\"fillKey\"], labelInfo[\"strokeKey\"]);\r\n                                declutterData[3] = labelImage;\r\n                                drawImage.apply(undefined, declutterData);\r\n                            }\r\n                        }\r\n                    }\r\n                    declutterGroup.length = 5;\r\n                    ol.extent.createOrUpdateEmpty(declutterGroup);\r\n                }\r\n            }\r\n        };\r\n        _this.BATCH_CONSTRUCTORS_CUSTOM = {\r\n            \"Point\": _style_detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_1__[\"DetectTextLabelingStrategy\"],\r\n            \"MultiPoint\": _style_textLabelingStrategy__WEBPACK_IMPORTED_MODULE_0__[\"TextLabelingStrategy\"],\r\n            \"LineString\": _style_textLabelingStrategy__WEBPACK_IMPORTED_MODULE_0__[\"TextLabelingStrategy\"],\r\n            \"Circle\": _style_textLabelingStrategy__WEBPACK_IMPORTED_MODULE_0__[\"TextLabelingStrategy\"],\r\n            \"MultiLineString\": _style_textLabelingStrategy__WEBPACK_IMPORTED_MODULE_0__[\"TextLabelingStrategy\"],\r\n            \"Polygon\": _style_textLabelingStrategy__WEBPACK_IMPORTED_MODULE_0__[\"TextLabelingStrategy\"],\r\n            \"MultiPolygon\": _style_textLabelingStrategy__WEBPACK_IMPORTED_MODULE_0__[\"TextLabelingStrategy\"]\r\n        };\r\n        _this.drawText = _this.drawTextCustom;\r\n        _this.setTextStyle = _this.setTextStyleCustom;\r\n        _this.replay_ = _this.replayCustom;\r\n        _this.labelInfoCache = new ol.structs.LRUCache();\r\n        return _this;\r\n    }\r\n    TextReplayCustom.prototype.replayCustom = function (context, transform, skippedFeaturesHash, instructions, featureCallback, opt_hitExtent) {\r\n        /** @type {Array.<number>} */\r\n        var pixelExten;\r\n        pixelExten = ol.geom.flat.transform.transform2D(this.maxExtent, 0, this.maxExtent.length, 2, transform, this[\"pixelExten\"]);\r\n        var pixelCoordinates;\r\n        if (this.pixelCoordinates_ && ol.array.equals(transform, this.renderedTransform_)) {\r\n            pixelCoordinates = this.pixelCoordinates_;\r\n        }\r\n        else {\r\n            if (!this.pixelCoordinates_) {\r\n                this.pixelCoordinates_ = [];\r\n            }\r\n            pixelCoordinates = ol.geom.flat.transform.transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\r\n            ol.transform.setFromArray(this.renderedTransform_, transform);\r\n        }\r\n        var quickZoom = false;\r\n        if (context[\"quickZoom\"] !== undefined) {\r\n            quickZoom = context[\"quickZoom\"];\r\n        }\r\n        var skipFeatures = !ol.obj.isEmpty(skippedFeaturesHash);\r\n        var i = 0; // instruction index\r\n        var ii = instructions.length; // end of instructions\r\n        var d = 0; // data index\r\n        var dd; // end of per-instruction data\r\n        var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\r\n        var pendingFill = 0;\r\n        var pendingStroke = 0;\r\n        var lastFillInstruction = null;\r\n        var lastStrokeInstruction = null;\r\n        var coordinateCache = this.coordinateCache_;\r\n        var viewRotation = this.viewRotation_;\r\n        var state = /** @type {olx.render.State} */ ({\r\n            context: context,\r\n            pixelRatio: this.pixelRatio,\r\n            resolution: this.resolution,\r\n            rotation: viewRotation\r\n        });\r\n        // When the batch size gets too big, performance decreases. 200 is a good\r\n        // balance between batch size and number of fill/stroke instructions.\r\n        var batchSize = this.instructions !== instructions || this.overlaps ? 0 : 200;\r\n        var currentResolution = context[\"currentResolution\"];\r\n        var ratio = window.devicePixelRatio * 1.194328566955879 / currentResolution;\r\n        if (ratio >= 3) {\r\n            ratio /= 2;\r\n        }\r\n        while (i < ii) {\r\n            var instruction = instructions[i];\r\n            var type = /** @type {ol.render.canvas.Instruction} */ (instruction[0]);\r\n            var /** @type {ol.Feature|ol.render.Feature} */ feature = void 0, x = void 0, y = void 0;\r\n            switch (type) {\r\n                case ol.render.canvas.Instruction.BEGIN_GEOMETRY:\r\n                    feature = /** @type {ol.Feature|ol.render.Feature} */ (instruction[1]);\r\n                    if ((skipFeatures && skippedFeaturesHash[ol.getUid(feature).toString()]) || !feature.getGeometry()) {\r\n                        i = /** @type {number} */ (instruction[2]);\r\n                    }\r\n                    else if (opt_hitExtent !== undefined && !ol.extent.intersects(opt_hitExtent, feature.getGeometry().getExtent())) {\r\n                        i = /** @type {number} */ (instruction[2]) + 1;\r\n                    }\r\n                    else {\r\n                        ++i;\r\n                    }\r\n                    break;\r\n                case ol.render.canvas.Instruction.BEGIN_PATH:\r\n                    if (pendingFill > batchSize) {\r\n                        this.fill_(context);\r\n                        pendingFill = 0;\r\n                    }\r\n                    if (pendingStroke > batchSize) {\r\n                        context.stroke();\r\n                        pendingStroke = 0;\r\n                    }\r\n                    if (!pendingFill && !pendingStroke) {\r\n                        context.beginPath();\r\n                        prevX = prevY = NaN;\r\n                    }\r\n                    ++i;\r\n                    break;\r\n                case ol.render.canvas.Instruction.CIRCLE:\r\n                    d = /** @type {number} */ (instruction[1]);\r\n                    var x1 = pixelCoordinates[d];\r\n                    var y1 = pixelCoordinates[d + 1];\r\n                    var x2 = pixelCoordinates[d + 2];\r\n                    var y2 = pixelCoordinates[d + 3];\r\n                    var dx = x2 - x1;\r\n                    var dy = y2 - y1;\r\n                    var r = Math.sqrt(dx * dx + dy * dy);\r\n                    context.moveTo(x1 + r, y1);\r\n                    context.arc(x1, y1, r, 0, 2 * Math.PI, true);\r\n                    ++i;\r\n                    break;\r\n                case ol.render.canvas.Instruction.CLOSE_PATH:\r\n                    context.closePath();\r\n                    ++i;\r\n                    break;\r\n                case ol.render.canvas.Instruction.CUSTOM:\r\n                    d = /** @type {number} */ (instruction[1]);\r\n                    dd = instruction[2];\r\n                    var geometry = /** @type {ol.geom.SimpleGeometry} */ (instruction[3]);\r\n                    var renderer = instruction[4];\r\n                    var fn = instruction.length === 6 ? instruction[5] : undefined;\r\n                    state.geometry = geometry;\r\n                    state.feature = feature;\r\n                    if (!(i in coordinateCache)) {\r\n                        coordinateCache[i] = [];\r\n                    }\r\n                    var coords = coordinateCache[i];\r\n                    if (fn) {\r\n                        fn(pixelCoordinates, d, dd, 2, coords);\r\n                    }\r\n                    else {\r\n                        coords[0] = pixelCoordinates[d];\r\n                        coords[1] = pixelCoordinates[d + 1];\r\n                        coords.length = 2;\r\n                    }\r\n                    renderer(coords, state);\r\n                    ++i;\r\n                    break;\r\n                case ol.render.canvas.Instruction.DRAW_IMAGE:\r\n                    d = /** @type {number} */ (instruction[1]);\r\n                    dd = /** @type {number} */ (instruction[2]);\r\n                    image = /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */ (instruction[3]);\r\n                    // Remaining arguments in DRAW_IMAGE are in alphabetical order\r\n                    anchorX = /** @type {number} */ (instruction[4]);\r\n                    anchorY = /** @type {number} */ (instruction[5]);\r\n                    declutterGroup = featureCallback ? null : /** @type {ol.DeclutterGroup} */ (instruction[6]);\r\n                    var height = /** @type {number} */ (instruction[7]);\r\n                    var opacity = /** @type {number} */ (instruction[8]);\r\n                    var originX = /** @type {number} */ (instruction[9]);\r\n                    var originY = /** @type {number} */ (instruction[10]);\r\n                    var rotateWithView = /** @type {boolean} */ (instruction[11]);\r\n                    var rotation = /** @type {number} */ (instruction[12]);\r\n                    var scale = /** @type {number} */ (instruction[13]);\r\n                    var snapToPixel = /** @type {boolean} */ (instruction[14]);\r\n                    var width = /** @type {number} */ (instruction[15]);\r\n                    var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;\r\n                    if (instruction.length > 16) {\r\n                        padding = /** @type {Array.<number>} */ (instruction[16]);\r\n                        backgroundFill = /** @type {boolean} */ (instruction[17]);\r\n                        backgroundStroke = /** @type {boolean} */ (instruction[18]);\r\n                    }\r\n                    else {\r\n                        padding = ol.render.canvas.defaultPadding;\r\n                        backgroundFill = backgroundStroke = false;\r\n                    }\r\n                    if (rotateWithView) {\r\n                        rotation += viewRotation;\r\n                    }\r\n                    for (; d < dd; d += 2) {\r\n                        this.replayImage_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ? /** @type {Array.<*>} */ (lastFillInstruction) : null, backgroundStroke ? /** @type {Array.<*>} */ (lastStrokeInstruction) : null);\r\n                    }\r\n                    this.renderDeclutter_(declutterGroup, feature);\r\n                    ++i;\r\n                    break;\r\n                case ol.render.canvas.Instruction.DRAW_CHARS:\r\n                    if (!quickZoom) {\r\n                        var begin = /** @type {number} */ (instruction[1]);\r\n                        var end = /** @type {number} */ (instruction[2]);\r\n                        var baseline = /** @type {number} */ (instruction[3]);\r\n                        declutterGroup = featureCallback ? null : /** @type {ol.DeclutterGroup} */ (instruction[4]);\r\n                        var overflow = /** @type {number} */ (instruction[5]);\r\n                        var fillKey = /** @type {string} */ (instruction[6]);\r\n                        var maxAngle = /** @type {number} */ (instruction[7]);\r\n                        var measure = /** @type {function(string):number} */ (instruction[8]);\r\n                        var offsetY = /** @type {number} */ (instruction[9]);\r\n                        var strokeKey = /** @type {string} */ (instruction[10]);\r\n                        var strokeWidth = /** @type {number} */ (instruction[11]);\r\n                        var text = /** @type {string} */ (instruction[12]);\r\n                        var textKey = /** @type {string} */ (instruction[13]);\r\n                        var textScale = /** @type {number} */ (instruction[14]);\r\n                        var declutterGroups = [];\r\n                        var pathLength = ol.geom.flat.length.lineString(pixelCoordinates, begin, end, 2);\r\n                        var textLength = measure(text);\r\n                        if (overflow || textLength * 1.2 <= pathLength) {\r\n                            // The original logical is create label image --> declutterGroup --> draw label image to context\r\n                            // The newest logical is  create label info and create image instruction --> declutterGroup --> create label image --> draw label image to context\r\n                            var labelInstructions = [];\r\n                            var labelIndex = 0;\r\n                            if (currentResolution < 1) {\r\n                                var distance = 180 * ratio;\r\n                                var tmpLength = pathLength - textLength;\r\n                                var centerPoint = tmpLength / 2;\r\n                                var leftPoint = centerPoint;\r\n                                var rightPoint = centerPoint;\r\n                                var pointArray = [];\r\n                                pointArray.push(centerPoint);\r\n                                while (leftPoint > ((textLength / 2) + distance)) {\r\n                                    leftPoint = leftPoint - distance;\r\n                                    pointArray.push(leftPoint);\r\n                                }\r\n                                while (rightPoint < ((pathLength - textLength / 2) - distance)) {\r\n                                    rightPoint = rightPoint + distance;\r\n                                    pointArray.push(rightPoint);\r\n                                }\r\n                                for (var len = 0; len < pointArray.length; len++) {\r\n                                    var tempDeclutterGroup = void 0;\r\n                                    if (declutterGroup) {\r\n                                        tempDeclutterGroup = featureCallback ? null : declutterGroup.slice(0);\r\n                                    }\r\n                                    var startM = pointArray[len];\r\n                                    var parts = ol.geom.flat.textpath.lineString(pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\r\n                                    if (parts) {\r\n                                        var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;\r\n                                        if (strokeKey) {\r\n                                            for (c = 0, cc = parts.length; c < cc; ++c) {\r\n                                                part = parts[c]; // x, y, anchorX, rotation, chunk\r\n                                                chars = /** @type {string} */ (part[4]);\r\n                                                var labelInfo = undefined;\r\n                                                if (tempDeclutterGroup) {\r\n                                                    labelInfo = this.getImageInfo(chars, textKey, \"\", strokeKey);\r\n                                                    labelInstructions[labelIndex] = {\r\n                                                        chars: chars,\r\n                                                        textKey: textKey,\r\n                                                        fillKey: fillKey,\r\n                                                        strokeKey: \"\"\r\n                                                    };\r\n                                                    labelIndex += 1;\r\n                                                }\r\n                                                else {\r\n                                                    labelInfo = /** @type {ol.render.canvas.TextReplay} */ (this).getImage(chars, textKey, \"\", strokeKey);\r\n                                                }\r\n                                                anchorX = /** @type {number} */ (part[2]) + strokeWidth;\r\n                                                anchorY = baseline * labelInfo[\"height\"] + (0.5 - baseline) * 2 * strokeWidth - offsetY;\r\n                                                this.replayImage_(context, /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), labelInfo, anchorX, anchorY, tempDeclutterGroup, labelInfo[\"height\"], 1, 0, 0, /** @type {number} */ (part[3]), textScale, false, labelInfo[\"width\"], ol.render.canvas.defaultPadding, null, null);\r\n                                            }\r\n                                        }\r\n                                        if (fillKey) {\r\n                                            for (c = 0, cc = parts.length; c < cc; ++c) {\r\n                                                part = parts[c]; // x, y, anchorX, rotation, chunk\r\n                                                chars = /** @type {string} */ (part[4]);\r\n                                                var labelInfo = undefined;\r\n                                                if (tempDeclutterGroup) {\r\n                                                    labelInfo = this.getImageInfo(chars, textKey, fillKey, \"\");\r\n                                                    labelInstructions[labelIndex] = {\r\n                                                        chars: chars,\r\n                                                        textKey: textKey,\r\n                                                        fillKey: fillKey,\r\n                                                        strokeKey: \"\"\r\n                                                    };\r\n                                                    labelIndex += 1;\r\n                                                }\r\n                                                else {\r\n                                                    labelInfo = /** @type {ol.render.canvas.TextReplay} */ (this).getImage(chars, textKey, fillKey, \"\");\r\n                                                }\r\n                                                anchorX = /** @type {number} */ (part[2]);\r\n                                                anchorY = baseline * labelInfo[\"height\"] - offsetY;\r\n                                                this.replayImage_(context, /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), labelInfo, anchorX, anchorY, tempDeclutterGroup, labelInfo[\"height\"], 1, 0, 0, /** @type {number} */ (part[3]), textScale, false, labelInfo[\"width\"], ol.render.canvas.defaultPadding, null, null);\r\n                                            }\r\n                                        }\r\n                                        declutterGroups.push(tempDeclutterGroup);\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                var tempDeclutterGroup = void 0;\r\n                                if (declutterGroup) {\r\n                                    tempDeclutterGroup = featureCallback ? null : declutterGroup.slice(0);\r\n                                }\r\n                                var textAlign = /** @type {ol.render.canvas.TextReplay} */ (this).textStates[textKey].textAlign;\r\n                                var startM_1 = (pathLength - textLength) * ol.render.replay.TEXT_ALIGN[textAlign];\r\n                                var parts = ol.geom.flat.textpath.lineString(pixelCoordinates, begin, end, 2, text, measure, startM_1, maxAngle);\r\n                                if (parts) {\r\n                                    var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;\r\n                                    if (strokeKey) {\r\n                                        for (c = 0, cc = parts.length; c < cc; ++c) {\r\n                                            part = parts[c]; // x, y, anchorX, rotation, chunk\r\n                                            chars = /** @type {string} */ (part[4]);\r\n                                            var labelInfo = undefined;\r\n                                            if (tempDeclutterGroup) {\r\n                                                labelInfo = this.getImageInfo(chars, textKey, \"\", strokeKey);\r\n                                                labelInstructions[labelIndex] = {\r\n                                                    chars: chars,\r\n                                                    textKey: textKey,\r\n                                                    fillKey: fillKey,\r\n                                                    strokeKey: \"\"\r\n                                                };\r\n                                                labelIndex += 1;\r\n                                            }\r\n                                            else {\r\n                                                labelInfo = /** @type {ol.render.canvas.TextReplay} */ (this).getImage(chars, textKey, \"\", strokeKey);\r\n                                            }\r\n                                            // label = /** @type {ol.render.canvas.TextReplay} */ (this).getImage(chars, textKey, \"\", strokeKey);\r\n                                            anchorX = /** @type {number} */ (part[2]) + strokeWidth;\r\n                                            anchorY = baseline * labelInfo[\"height\"] + (0.5 - baseline) * 2 * strokeWidth - offsetY;\r\n                                            this.replayImage_(context, /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), labelInfo, anchorX, anchorY, tempDeclutterGroup, labelInfo[\"height\"], 1, 0, 0, /** @type {number} */ (part[3]), textScale, false, labelInfo[\"width\"], ol.render.canvas.defaultPadding, null, null);\r\n                                        }\r\n                                    }\r\n                                    if (fillKey) {\r\n                                        for (c = 0, cc = parts.length; c < cc; ++c) {\r\n                                            part = parts[c]; // x, y, anchorX, rotation, chunk\r\n                                            chars = /** @type {string} */ (part[4]);\r\n                                            var labelInfo = undefined;\r\n                                            if (tempDeclutterGroup) {\r\n                                                labelInfo = this.getImageInfo(chars, textKey, fillKey, \"\");\r\n                                                labelInstructions[labelIndex] = {\r\n                                                    chars: chars,\r\n                                                    textKey: textKey,\r\n                                                    fillKey: fillKey,\r\n                                                    strokeKey: \"\"\r\n                                                };\r\n                                                labelIndex += 1;\r\n                                            }\r\n                                            else {\r\n                                                labelInfo = /** @type {ol.render.canvas.TextReplay} */ (this).getImage(chars, textKey, fillKey, \"\");\r\n                                            }\r\n                                            anchorX = /** @type {number} */ (part[2]);\r\n                                            anchorY = baseline * labelInfo[\"height\"] - offsetY;\r\n                                            this.replayImage_(context, /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), labelInfo, anchorX, anchorY, tempDeclutterGroup, labelInfo[\"height\"], 1, 0, 0, /** @type {number} */ (part[3]), textScale, false, labelInfo[\"width\"], ol.render.canvas.defaultPadding, null, null);\r\n                                        }\r\n                                    }\r\n                                    declutterGroups.push(tempDeclutterGroup);\r\n                                }\r\n                            }\r\n                        }\r\n                        for (var d_1 = 0; d_1 < declutterGroups.length; d_1++) {\r\n                            var targetDeclutterGroup = declutterGroups[d_1];\r\n                            if (targetDeclutterGroup && targetDeclutterGroup.length > 5) {\r\n                                var targetExtent = [targetDeclutterGroup[0], targetDeclutterGroup[1], targetDeclutterGroup[2], targetDeclutterGroup[3]];\r\n                                if (targetExtent[0] > pixelExten[0] && targetExtent[1] > pixelExten[3] && targetExtent[2] < pixelExten[2] && targetExtent[3] < pixelExten[1]) {\r\n                                    this.renderDeclutterChar_(targetDeclutterGroup, feature);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    ++i;\r\n                    break;\r\n                case ol.render.canvas.Instruction.END_GEOMETRY:\r\n                    if (featureCallback !== undefined) {\r\n                        feature = /** @type {ol.Feature|ol.render.Feature} */ (instruction[1]);\r\n                        var result = featureCallback(feature);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    }\r\n                    ++i;\r\n                    break;\r\n                case ol.render.canvas.Instruction.FILL:\r\n                    if (batchSize) {\r\n                        pendingFill++;\r\n                    }\r\n                    else {\r\n                        this.fill_(context);\r\n                    }\r\n                    ++i;\r\n                    break;\r\n                case ol.render.canvas.Instruction.MOVE_TO_LINE_TO:\r\n                    d = /** @type {number} */ (instruction[1]);\r\n                    dd = /** @type {number} */ (instruction[2]);\r\n                    x = pixelCoordinates[d];\r\n                    y = pixelCoordinates[d + 1];\r\n                    roundX = (x + 0.5) | 0;\r\n                    roundY = (y + 0.5) | 0;\r\n                    if (roundX !== prevX || roundY !== prevY) {\r\n                        context.moveTo(x, y);\r\n                        prevX = roundX;\r\n                        prevY = roundY;\r\n                    }\r\n                    for (d += 2; d < dd; d += 2) {\r\n                        x = pixelCoordinates[d];\r\n                        y = pixelCoordinates[d + 1];\r\n                        roundX = (x + 0.5) | 0;\r\n                        roundY = (y + 0.5) | 0;\r\n                        if (d === dd - 2 || roundX !== prevX || roundY !== prevY) {\r\n                            context.lineTo(x, y);\r\n                            prevX = roundX;\r\n                            prevY = roundY;\r\n                        }\r\n                    }\r\n                    ++i;\r\n                    break;\r\n                case ol.render.canvas.Instruction.SET_FILL_STYLE:\r\n                    lastFillInstruction = instruction;\r\n                    this.fillOrigin_ = instruction[2];\r\n                    if (pendingFill) {\r\n                        this.fill_(context);\r\n                        pendingFill = 0;\r\n                        if (pendingStroke) {\r\n                            context.stroke();\r\n                            pendingStroke = 0;\r\n                        }\r\n                    }\r\n                    context.fillStyle = /** @type {ol.ColorLike} */ (instruction[1]);\r\n                    ++i;\r\n                    break;\r\n                case ol.render.canvas.Instruction.SET_STROKE_STYLE:\r\n                    lastStrokeInstruction = instruction;\r\n                    if (pendingStroke) {\r\n                        context.stroke();\r\n                        pendingStroke = 0;\r\n                    }\r\n                    this.setStrokeStyle_(context, /** @type {Array.<*>} */ (instruction));\r\n                    ++i;\r\n                    break;\r\n                case ol.render.canvas.Instruction.STROKE:\r\n                    if (batchSize) {\r\n                        pendingStroke++;\r\n                    }\r\n                    else {\r\n                        context.stroke();\r\n                    }\r\n                    ++i;\r\n                    break;\r\n                default:\r\n                    ++i; // consume the instruction anyway, to avoid an infinite loop\r\n                    break;\r\n            }\r\n        }\r\n        if (pendingFill) {\r\n            this.fill_(context);\r\n        }\r\n        if (pendingStroke) {\r\n            context.stroke();\r\n        }\r\n        return undefined;\r\n    };\r\n    TextReplayCustom.prototype.replayImage_ = function (context, x, y, labelInfo, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\r\n        var fillStroke = fillInstruction || strokeInstruction;\r\n        var localTransform = this.tmpLocalTransform_;\r\n        anchorX *= scale;\r\n        anchorY *= scale;\r\n        x -= anchorX;\r\n        y -= anchorY;\r\n        if (snapToPixel) {\r\n            x = Math.ceil(x);\r\n            y = Math.ceil(y);\r\n        }\r\n        var w = (width + originX > labelInfo.width) ? labelInfo.width - originX : width;\r\n        var h = (height + originY > labelInfo.height) ? labelInfo.height - originY : height;\r\n        var box = this.tmpExtent_;\r\n        var boxW = padding[3] + w * scale + padding[1];\r\n        var boxH = padding[0] + h * scale + padding[2];\r\n        var boxX = x - padding[3];\r\n        var boxY = y - padding[0];\r\n        /** @type {ol.Coordinate} */\r\n        var p1;\r\n        /** @type {ol.Coordinate} */\r\n        var p2;\r\n        /** @type {ol.Coordinate} */\r\n        var p3;\r\n        /** @type {ol.Coordinate} */\r\n        var p4;\r\n        if (fillStroke || rotation !== 0) {\r\n            p1 = [boxX, boxY];\r\n            p2 = [boxX + boxW, boxY];\r\n            p3 = [boxX + boxW, boxY + boxH];\r\n            p4 = [boxX, boxY + boxH];\r\n        }\r\n        var transform = null;\r\n        if (rotation !== 0) {\r\n            var centerX = x + anchorX;\r\n            var centerY = y + anchorY;\r\n            transform = ol.transform.compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\r\n            ol.extent.createOrUpdateEmpty(box);\r\n            ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p1));\r\n            ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p2));\r\n            ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p3));\r\n            ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p4));\r\n        }\r\n        else {\r\n            ol.extent.createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, box);\r\n        }\r\n        var canvas = context.canvas;\r\n        var intersects = box[0] <= canvas.width && box[2] >= 0 && box[1] <= canvas.height && box[3] >= 0;\r\n        if (declutterGroup) {\r\n            if (!intersects && declutterGroup[4] == 1) {\r\n                return;\r\n            }\r\n            ol.extent.extend(declutterGroup, box);\r\n            var declutterArgs = intersects ?\r\n                [context, transform ? transform.slice(0) : null, opacity, labelInfo, originX, originY, w, h, x, y, scale] :\r\n                null;\r\n            if (declutterArgs && fillStroke) {\r\n                declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);\r\n            }\r\n            declutterGroup.push(declutterArgs);\r\n        }\r\n        else if (intersects) {\r\n            if (fillStroke) {\r\n                this.replayTextBackground_(context, p1, p2, p3, p4, \r\n                /** @type {Array.<*>} */ (fillInstruction), \r\n                /** @type {Array.<*>} */ (strokeInstruction));\r\n            }\r\n            ol.render.canvas.drawImage(context, transform, opacity, labelInfo, originX, originY, w, h, x, y, scale);\r\n        }\r\n    };\r\n    ;\r\n    // Get the image info, such as width, height\r\n    TextReplayCustom.prototype.getImageInfo = function (text, textKey, fillKey, strokeKey) {\r\n        var labelInfo = {};\r\n        labelInfo[\"text\"] = text;\r\n        labelInfo[\"textKey\"] = textKey;\r\n        labelInfo[\"fillKey\"] = fillKey;\r\n        labelInfo[\"strokeKey\"] = strokeKey;\r\n        var label;\r\n        var key = strokeKey + textKey + text + fillKey + this.pixelRatio;\r\n        if (!this.labelInfoCache.containsKey(key)) {\r\n            var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;\r\n            var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;\r\n            var textState = this.textStates[textKey] || this.textState_;\r\n            var pixelRatio = this.pixelRatio;\r\n            var scale = textState.scale * pixelRatio;\r\n            var align = ol.render.replay.TEXT_ALIGN[textState.textAlign || ol.render.canvas.defaultTextAlign];\r\n            var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\r\n            var lines = text.split('\\n');\r\n            var numLines = lines.length;\r\n            var widths = [];\r\n            var width = ol.render.canvas.TextReplay.measureTextWidths(textState.font, lines, widths);\r\n            var lineHeight = textState.lineHeight;\r\n            var height = lineHeight * numLines;\r\n            var renderWidth = (width + strokeWidth);\r\n            labelInfo[\"width\"] = Math.ceil(renderWidth * scale);\r\n            labelInfo[\"widths\"] = widths;\r\n            labelInfo[\"height\"] = Math.ceil((height + strokeWidth) * scale);\r\n            this.labelInfoCache.set(key, labelInfo);\r\n            return labelInfo;\r\n        }\r\n        return this.labelInfoCache.get(key);\r\n    };\r\n    TextReplayCustom.prototype.getImage = function (text, textKey, fillKey, strokeKey) {\r\n        var label;\r\n        var key = strokeKey + textKey + text + fillKey + this.pixelRatio;\r\n        var labelCache = ol.render.canvas.labelCache;\r\n        if (!labelCache.containsKey(key)) {\r\n            var labelInfo = this.labelInfoCache[\"key\"];\r\n            var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;\r\n            var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;\r\n            var textState = this.textStates[textKey] || this.textState_;\r\n            var pixelRatio = this.pixelRatio;\r\n            var scale = textState.scale * pixelRatio;\r\n            var align = ol.render.replay.TEXT_ALIGN[textState.textAlign || ol.render.canvas.defaultTextAlign];\r\n            var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\r\n            var lines = text.split('\\n');\r\n            var numLines = lines.length;\r\n            var widths = [];\r\n            var width;\r\n            var lineHeight;\r\n            if (labelInfo) {\r\n                width = labelInfo[\"width\"];\r\n            }\r\n            else {\r\n                width = ol.render.canvas.TextReplay.measureTextWidths(textState.font, lines, widths);\r\n            }\r\n            var lineHeight = textState[\"lineHeight\"];\r\n            var height = lineHeight * numLines;\r\n            var renderWidth = (width + strokeWidth);\r\n            var context = ol.dom.createCanvasContext2D(Math.ceil(renderWidth * scale), Math.ceil((height + strokeWidth) * scale));\r\n            label = context.canvas;\r\n            labelCache.set(key, label);\r\n            if (scale != 1) {\r\n                context.scale(scale, scale);\r\n            }\r\n            context.font = textState.font;\r\n            if (strokeKey) {\r\n                context.strokeStyle = strokeState.strokeStyle;\r\n                context.lineWidth = strokeWidth * (ol.has.SAFARI ? scale : 1);\r\n                context.lineCap = strokeState.lineCap;\r\n                context.lineJoin = strokeState.lineJoin;\r\n                context.miterLimit = strokeState.miterLimit;\r\n                if (ol.has.CANVAS_LINE_DASH && strokeState.lineDash.length) {\r\n                    context.setLineDash(strokeState.lineDash);\r\n                    context.lineDashOffset = strokeState.lineDashOffset;\r\n                }\r\n            }\r\n            if (fillKey) {\r\n                context.fillStyle = fillState.fillStyle;\r\n            }\r\n            context.textBaseline = 'middle';\r\n            context.textAlign = 'center';\r\n            var leftRight = (0.5 - align);\r\n            var x = align * label.width / scale + leftRight * strokeWidth;\r\n            var i;\r\n            if (strokeKey) {\r\n                for (i = 0; i < numLines; ++i) {\r\n                    context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\r\n                }\r\n            }\r\n            if (fillKey) {\r\n                for (i = 0; i < numLines; ++i) {\r\n                    context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\r\n                }\r\n            }\r\n        }\r\n        return labelCache.get(key);\r\n    };\r\n    ;\r\n    TextReplayCustom.prototype.drawChars_ = function (begin, end, declutterGroup) {\r\n        var strokeState = this.textStrokeState_;\r\n        var textState = this.textState_;\r\n        var fillState = this.textFillState_;\r\n        var strokeKey = this.strokeKey_;\r\n        if (strokeState) {\r\n            if (!(strokeKey in this.strokeStates)) {\r\n                this.strokeStates[strokeKey] = /** @type {ol.CanvasStrokeState} */ ({\r\n                    strokeStyle: strokeState.strokeStyle,\r\n                    lineCap: strokeState.lineCap,\r\n                    lineDashOffset: strokeState.lineDashOffset,\r\n                    lineWidth: strokeState.lineWidth,\r\n                    lineJoin: strokeState.lineJoin,\r\n                    miterLimit: strokeState.miterLimit,\r\n                    lineDash: strokeState.lineDash\r\n                });\r\n            }\r\n        }\r\n        var textKey = this.textKey_;\r\n        if (!(this.textKey_ in this.textStates)) {\r\n            this.textStates[this.textKey_] = /** @type {ol.CanvasTextState} */ ({\r\n                font: textState.font,\r\n                lineHeight: ol.render.canvas.measureTextHeight(textState.font),\r\n                textAlign: textState.textAlign || ol.render.canvas.defaultTextAlign,\r\n                scale: textState.scale\r\n            });\r\n        }\r\n        var fillKey = this.fillKey_;\r\n        if (fillState) {\r\n            if (!(fillKey in this.fillStates)) {\r\n                this.fillStates[fillKey] = /** @type {ol.CanvasFillState} */ ({\r\n                    fillStyle: fillState.fillStyle\r\n                });\r\n            }\r\n        }\r\n        var pixelRatio = this.pixelRatio;\r\n        var baseline = ol.render.replay.TEXT_ALIGN[textState.textBaseline];\r\n        var offsetY = this.textOffsetY_ * pixelRatio;\r\n        var text = this.text_;\r\n        var font = textState.font;\r\n        var textScale = textState.scale;\r\n        var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;\r\n        var widths = this.widths_[font];\r\n        if (!widths) {\r\n            this.widths_[font] = widths = {};\r\n        }\r\n        this.instructions.push([ol.render.canvas.Instruction.DRAW_CHARS,\r\n            begin, end, baseline, declutterGroup,\r\n            textState.overflow, fillKey, textState.maxAngle,\r\n            function (text) {\r\n                var width = widths[text];\r\n                if (!width) {\r\n                    width = widths[text] = ol.render.canvas.measureTextWidth(font, text);\r\n                }\r\n                return width * textScale * pixelRatio;\r\n            },\r\n            offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1\r\n        ]);\r\n        this.hitDetectionInstructions.push([ol.render.canvas.Instruction.DRAW_CHARS,\r\n            begin, end, baseline, declutterGroup,\r\n            textState.overflow, fillKey, textState.maxAngle,\r\n            function (text) {\r\n                var width = widths[text];\r\n                if (!width) {\r\n                    width = widths[text] = ol.render.canvas.measureTextWidth(font, text);\r\n                }\r\n                return width * textScale;\r\n            },\r\n            offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio\r\n        ]);\r\n    };\r\n    ;\r\n    TextReplayCustom.prototype.setTextStyleCustom = function (textStyle, declutterGroup) {\r\n        var textState, fillState, strokeState;\r\n        if (!textStyle) {\r\n            this.text_ = \"\";\r\n        }\r\n        else {\r\n            this.declutterGroup_ = /** @type {ol.DeclutterGroup} */ (declutterGroup);\r\n            var textFillStyle = textStyle.getFill();\r\n            if (!textFillStyle) {\r\n                fillState = this.textFillState_ = null;\r\n            }\r\n            else {\r\n                fillState = this.textFillState_;\r\n                if (!fillState) {\r\n                    fillState = this.textFillState_ = /** @type {ol.CanvasFillState} */ ({});\r\n                }\r\n                fillState.fillStyle = ol.colorlike.asColorLike(textFillStyle.getColor() || ol.render.canvas.defaultFillStyle);\r\n            }\r\n            var textStrokeStyle = textStyle.getStroke();\r\n            if (!textStrokeStyle) {\r\n                strokeState = this.textStrokeState_ = null;\r\n            }\r\n            else {\r\n                strokeState = this.textStrokeState_;\r\n                if (!strokeState) {\r\n                    strokeState = this.textStrokeState_ = /** @type {ol.CanvasStrokeState} */ ({});\r\n                }\r\n                var lineDash = textStrokeStyle.getLineDash();\r\n                var lineDashOffset = textStrokeStyle.getLineDashOffset();\r\n                var lineWidth = textStrokeStyle.getWidth();\r\n                var miterLimit = textStrokeStyle.getMiterLimit();\r\n                strokeState.lineCap = textStrokeStyle.getLineCap() || ol.render.canvas.defaultLineCap;\r\n                strokeState.lineDash = lineDash ? lineDash.slice() : ol.render.canvas.defaultLineDash;\r\n                strokeState.lineDashOffset =\r\n                    lineDashOffset === undefined ? ol.render.canvas.defaultLineDashOffset : lineDashOffset;\r\n                strokeState.lineJoin = textStrokeStyle.getLineJoin() || ol.render.canvas.defaultLineJoin;\r\n                strokeState.lineWidth =\r\n                    lineWidth === undefined ? ol.render.canvas.defaultLineWidth : lineWidth;\r\n                strokeState.miterLimit =\r\n                    miterLimit === undefined ? ol.render.canvas.defaultMiterLimit : miterLimit;\r\n                strokeState.strokeStyle = ol.colorlike.asColorLike(textStrokeStyle.getColor() || ol.render.canvas.defaultStrokeStyle);\r\n            }\r\n            textState = this.textState_;\r\n            var font = textStyle.getFont() || ol.render.canvas.defaultFont;\r\n            ol.render.canvas.checkFont(font);\r\n            var textScale = textStyle.getScale();\r\n            textState.overflow = textStyle.getOverflow();\r\n            textState.font = font;\r\n            textState.maxAngle = textStyle.getMaxAngle();\r\n            textState.placement = textStyle.getPlacement();\r\n            textState.textAlign = textStyle.getTextAlign();\r\n            textState.textBaseline = textStyle.getTextBaseline() || ol.render.canvas.defaultTextBaseline;\r\n            textState.backgroundFill = textStyle.getBackgroundFill();\r\n            textState.backgroundStroke = textStyle.getBackgroundStroke();\r\n            textState.padding = textStyle.getPadding() || ol.render.canvas.defaultPadding;\r\n            textState.scale = textScale === undefined ? 1 : textScale;\r\n            var textOffsetX = textStyle.getOffsetX();\r\n            var textOffsetY = textStyle.getOffsetY();\r\n            var textRotateWithView = textStyle.getRotateWithView();\r\n            var textRotation = textStyle.getRotation();\r\n            this.text_ = textStyle.getText() || \"\";\r\n            this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\r\n            this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\r\n            this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\r\n            this.textRotation_ = textRotation === undefined ? 0 : textRotation;\r\n            this.strokeKey_ = strokeState ?\r\n                (typeof strokeState.strokeStyle === \"string\" ? strokeState.strokeStyle : ol.getUid(strokeState.strokeStyle)) +\r\n                    strokeState.lineCap + strokeState.lineDashOffset + \"|\" + strokeState.lineWidth +\r\n                    strokeState.lineJoin + strokeState.miterLimit + \"[\" + strokeState.lineDash.join() + \"]\" :\r\n                \"\";\r\n            this.textKey_ = textState.font + textState.scale + (textState.textAlign || \"?\");\r\n            this.fillKey_ = fillState ?\r\n                (typeof fillState.fillStyle === \"string\" ? fillState.fillStyle : (\"|\" + ol.getUid(fillState.fillStyle))) :\r\n                \"\";\r\n            this.label = textStyle.label;\r\n            this.labelPosition = textStyle.labelPosition;\r\n        }\r\n    };\r\n    TextReplayCustom.prototype.drawTextCustom = function (geometry, feature) {\r\n        var fillState = this.textFillState_;\r\n        var strokeState = this.textStrokeState_;\r\n        var textState = this.textState_;\r\n        var geometryType = geometry.getType();\r\n        if (this.text_ === \"\" || !textState || (!fillState && !strokeState)) {\r\n            return;\r\n        }\r\n        if (this.labelPosition === undefined) {\r\n            return;\r\n        }\r\n        if ((geometryType === ol.geom.GeometryType.LINE_STRING || geometryType === ol.geom.GeometryType.MULTI_LINE_STRING) && !this.label) {\r\n            var begin_1 = this.coordinates.length;\r\n            var geometryType_1 = geometry.getType();\r\n            var flatCoordinates_1 = this.labelPosition;\r\n            var end_1 = 2;\r\n            var stride_1 = 2;\r\n            var i = void 0, ii = void 0;\r\n            // if (!ol.extent.intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\r\n            //     return;\r\n            // }\r\n            var ends = void 0;\r\n            // flatCoordinates = geometry.getFlatCoordinates();\r\n            stride_1 = geometry.getStride();\r\n            if (geometryType_1 === ol.geom.GeometryType.LINE_STRING) {\r\n                ends = [flatCoordinates_1.length];\r\n            }\r\n            else if (geometryType_1 === ol.geom.GeometryType.MULTI_LINE_STRING) {\r\n                ends = geometry.getEnds();\r\n            }\r\n            else if (geometryType_1 === ol.geom.GeometryType.POLYGON) {\r\n                ends = geometry.getEnds().slice(0, 1);\r\n            }\r\n            else if (geometryType_1 === ol.geom.GeometryType.MULTI_POLYGON) {\r\n                var endss = geometry.getEndss();\r\n                ends = [];\r\n                for (i = 0, ii = endss.length; i < ii; ++i) {\r\n                    ends.push(endss[i][0]);\r\n                }\r\n            }\r\n            this.beginGeometry(geometry, feature);\r\n            var textAlign = textState.textAlign;\r\n            var flatOffset = 0;\r\n            var flatEnd = void 0;\r\n            for (var o = 0, oo = ends.length; o < oo; ++o) {\r\n                if (textAlign === undefined) {\r\n                    var range = ol.geom.flat.straightchunk.lineString(textState.maxAngle, flatCoordinates_1, flatOffset, ends[o], stride_1);\r\n                    flatOffset = range[0];\r\n                    flatEnd = range[1];\r\n                }\r\n                else {\r\n                    flatEnd = ends[o];\r\n                }\r\n                for (i = flatOffset; i < flatEnd; i += stride_1) {\r\n                    this.coordinates.push(flatCoordinates_1[i], flatCoordinates_1[i + 1]);\r\n                }\r\n                end_1 = this.coordinates.length;\r\n                flatOffset = ends[o];\r\n                this.drawChars_(begin_1, end_1, this.declutterGroup_);\r\n                begin_1 = end_1;\r\n            }\r\n            this.endGeometry(geometry, feature);\r\n            return;\r\n        }\r\n        // if (this.label === undefined) { return; }\r\n        var begin = this.coordinates.length;\r\n        var flatCoordinates = this.labelPosition;\r\n        var end = 2;\r\n        var stride = 2;\r\n        var label = this.label;\r\n        if (geometry.getType() === ol.geom.GeometryType.POLYGON) {\r\n            stride = 3;\r\n        }\r\n        // let begin = this.coordinates.length;\r\n        // let geometryType = geometry.getType();\r\n        // let flatCoordinates = null;\r\n        // let end = 2;\r\n        // let stride = 2;\r\n        // let i, ii;\r\n        // if (textState.placement === (<any>ol.style).TextPlacement.LINE) {\r\n        //     if (!ol.extent.intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\r\n        //         return;\r\n        //     }\r\n        //     let ends;\r\n        //     flatCoordinates = geometry.getFlatCoordinates();\r\n        //     stride = geometry.getStride();\r\n        //     if (geometryType === (<any>ol.geom).GeometryType.LINE_STRING) {\r\n        //         ends = [flatCoordinates.length];\r\n        //     } else if (geometryType === (<any>ol.geom).GeometryType.MULTI_LINE_STRING) {\r\n        //         ends = geometry.getEnds();\r\n        //     } else if (geometryType === (<any>ol.geom).GeometryType.POLYGON) {\r\n        //         ends = geometry.getEnds().slice(0, 1);\r\n        //     } else if (geometryType === (<any>ol.geom).GeometryType.MULTI_POLYGON) {\r\n        //         let endss = geometry.getEndss();\r\n        //         ends = [];\r\n        //         for (i = 0, ii = endss.length; i < ii; ++i) {\r\n        //             ends.push(endss[i][0]);\r\n        //         }\r\n        //     }\r\n        //     this.beginGeometry(geometry, feature);\r\n        //     let textAlign = textState.textAlign;\r\n        //     let flatOffset = 0;\r\n        //     let flatEnd;\r\n        //     for (let o = 0, oo = ends.length; o < oo; ++o) {\r\n        //         if (textAlign === undefined) {\r\n        //             let range = (<any>ol.geom).flat.straightchunk.lineString(\r\n        //                 textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\r\n        //             flatOffset = range[0];\r\n        //             flatEnd = range[1];\r\n        //         } else {\r\n        //             flatEnd = ends[o];\r\n        //         }\r\n        //         for (i = flatOffset; i < flatEnd; i += stride) {\r\n        //             this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\r\n        //         }\r\n        //         end = this.coordinates.length;\r\n        //         flatOffset = ends[o];\r\n        //         this.drawChars_(begin, end, this.declutterGroup_);\r\n        //         begin = end;\r\n        //     }\r\n        //     this.endGeometry(geometry, feature);\r\n        // } else {\r\n        //     let label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);\r\n        //     let width = label.width / this.pixelRatio;\r\n        //     let Constructor = this.BATCH_CONSTRUCTORS_CUSTOM[geometryType];\r\n        //     let textLabelingStrategy = new Constructor();\r\n        //     switch (geometryType) {\r\n        //         case (<any>ol.geom).GeometryType.POINT:\r\n        //         case (<any>ol.geom).GeometryType.MULTI_POINT:\r\n        //             flatCoordinates = geometry.getFlatCoordinates();\r\n        //             end = flatCoordinates.length;\r\n        //             break;\r\n        //         case (<any>ol.geom).GeometryType.LINE_STRING:\r\n        //             flatCoordinates = /** @type {ol.geom.LineString} */ (geometry).getFlatMidpoint();\r\n        //             if (!textLabelingStrategy.MarkLocation(flatCoordinates, label, this.resolution)) {\r\n        //                 return;\r\n        //             }\r\n        //             break;\r\n        //         case (<any>ol.geom).GeometryType.CIRCLE:\r\n        //             flatCoordinates = /** @type {ol.geom.Circle} */ (geometry).getCenter();\r\n        //             break;\r\n        //         case (<any>ol.geom).GeometryType.MULTI_LINE_STRING:\r\n        //             flatCoordinates = /** @type {ol.geom.MultiLineString} */ (geometry).getFlatMidpoints();\r\n        //             end = flatCoordinates.length;\r\n        //             break;\r\n        //         case (<any>ol.geom).GeometryType.POLYGON:\r\n        //             flatCoordinates = /** @type {ol.geom.Polygon} */ (geometry).getFlatInteriorPoint();\r\n        //             if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {\r\n        //                 return;\r\n        //             }\r\n        //             // if (!textLabelingStrategy.MarkLocation(flatCoordinates, label, this.resolution)) {\r\n        //             //     return;\r\n        //             // }\r\n        //             stride = 3;\r\n        //             break;\r\n        //         case (<any>ol.geom).GeometryType.MULTI_POLYGON:\r\n        //             let interiorPoints = /** @type {ol.geom.MultiPolygon} */ (geometry).getFlatInteriorPoints();\r\n        //             flatCoordinates = [];\r\n        //             for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {\r\n        //                 if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {\r\n        //                     flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\r\n        //                 }\r\n        //             }\r\n        //             end = flatCoordinates.length;\r\n        //             if (end === 0) {\r\n        //                 return;\r\n        //             }\r\n        //             break;\r\n        //         default:\r\n        //     }\r\n        end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);\r\n        this.beginGeometry(geometry, feature);\r\n        if (textState.backgroundFill || textState.backgroundStroke) {\r\n            this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\r\n            this.updateFillStyle(this.state, this.applyFill, geometry);\r\n            this.updateStrokeStyle(this.state, this.applyStroke);\r\n        }\r\n        this.drawTextImage_(label, begin, end);\r\n        this.endGeometry(geometry, feature);\r\n        // }\r\n    };\r\n    return TextReplayCustom;\r\n}(ol.render.canvas.TextReplay));\r\n\r\n\n\n//# sourceURL=webpack:///./src/render/textReplayCustom.ts?");

/***/ }),

/***/ "./src/source/geoVectorTileSource.ts":
/*!*******************************************!*\
  !*** ./src/source/geoVectorTileSource.ts ***!
  \*******************************************/
/*! exports provided: GeoVectorTileSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoVectorTileSource\", function() { return GeoVectorTileSource; });\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar GeoVectorTileSource = /** @class */ (function (_super) {\r\n    __extends(GeoVectorTileSource, _super);\r\n    function GeoVectorTileSource(options) {\r\n        var _this = _super.call(this, options) || this;\r\n        _this.maxDataZoom = options.maxDataZoom;\r\n        if (options[\"tileUrlFunction\"] === undefined) {\r\n            _this.setTileUrlFunction(_this.getGeoTileUrlFunction());\r\n        }\r\n        _this.clientId = options.clientId;\r\n        _this.clientSecret = options.clientSecret;\r\n        _this.geoFormat = options.format;\r\n        _this.tileLoadFunction = _this.vectorTileLoadFunction.bind(_this);\r\n        _this.isMultithread = options[\"multithread\"] === undefined ? true : options[\"multithread\"];\r\n        return _this;\r\n    }\r\n    GeoVectorTileSource.prototype.getGeoFormat = function () {\r\n        return this.geoFormat;\r\n    };\r\n    GeoVectorTileSource.prototype.getGeoTileUrlFunction = function () {\r\n        var zRegEx = /\\{z\\}/g;\r\n        var xRegEx = /\\{x\\}/g;\r\n        var yRegEx = /\\{y\\}/g;\r\n        var dashYRegEx = /\\{-y\\}/g;\r\n        var urls = this.urls;\r\n        var tileGrid = this.tileGrid;\r\n        var maxDataZoom = this.maxDataZoom;\r\n        return function (tileCoord) {\r\n            if (!tileCoord) {\r\n                return undefined;\r\n            }\r\n            else {\r\n                var requestCoord_1 = [tileCoord[0], tileCoord[1], tileCoord[2]];\r\n                if (maxDataZoom && requestCoord_1[0] > maxDataZoom) {\r\n                    while (requestCoord_1[0] !== maxDataZoom) {\r\n                        requestCoord_1[0] -= 1;\r\n                        requestCoord_1[1] = Math.floor(requestCoord_1[1] / 2);\r\n                        requestCoord_1[2] = Math.floor(requestCoord_1[2] / 2);\r\n                    }\r\n                }\r\n                var h = ol.tilecoord.hash(tileCoord);\r\n                var index = ol.math.modulo(h, urls.length);\r\n                var template = urls[index];\r\n                return template.replace(zRegEx, requestCoord_1[0].toString())\r\n                    .replace(xRegEx, requestCoord_1[1].toString())\r\n                    .replace(yRegEx, function () {\r\n                    var y = -requestCoord_1[2] - 1;\r\n                    return y.toString();\r\n                })\r\n                    .replace(dashYRegEx, function () {\r\n                    var z = requestCoord_1[0];\r\n                    var range = tileGrid.getFullTileRange(z);\r\n                    ol.asserts.assert(range, 55); // The {-y} placeholder requires a tile grid with extent\r\n                    var y = range.getHeight() + requestCoord_1[2];\r\n                    return y.toString();\r\n                });\r\n            }\r\n        };\r\n    };\r\n    GeoVectorTileSource.prototype.vectorTileLoadFunction = function (tile, url) {\r\n        var loader = this.loadFeaturesXhr(url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile), this);\r\n        tile.setLoader(loader);\r\n    };\r\n    GeoVectorTileSource.prototype.getIDAndSecret = function (self) {\r\n        var xhr = new XMLHttpRequest();\r\n        var url = 'https://gisserver.thinkgeo.com/api/v1/auth/token';\r\n        var content = 'ApiKey=' + self.clientId + '&ApiSecret=' + self.clientSecret;\r\n        xhr.open(\"POST\", url, false);\r\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n        xhr.onload = function (event) {\r\n            if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {\r\n                var token = JSON.parse(xhr.responseText).data.access_token;\r\n                self.token = token;\r\n            }\r\n        }.bind(this);\r\n        xhr.onerror = function () {\r\n        }.bind(this);\r\n        xhr.send(content);\r\n    };\r\n    GeoVectorTileSource.prototype.loadFeaturesXhr = function (url, format, success, failure, self) {\r\n        return (function (extent, resolution, projection) {\r\n            var sourceTile = this;\r\n            var maxDataZoom = format.maxDataZoom;\r\n            var requestTileCoord = [this.tileCoord[0], this.tileCoord[1], this.tileCoord[2]];\r\n            if (maxDataZoom && requestTileCoord[0] > maxDataZoom) {\r\n                while (requestTileCoord[0] !== maxDataZoom) {\r\n                    requestTileCoord[0] -= 1;\r\n                    requestTileCoord[1] = Math.floor(requestTileCoord[1] / 2);\r\n                    requestTileCoord[2] = Math.floor(requestTileCoord[2] / 2);\r\n                }\r\n            }\r\n            this.requestTileCoord = requestTileCoord;\r\n            var tileGrid = self.getTileGrid();\r\n            var tileExtent = tileGrid.getTileCoordExtent(sourceTile.tileCoord);\r\n            var tileResolution = tileGrid.getResolution(sourceTile.tileCoord[0]);\r\n            var callback = function (tile, callbackFunction, sourceProjection, lastExtent) {\r\n                callbackFunction.call(tile, sourceProjection, lastExtent);\r\n            };\r\n            var hasRequested = false;\r\n            hasRequested = format.registerTileLoadEvent(this, success, failure, callback);\r\n            if (!hasRequested) {\r\n                // Client ID and Client Secret   \r\n                if (url.indexOf('apiKey') === -1 && self.clientId && self.clientSecret && !self.token) {\r\n                    self.getIDAndSecret(self);\r\n                }\r\n                if (format.isMultithread && format.workerManager) {\r\n                    var requestInfo = {\r\n                        url: typeof url === \"function\" ? url(extent, resolution, projection) : url,\r\n                        type: format.getType(),\r\n                        tileCoord: this.tileCoord,\r\n                        requestCoord: requestTileCoord,\r\n                        minimalist: format.minimalist,\r\n                        maxDataZoom: format.maxDataZoom,\r\n                        formatId: ol.getUid(format),\r\n                        layerName: format.layerName,\r\n                        token: self.token,\r\n                        vectorTileDataCahceSize: format[\"vectorTileDataCahceSize\"],\r\n                        tileRange: sourceTile.tileRange,\r\n                        tileCoordWithSourceCoord: sourceTile.tileCoordWithSourceCoord,\r\n                        vectorImageTileCoord: sourceTile.vectorImageTileCoord,\r\n                        tileExtent: tileExtent,\r\n                        tileResolution: tileResolution\r\n                    };\r\n                    var loadedCallback = function (data, methodInfo) {\r\n                        var requestKey = data.requestKey;\r\n                        var tileLoadEventInfos = format.registeredLoadEvents[requestKey];\r\n                        delete format.registeredLoadEvents[requestKey];\r\n                        for (var i = 0; i < tileLoadEventInfos.length; i++) {\r\n                            var loadEventInfo = tileLoadEventInfos[i];\r\n                            loadEventInfo.tile.workerId = methodInfo.workerId; // Currently, we just one web worker for one layer.\r\n                            // let tileKey = \"\" + loadEventInfo.tile.tileCoord[1] + \",\" + loadEventInfo.tile.tileCoord[2];\r\n                            // FIXME Eric\r\n                            if (data.status === \"cancel\") {\r\n                                loadEventInfo.tile.setState(ol.TileState.CANCEL);\r\n                            }\r\n                            else if (data.status === \"succeed\") {\r\n                                loadEventInfo.callback(loadEventInfo.tile, loadEventInfo.successFunction, format.readProjection());\r\n                            }\r\n                            else {\r\n                                loadEventInfo.callback(loadEventInfo.tile, loadEventInfo.failureFunction, format.readProjection());\r\n                            }\r\n                        }\r\n                    };\r\n                    format.workerManager.postMessage(this.tileCoord + ol.getUid(loadedCallback), \"request\", requestInfo, loadedCallback, undefined);\r\n                }\r\n                else {\r\n                    var tileCoord_1 = this.tileCoord;\r\n                    var tile_1 = this;\r\n                    var xhr_1 = new XMLHttpRequest();\r\n                    xhr_1.open(\"GET\", typeof url === \"function\" ? url(extent, resolution, projection) : url, true);\r\n                    if (self.token) {\r\n                        xhr_1.setRequestHeader('Authorization', 'Bearer ' + self.token);\r\n                    }\r\n                    if (format.getType() === ol.format.FormatType.ARRAY_BUFFER) {\r\n                        xhr_1.responseType = \"arraybuffer\";\r\n                    }\r\n                    xhr_1.onload = function (event) {\r\n                        if (!xhr_1.status || xhr_1.status >= 200 && xhr_1.status < 300) {\r\n                            var type = format.getType();\r\n                            /** @type {Document|Node|Object|string|undefined} */\r\n                            var source = void 0;\r\n                            if (type === ol.format.FormatType.JSON ||\r\n                                type === ol.format.FormatType.TEXT) {\r\n                                source = xhr_1.responseText;\r\n                            }\r\n                            else if (type === ol.format.FormatType.XML) {\r\n                                source = xhr_1.responseXML;\r\n                                if (!source) {\r\n                                    source = ol.xml.parse(xhr_1.responseText);\r\n                                }\r\n                            }\r\n                            else if (type === ol.format.FormatType.ARRAY_BUFFER) {\r\n                                source = /** @type {ArrayBuffer} */ (xhr_1.response);\r\n                            }\r\n                            if (source) {\r\n                                // ReadFeature\r\n                                var data = format.readFeaturesAndCreateInstructsNew(source, requestTileCoord, tileCoord_1);\r\n                                // Call Load Event\r\n                                var requestKey = tile_1.requestTileCoord.join(\",\") + \",\" + tile_1.tileCoord[0];\r\n                                var tileLoadEventInfos = format.registeredLoadEvents[requestKey];\r\n                                delete format.registeredLoadEvents[requestKey];\r\n                                for (var i = 0; i < tileLoadEventInfos.length; i++) {\r\n                                    var loadEventInfo = tileLoadEventInfos[i];\r\n                                    var tileKey = \"\" + loadEventInfo.tile.tileCoord[1] + \",\" + loadEventInfo.tile.tileCoord[2];\r\n                                    loadEventInfo.tile.featuresAndInstructs = { features: data[0], instructs: data[1][tileKey] };\r\n                                    loadEventInfo.callback(loadEventInfo.tile, loadEventInfo.successFunction, format.readProjection());\r\n                                }\r\n                            }\r\n                            else {\r\n                                failure.call(this);\r\n                            }\r\n                        }\r\n                        else {\r\n                            failure.call(this);\r\n                        }\r\n                    }.bind(this);\r\n                    xhr_1.onerror = function () {\r\n                        failure.call(this);\r\n                    }.bind(this);\r\n                    this[\"xhr\"] = xhr_1;\r\n                    format.source.dispatchEvent(new ol.VectorTile.Event(\"sendingTileRequest\", xhr_1));\r\n                    xhr_1.send();\r\n                }\r\n            }\r\n        });\r\n    };\r\n    return GeoVectorTileSource;\r\n}(ol.source.VectorTile));\r\n\r\n\n\n//# sourceURL=webpack:///./src/source/geoVectorTileSource.ts?");

/***/ }),

/***/ "./src/style/detectTextLabelingStrategy.ts":
/*!*************************************************!*\
  !*** ./src/style/detectTextLabelingStrategy.ts ***!
  \*************************************************/
/*! exports provided: DetectTextLabelingStrategy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DetectTextLabelingStrategy\", function() { return DetectTextLabelingStrategy; });\n/* harmony import */ var _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./textLabelingStrategy */ \"./src/style/textLabelingStrategy.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar DetectTextLabelingStrategy = /** @class */ (function (_super) {\r\n    __extends(DetectTextLabelingStrategy, _super);\r\n    function DetectTextLabelingStrategy() {\r\n        var _this = _super.call(this) || this;\r\n        _this.markLocationCore = _this.markLocationCoreCustom;\r\n        return _this;\r\n    }\r\n    DetectTextLabelingStrategy.prototype.markLocationCoreCustom = function (flatCoordinates, width, height, resolution, geometryType, textStyle, grid, frameState) {\r\n        switch (geometryType) {\r\n            case ol.geom.GeometryType.POINT:\r\n            case ol.geom.GeometryType.MULTI_POINT:\r\n            case ol.geom.GeometryType.CIRCLE:\r\n                if (this.isOverlapping(flatCoordinates, width, height, textStyle.margin, textStyle.minDistance, textStyle.minPadding, textStyle.spacing, grid, frameState)) {\r\n                    flatCoordinates = this.movePointLabel(flatCoordinates, width, height, resolution, textStyle, grid, frameState);\r\n                }\r\n                break;\r\n            case ol.geom.GeometryType.LINE_STRING:\r\n            case ol.geom.GeometryType.MULTI_LINE_STRING:\r\n            case ol.geom.GeometryType.POLYGON:\r\n            case ol.geom.GeometryType.MULTI_POLYGON:\r\n                if (this.isOverlapping(flatCoordinates, width, height, textStyle.margin, textStyle.minDistance, textStyle.minPadding, textStyle.spacing, grid, frameState)) {\r\n                    flatCoordinates = undefined;\r\n                }\r\n        }\r\n        return flatCoordinates;\r\n    };\r\n    DetectTextLabelingStrategy.prototype.movePointLabel = function (flatCoordinates, width, height, resolution, textStyle, grid, frameState) {\r\n        var gridSize = 50;\r\n        var distance = gridSize * resolution;\r\n        if (textStyle.placements) {\r\n            var placements = textStyle.placements.split(\",\");\r\n            for (var _i = 0, placements_1 = placements; _i < placements_1.length; _i++) {\r\n                var placement = placements_1[_i];\r\n                var newFlatCoordinates = this.getMovedPosition(flatCoordinates, placement, distance);\r\n                if (!this.isOverlapping(newFlatCoordinates, width, height, textStyle.margin, textStyle.minDistance, textStyle.minPadding, textStyle.spacing, grid, frameState)) {\r\n                    return newFlatCoordinates;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    DetectTextLabelingStrategy.prototype.getMovedPosition = function (flatCoordinates, placement, distance) {\r\n        var newFlatCoordinates;\r\n        switch (placement) {\r\n            case \"UR\":\r\n                newFlatCoordinates = this.moveToUR(flatCoordinates, distance);\r\n                break;\r\n            case \"U\":\r\n                newFlatCoordinates = this.moveToU(flatCoordinates, distance);\r\n                break;\r\n            case \"UL\":\r\n                newFlatCoordinates = this.moveToUL(flatCoordinates, distance);\r\n                break;\r\n            case \"B\":\r\n                newFlatCoordinates = this.moveToB(flatCoordinates, distance);\r\n                break;\r\n            case \"BR\":\r\n                newFlatCoordinates = this.moveToBR(flatCoordinates, distance);\r\n                break;\r\n            case \"BL\":\r\n                newFlatCoordinates = this.moveToBL(flatCoordinates, distance);\r\n                break;\r\n            case \"L\":\r\n                newFlatCoordinates = this.moveToL(flatCoordinates, distance);\r\n                break;\r\n            case \"R\":\r\n                newFlatCoordinates = this.moveToR(flatCoordinates, distance);\r\n                break;\r\n        }\r\n        return newFlatCoordinates;\r\n    };\r\n    DetectTextLabelingStrategy.prototype.moveToUR = function (flatCoordinates, distance) {\r\n        var newFlatCoordinates = new Array();\r\n        newFlatCoordinates.push(flatCoordinates[0] + distance);\r\n        newFlatCoordinates.push(flatCoordinates[1] + distance);\r\n        newFlatCoordinates.push(flatCoordinates[2]);\r\n        return newFlatCoordinates;\r\n    };\r\n    DetectTextLabelingStrategy.prototype.moveToU = function (flatCoordinates, distance) {\r\n        var newFlatCoordinates = new Array();\r\n        newFlatCoordinates.push(flatCoordinates[0]);\r\n        newFlatCoordinates.push(flatCoordinates[1] + distance);\r\n        newFlatCoordinates.push(flatCoordinates[2]);\r\n        return newFlatCoordinates;\r\n    };\r\n    DetectTextLabelingStrategy.prototype.moveToUL = function (flatCoordinates, distance) {\r\n        var newFlatCoordinates = new Array();\r\n        newFlatCoordinates.push(flatCoordinates[0] - distance);\r\n        newFlatCoordinates.push(flatCoordinates[1] + distance);\r\n        newFlatCoordinates.push(flatCoordinates[2]);\r\n        return newFlatCoordinates;\r\n    };\r\n    DetectTextLabelingStrategy.prototype.moveToB = function (flatCoordinates, distance) {\r\n        var newFlatCoordinates = new Array();\r\n        newFlatCoordinates.push(flatCoordinates[0]);\r\n        newFlatCoordinates.push(flatCoordinates[1] - distance);\r\n        newFlatCoordinates.push(flatCoordinates[2]);\r\n        return newFlatCoordinates;\r\n    };\r\n    DetectTextLabelingStrategy.prototype.moveToBR = function (flatCoordinates, distance) {\r\n        var newFlatCoordinates = new Array();\r\n        newFlatCoordinates.push(flatCoordinates[0] + distance);\r\n        newFlatCoordinates.push(flatCoordinates[1] - distance);\r\n        newFlatCoordinates.push(flatCoordinates[2]);\r\n        return newFlatCoordinates;\r\n    };\r\n    DetectTextLabelingStrategy.prototype.moveToBL = function (flatCoordinates, distance) {\r\n        var newFlatCoordinates = new Array();\r\n        newFlatCoordinates.push(flatCoordinates[0] - distance);\r\n        newFlatCoordinates.push(flatCoordinates[1] - distance);\r\n        newFlatCoordinates.push(flatCoordinates[2]);\r\n        return newFlatCoordinates;\r\n    };\r\n    DetectTextLabelingStrategy.prototype.moveToL = function (flatCoordinates, distance) {\r\n        var newFlatCoordinates = new Array();\r\n        newFlatCoordinates.push(flatCoordinates[0] - distance);\r\n        newFlatCoordinates.push(flatCoordinates[1]);\r\n        newFlatCoordinates.push(flatCoordinates[2]);\r\n        return newFlatCoordinates;\r\n    };\r\n    DetectTextLabelingStrategy.prototype.moveToR = function (flatCoordinates, distance) {\r\n        var newFlatCoordinates = new Array();\r\n        newFlatCoordinates.push(flatCoordinates[0] + distance);\r\n        newFlatCoordinates.push(flatCoordinates[1]);\r\n        newFlatCoordinates.push(flatCoordinates[2]);\r\n        return newFlatCoordinates;\r\n    };\r\n    return DetectTextLabelingStrategy;\r\n}(_textLabelingStrategy__WEBPACK_IMPORTED_MODULE_0__[\"TextLabelingStrategy\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/style/detectTextLabelingStrategy.ts?");

/***/ }),

/***/ "./src/style/geoAreaStyle.ts":
/*!***********************************!*\
  !*** ./src/style/geoAreaStyle.ts ***!
  \***********************************/
/*! exports provided: GeoAreaStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoAreaStyle\", function() { return GeoAreaStyle; });\n/* harmony import */ var _geoStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoStyle */ \"./src/style/geoStyle.ts\");\n/* harmony import */ var _style_geoBrush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style/geoBrush */ \"./src/style/geoBrush.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n\r\nvar GeoAreaStyle = /** @class */ (function (_super) {\r\n    __extends(GeoAreaStyle, _super);\r\n    function GeoAreaStyle(styleJson) {\r\n        var _this = _super.call(this, styleJson) || this;\r\n        if (styleJson) {\r\n            _this.brushType = styleJson[\"polygon-brush-type\"];\r\n            _this.rotateAngle = styleJson[\"polygon-rotate-angle\"];\r\n            _this.dx = styleJson[\"polygon-dx\"];\r\n            _this.dy = styleJson[\"polygon-dy\"];\r\n            _this.fill = styleJson[\"polygon-fill\"];\r\n            _this.foregroundFill = styleJson[\"polygon-foreground-fill\"];\r\n            _this.gamma = styleJson[\"polygon-gamma\"] ? styleJson[\"polygon-gamma\"] : true;\r\n            _this.geometryTransform = styleJson[\"polygon-geometry-transform\"];\r\n            _this.hatchStyle = styleJson[\"polygon-hatch-style\"];\r\n            _this.opacity = styleJson[\"polygon-opacity\"];\r\n            _this.outlineColor = styleJson[\"polygon-outline-color\"];\r\n            _this.outlineDashArray = styleJson[\"polygon-outline-dasharray\"];\r\n            _this.outlineOpacity = styleJson[\"polygon-outline-opacity\"];\r\n            _this.outlineWidth = styleJson[\"polygon-outline-width\"];\r\n            _this.linearGradient = styleJson[\"polygon-linear-gradient\"];\r\n            _this.radialGradient = styleJson[\"polygon-radial-gradient\"];\r\n            _this.textureFile = styleJson[\"polygon-texture-file\"];\r\n            _this.shadowColor = styleJson[\"polygon-shadow-color\"];\r\n            _this.shadowDx = styleJson[\"polygon-shadow-dx\"];\r\n            _this.shadowDy = styleJson[\"polygon-shadow-dy\"];\r\n        }\r\n        return _this;\r\n    }\r\n    GeoAreaStyle.prototype.initializeCore = function () {\r\n        this.brushType = this.brushType || \"solid\";\r\n        this.brushOptions = {\r\n            fillColor: this.fill,\r\n            fillOpacity: this.opacity,\r\n            linearGradient: this.linearGradient,\r\n            radialGradient: this.radialGradient,\r\n            textureFile: this.textureFile,\r\n            foregroundFill: this.foregroundFill,\r\n            hatchStyle: this.hatchStyle\r\n        };\r\n        if (this.geometryTransform) {\r\n            this.geometryTransformValue = this.getTransformValues(this.geometryTransform);\r\n        }\r\n        if (this.brushType === \"solid\" || this.brushType === \"hatch\") {\r\n            this.geoBrush = _style_geoBrush__WEBPACK_IMPORTED_MODULE_1__[\"GeoBrush\"].createBrushByType(this.brushType, null, null, this.brushOptions);\r\n        }\r\n        if (this.outlineColor) {\r\n            this.convertedOutlineColor = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.outlineColor, this.outlineOpacity);\r\n        }\r\n        if (this.outlineDashArray) {\r\n            this.convertedOutlineDashArray = this.outlineDashArray.split(\",\");\r\n        }\r\n        if (this.shadowColor) {\r\n            this.convertedShadowColor = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.shadowColor);\r\n        }\r\n        this.shadowTranslateValueByResolution = {};\r\n    };\r\n    GeoAreaStyle.prototype.getTransformValues = function (transform) {\r\n        // get transform values which look like transform(value1, value2)\r\n        var start = transform.indexOf(\"(\");\r\n        var end = transform.indexOf(\")\");\r\n        var valueString = transform.substring(start + 1, end);\r\n        var values = [];\r\n        if (valueString.includes(\",\")) {\r\n            values = valueString.split(\",\");\r\n        }\r\n        else {\r\n            values.push(valueString);\r\n        }\r\n        return values;\r\n    };\r\n    GeoAreaStyle.prototype.GetTransformedCoordinates = function (feature) {\r\n        var tmpFlatCoordinates = feature.getFlatCoordinates();\r\n        var tmpCoordinates = [[]];\r\n        var index = 0;\r\n        for (var i = 0; i < tmpFlatCoordinates.length; i += 2) {\r\n            tmpCoordinates[index] || (tmpCoordinates[index] = []);\r\n            tmpCoordinates[index].push([tmpFlatCoordinates[i], tmpFlatCoordinates[i + 1]]);\r\n            if (tmpCoordinates[index].length > 3 && tmpCoordinates[index][0][0] === tmpFlatCoordinates[i] && tmpCoordinates[index][0][1] === tmpFlatCoordinates[i + 1]) {\r\n                index++;\r\n            }\r\n        }\r\n        var geometry = new ol.geom.Polygon(tmpCoordinates, \"XY\");\r\n        if (this.geometryTransform.indexOf(\"translate\") === 0) {\r\n            geometry.translate(+this.geometryTransformValue[0].trim(), +this.geometryTransformValue[1].trim());\r\n        }\r\n        else if (this.geometryTransform.indexOf(\"scale\") === 0) {\r\n            geometry.scale(+this.geometryTransformValue[0].trim(), +this.geometryTransformValue[1].trim());\r\n        }\r\n        else if (this.geometryTransform.indexOf(\"rotate\") === 0) {\r\n            var center = ol.extent.getCenter(geometry.getExtent());\r\n            var angle = +this.geometryTransformValue[0].trim() * Math.PI / 180;\r\n            geometry.rotate(angle, center);\r\n        }\r\n        else if (this.geometryTransform.indexOf(\"skew\") === 0) {\r\n            this.skewGeometry(geometry, +this.geometryTransformValue[0].trim(), +this.geometryTransformValue[1].trim());\r\n        }\r\n        return geometry.flatCoordinates;\r\n    };\r\n    GeoAreaStyle.prototype.getConvertedStyleCore = function (feature, resolution, options) {\r\n        var length = 0;\r\n        this.styles = [];\r\n        if (this.fill || (this.outlineColor && this.outlineWidth) || this.linearGradient || this.radialGradient) {\r\n            if (this.geometryTransform) {\r\n                feature.flatCoordinates_ = this.GetTransformedCoordinates(feature);\r\n            }\r\n            if (this.shadowDx || this.shadowDy) {\r\n                var shadowTranslateValue = this.shadowTranslateValueByResolution[resolution];\r\n                if (shadowTranslateValue === undefined) {\r\n                    var tmpResolution = Math.round(resolution * 100000000) / 100000000;\r\n                    this.shadowTranslate = (\"translate(\" + (this.shadowDx ? this.shadowDx : 0) * tmpResolution + \",\" + (this.shadowDy ? this.shadowDy : 0) * tmpResolution + \")\");\r\n                    shadowTranslateValue = this.getTransformValues(this.shadowTranslate);\r\n                    this.shadowTranslateValueByResolution[resolution] = shadowTranslateValue;\r\n                }\r\n                var tmpFlatCoordinates = feature.getFlatCoordinates();\r\n                var newFlatCoordinates = ol.geom.flat.transform.translate(tmpFlatCoordinates, 0, tmpFlatCoordinates.length, 2, +shadowTranslateValue[0].trim(), +shadowTranslateValue[1].trim(), undefined);\r\n                var tmpCoordinates = [[]];\r\n                var index = 0;\r\n                for (var i = 0; i < newFlatCoordinates.length; i += 2) {\r\n                    tmpCoordinates[index] || (tmpCoordinates[index] = []);\r\n                    tmpCoordinates[index].push([newFlatCoordinates[i], newFlatCoordinates[i + 1]]);\r\n                    if (tmpCoordinates[index].length > 3 && tmpCoordinates[index][0][0] === newFlatCoordinates[i] && tmpCoordinates[index][0][1] === newFlatCoordinates[i + 1]) {\r\n                        index++;\r\n                    }\r\n                }\r\n                var geometry = new ol.geom.Polygon(tmpCoordinates, \"XY\");\r\n                GeoAreaStyle.areaShadowStyle.getFill().setColor(this.convertedShadowColor);\r\n                GeoAreaStyle.areaShadowStyle.setGeometry(geometry);\r\n                this.styles[length++] = GeoAreaStyle.areaShadowStyle;\r\n            }\r\n            if (this.fill) {\r\n                this.geoBrush = _style_geoBrush__WEBPACK_IMPORTED_MODULE_1__[\"GeoBrush\"].createBrushByType(this.brushType, feature, resolution, this.brushOptions);\r\n                GeoAreaStyle.areaStyle.getFill().setColor(this.geoBrush);\r\n            }\r\n            // stroke to handle outlineColor, outlineDashArray, outlineOpacity and outlineWidth\r\n            if (this.outlineColor || this.outlineDashArray || this.outlineWidth) {\r\n                var newStroke = new ol.style.Stroke();\r\n                newStroke.setColor(this.convertedOutlineColor);\r\n                newStroke.setLineDash(this.convertedOutlineDashArray);\r\n                newStroke.setWidth(this.outlineWidth);\r\n                GeoAreaStyle.areaStyle.setStroke(newStroke);\r\n            }\r\n            else {\r\n                GeoAreaStyle.areaStyle.setStroke(undefined);\r\n            }\r\n            GeoAreaStyle.areaStyle.setGeometry(feature);\r\n            this.styles[length++] = GeoAreaStyle.areaStyle;\r\n            if (this.gamma !== undefined && options.layer) {\r\n                var styleGamma_1 = this.gamma;\r\n                options.layer.on(\"precompose\", function (evt) {\r\n                    evt.context.imageSmoothingEnabled = styleGamma_1;\r\n                    evt.context.webkitImageSmoothingEnabled = styleGamma_1;\r\n                    evt.context.mozImageSmoothingEnabled = styleGamma_1;\r\n                    evt.context.msImageSmoothingEnabled = styleGamma_1;\r\n                });\r\n            }\r\n        }\r\n        return this.styles;\r\n    };\r\n    GeoAreaStyle.areaStyle = new ol.style.Style({\r\n        fill: new ol.style.Fill({}),\r\n        stroke: new ol.style.Stroke({})\r\n    });\r\n    GeoAreaStyle.areaShadowStyle = new ol.style.Style({\r\n        fill: new ol.style.Fill({}),\r\n    });\r\n    return GeoAreaStyle;\r\n}(_geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/style/geoAreaStyle.ts?");

/***/ }),

/***/ "./src/style/geoBrush.ts":
/*!*******************************!*\
  !*** ./src/style/geoBrush.ts ***!
  \*******************************/
/*! exports provided: GeoBrush */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoBrush\", function() { return GeoBrush; });\n/* harmony import */ var _geoStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoStyle */ \"./src/style/geoStyle.ts\");\n\r\nvar GeoBrush = /** @class */ (function () {\r\n    function GeoBrush() {\r\n    }\r\n    GeoBrush.createBrushByType = function (brushType, feature, resolution, brushTypeOptions) {\r\n        var geoBrushFunction = this.geoBrushFunctions[brushType];\r\n        if (typeof geoBrushFunction === \"function\") {\r\n            return geoBrushFunction(feature, resolution, brushTypeOptions);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    GeoBrush.registerGeoBrushFunction = function (key, geoBrushFunction) {\r\n        this.geoBrushFunctions[key] = geoBrushFunction;\r\n    };\r\n    GeoBrush.createGeoSolidBrush = function (feature, resolution, geoBrushOptions) {\r\n        if (geoBrushOptions.fillColor) {\r\n            return _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(geoBrushOptions.fillColor, geoBrushOptions.fillOpacity);\r\n        }\r\n    };\r\n    GeoBrush.createRadialGradientColor = function (feature, resolution, geoBrushOptions) {\r\n        var extent = feature.getExtent();\r\n        // TODO: try to create it when creating the GeoStyle.\r\n        var canvas = document.createElement(\"canvas\");\r\n        var context = canvas.getContext(\"2d\");\r\n        // TODO: check if there is a difference by srid.\r\n        var width = ol.extent.getWidth(extent) / resolution * ol.has.DEVICE_PIXEL_RATIO;\r\n        var height = ol.extent.getHeight(extent) / resolution * ol.has.DEVICE_PIXEL_RATIO;\r\n        // TODO: the (x0,y0) is the center of feature extent, optimize it\r\n        var x0 = width / 2;\r\n        var y0 = height / 2;\r\n        var r1 = x0;\r\n        var grd = context.createRadialGradient(x0, y0, 0, x0, y0, r1);\r\n        var gradientColors = geoBrushOptions.radialGradient.split(\",\");\r\n        for (var _i = 0, gradientColors_1 = gradientColors; _i < gradientColors_1.length; _i++) {\r\n            var gradientColor = gradientColors_1[_i];\r\n            gradientColor = gradientColor.trim();\r\n            var colorStop = gradientColor.substr(1, gradientColor.length - 2);\r\n            var cs = colorStop.split(\":\");\r\n            grd.addColorStop(Number(cs[0].trim()), _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(cs[1].trim(), geoBrushOptions.fillOpacity));\r\n        }\r\n        return grd;\r\n    };\r\n    GeoBrush.createLinearGradientColor = function (feature, resolution, geoBrushOptions) {\r\n        var extent = feature.getExtent();\r\n        var canvas = document.createElement(\"canvas\");\r\n        var context = canvas.getContext(\"2d\");\r\n        // TODO: the direction Angle by x0,y0,x1,y1. this.directionAngle\r\n        var grd = context.createLinearGradient(0, 0, ol.extent.getWidth(extent) / resolution * ol.has.DEVICE_PIXEL_RATIO, ol.extent.getHeight(extent) / resolution * ol.has.DEVICE_PIXEL_RATIO);\r\n        var gradientColors = geoBrushOptions.linearGradient.split(\",\");\r\n        for (var _i = 0, gradientColors_2 = gradientColors; _i < gradientColors_2.length; _i++) {\r\n            var gradientColor = gradientColors_2[_i];\r\n            gradientColor = gradientColor.trim();\r\n            var colorStop = gradientColor.substr(1, gradientColor.length - 2);\r\n            var cs = colorStop.split(\":\");\r\n            grd.addColorStop(Number(cs[0].trim()), _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(cs[1].trim(), geoBrushOptions.fillOpacity));\r\n        }\r\n        return grd;\r\n    };\r\n    GeoBrush.createImageCanvasPattern = function (feature, resolution, geoBrushOptions) {\r\n        var canvas = document.createElement(\"canvas\");\r\n        var context = canvas.getContext(\"2d\");\r\n        var imageElement = document.createElement(\"img\");\r\n        imageElement.src = geoBrushOptions.textureFile;\r\n        return context.createPattern(imageElement, \"repeat\");\r\n    };\r\n    GeoBrush.createPatternColor = function (feature, resolution, geoBrushOptions) {\r\n        var createPatternFunction = GeoBrush.geoPatternFunctions[geoBrushOptions.hatchStyle];\r\n        if (typeof createPatternFunction === \"function\") {\r\n            return createPatternFunction(geoBrushOptions.fillColor, geoBrushOptions.foregroundFill);\r\n        }\r\n        else {\r\n            return _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(geoBrushOptions.fillColor, geoBrushOptions.fillOpacity);\r\n        }\r\n    };\r\n    GeoBrush.getCrossPattern = function (fill, foregroundFill) {\r\n        var size = 6;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * 2 * ratio;\r\n        canvas.height = size * 2 * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // horizon line\r\n        context.fillStyle = foregroundFill;\r\n        context.fillRect(0, canvas.height / 2, canvas.width, 1);\r\n        // vertical line\r\n        context.fillRect(canvas.width / 2, 0, 1, canvas.height);\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getHorizontalPattern = function (fill, foregroundFill) {\r\n        var size = 6;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * 2 * ratio;\r\n        canvas.height = size * 2 * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // horizon line\r\n        context.fillStyle = foregroundFill;\r\n        context.fillRect(0, canvas.height / 2, canvas.width, 1);\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getVerticalPattern = function (fill, foregroundFill) {\r\n        var size = 6;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * 2 * ratio;\r\n        canvas.height = size * 2 * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // vertical line\r\n        context.fillStyle = foregroundFill;\r\n        context.fillRect(canvas.width / 2, 0, 1, canvas.height);\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getForwardDiagonalPattern = function (fill, foregroundFill) {\r\n        var size = 6;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * 2 * ratio;\r\n        canvas.height = size * 2 * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // vertical line\r\n        context.strokeStyle = foregroundFill;\r\n        context.moveTo(0, 0);\r\n        context.lineTo(canvas.width, canvas.height);\r\n        context.stroke();\r\n        // context.fillStyle = foregroundFill;\r\n        // context.moveTo(-1, -1);\r\n        // context.lineTo(1, -1);\r\n        // context.lineTo(canvas.width + 1, canvas.height);\r\n        // context.lineTo(canvas.width + 1, canvas.height + 1);\r\n        // context.lineTo(canvas.width, canvas.height + 1);\r\n        // context.lineTo(-1, 0);\r\n        // context.lineTo(-1, -1);\r\n        // context.closePath();\r\n        // context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getBackwardDiagonalPattern = function (fill, foregroundFill) {\r\n        var size = 6;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * 2 * ratio;\r\n        canvas.height = size * 2 * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // vertical line\r\n        context.strokeStyle = foregroundFill;\r\n        context.moveTo(canvas.width, 0);\r\n        context.lineTo(0, canvas.height);\r\n        context.stroke();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent05Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * (2 * 0.95 + 1) * ratio;\r\n        canvas.height = size * (2 * 0.95 + 1) * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.moveTo(canvas.width * 0.5, canvas.height * 0.45);\r\n        context.lineTo(canvas.width * 0.55, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, canvas.height * 0.55);\r\n        context.lineTo(canvas.width * 0.45, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, canvas.height * 0.45);\r\n        context.closePath();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent10Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * (2 * 0.9 + 1) * ratio;\r\n        canvas.height = size * (2 * 0.9 + 1) * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.moveTo(canvas.width * 0.5, canvas.height * 0.4);\r\n        context.lineTo(canvas.width * 0.6, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, canvas.height * 0.6);\r\n        context.lineTo(canvas.width * 0.4, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, canvas.height * 0.4);\r\n        context.closePath();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent20Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * (2 * 0.8 + 1) * ratio;\r\n        canvas.height = size * (2 * 0.8 + 1) * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.moveTo(canvas.width * 0.5, canvas.height * 0.3);\r\n        context.lineTo(canvas.width * 0.7, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, canvas.height * 0.7);\r\n        context.lineTo(canvas.width * 0.3, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, canvas.height * 0.3);\r\n        context.closePath();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent25Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * 0.4 * ratio;\r\n        canvas.height = size * 0.4 * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.strokeStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.ellipse(canvas.width * 0.25, canvas.height * 0.25, 0.8, 0.8, 0, 0, 2 * Math.PI);\r\n        // context.stroke();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent30Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * (2 * 0.7 + 1) * ratio;\r\n        canvas.height = size * (2 * 0.7 + 1) * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.moveTo(canvas.width * 0.5, canvas.height * 0.2);\r\n        context.lineTo(canvas.width * 0.8, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, canvas.height * 0.8);\r\n        context.lineTo(canvas.width * 0.2, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, canvas.height * 0.2);\r\n        context.closePath();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent40Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * (2 * 0.4 + 1) * ratio;\r\n        canvas.height = size * (2 * 0.4 + 1) * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.moveTo(canvas.width * 0.5, canvas.height * 0.1);\r\n        context.lineTo(canvas.width * 0.9, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, canvas.height * 0.9);\r\n        context.lineTo(canvas.width * 0.1, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, canvas.height * 0.1);\r\n        context.closePath();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent50Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * (2 * 0.5 + 1) * ratio;\r\n        canvas.height = size * (2 * 0.5 + 1) * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.moveTo(canvas.width * 0.5, 0);\r\n        context.lineTo(canvas.width, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, canvas.height);\r\n        context.lineTo(0, canvas.height * 0.5);\r\n        context.lineTo(canvas.width * 0.5, 0);\r\n        context.closePath();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent60Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * (2 * 0.4 + 1) * ratio;\r\n        canvas.height = size * (2 * 0.4 + 1) * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.moveTo(canvas.width * 0.4, 0);\r\n        context.lineTo(canvas.width * 0.6, 0);\r\n        context.lineTo(canvas.width, canvas.height * 0.4);\r\n        context.lineTo(canvas.width, canvas.height * 0.6);\r\n        context.lineTo(canvas.width * 0.6, canvas.height);\r\n        context.lineTo(canvas.width * 0.4, canvas.height);\r\n        context.lineTo(0, canvas.height * 0.6);\r\n        context.lineTo(0, canvas.height * 0.4);\r\n        context.lineTo(canvas.width * 0.4, 0);\r\n        context.closePath();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent70Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * (2 * 0.3 + 1) * ratio;\r\n        canvas.height = size * (2 * 0.3 + 1) * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.moveTo(canvas.width * 0.3, 0);\r\n        context.lineTo(canvas.width * 0.7, 0);\r\n        context.lineTo(canvas.width, canvas.height * 0.3);\r\n        context.lineTo(canvas.width, canvas.height * 0.7);\r\n        context.lineTo(canvas.width * 0.7, canvas.height);\r\n        context.lineTo(canvas.width * 0.3, canvas.height);\r\n        context.lineTo(0, canvas.height * 0.7);\r\n        context.lineTo(0, canvas.height * 0.3);\r\n        context.lineTo(canvas.width * 0.3, 0);\r\n        context.closePath();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent75Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * (2 * 0.25 + 1) * ratio;\r\n        canvas.height = size * (2 * 0.25 + 1) * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.moveTo(canvas.width * 0.25, 0);\r\n        context.lineTo(canvas.width * 0.75, 0);\r\n        context.lineTo(canvas.width, canvas.height * 0.25);\r\n        context.lineTo(canvas.width, canvas.height * 0.75);\r\n        context.lineTo(canvas.width * 0.75, canvas.height);\r\n        context.lineTo(canvas.width * 0.25, canvas.height);\r\n        context.lineTo(0, canvas.height * 0.75);\r\n        context.lineTo(0, canvas.height * 0.25);\r\n        context.lineTo(canvas.width * 0.25, 0);\r\n        context.closePath();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent80Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * 0.8 * ratio;\r\n        canvas.height = size * 0.8 * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.strokeStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.ellipse(canvas.width * 0.1, canvas.height * 0.1, 0.8, 0.8, 0, 0, 2 * Math.PI);\r\n        // context.stroke();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getPercent90Pattern = function (fill, foregroundFill) {\r\n        var size = 5;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * (2 * 0.1 + 1) * ratio;\r\n        canvas.height = size * (2 * 0.1 + 1) * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // percentage region\r\n        context.fillStyle = foregroundFill;\r\n        context.strokeStyle = foregroundFill;\r\n        context.beginPath();\r\n        context.ellipse(canvas.width * 0.1, canvas.height * 0.1, 0.4, 0.4, 0, 0, 2 * Math.PI);\r\n        // context.stroke();\r\n        context.fill();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getLargeGridPattern = function (fill, foregroundFill) {\r\n        var size = 6;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * 2 * ratio;\r\n        canvas.height = size * 2 * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // grid rect\r\n        context.strokeStyle = foregroundFill;\r\n        context.strokeRect(0, 0, canvas.width, canvas.height);\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.getDiagonalCrossPattern = function (fill, foregroundFill) {\r\n        var size = 6;\r\n        var ratio = ol.has.DEVICE_PIXEL_RATIO;\r\n        var canvas = document.createElement(\"canvas\");\r\n        canvas.width = size * 2 * ratio;\r\n        canvas.height = size * 2 * ratio;\r\n        var context = canvas.getContext(\"2d\");\r\n        context.fillStyle = fill;\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // left to right diagonal line\r\n        context.strokeStyle = foregroundFill;\r\n        context.moveTo(0, 0);\r\n        context.lineTo(canvas.width, canvas.height);\r\n        context.stroke();\r\n        // right to left diagonal line\r\n        context.strokeStyle = foregroundFill;\r\n        context.moveTo(canvas.width, 0);\r\n        context.lineTo(0, canvas.height);\r\n        context.stroke();\r\n        return context.createPattern(canvas, \"repeat\");\r\n    };\r\n    GeoBrush.geoBrushFunctions = {\r\n        solid: GeoBrush.createGeoSolidBrush,\r\n        radialgradient: GeoBrush.createRadialGradientColor,\r\n        lineargradient: GeoBrush.createLinearGradientColor,\r\n        hatch: GeoBrush.createPatternColor,\r\n        texture: GeoBrush.createImageCanvasPattern\r\n    };\r\n    GeoBrush.geoPatternFunctions = {\r\n        Cross: GeoBrush.getCrossPattern,\r\n        Horizontal: GeoBrush.getHorizontalPattern,\r\n        Vertical: GeoBrush.getVerticalPattern,\r\n        ForwardDiagonal: GeoBrush.getForwardDiagonalPattern,\r\n        BackwardDiagonal: GeoBrush.getBackwardDiagonalPattern,\r\n        LargeGrid: GeoBrush.getLargeGridPattern,\r\n        DiagonalCross: GeoBrush.getDiagonalCrossPattern,\r\n        Percent05: GeoBrush.getPercent05Pattern,\r\n        Percent10: GeoBrush.getPercent10Pattern,\r\n        Percent20: GeoBrush.getPercent20Pattern,\r\n        Percent25: GeoBrush.getPercent25Pattern,\r\n        Percent30: GeoBrush.getPercent30Pattern,\r\n        Percent40: GeoBrush.getPercent40Pattern,\r\n        Percent50: GeoBrush.getPercent50Pattern,\r\n        Percent60: GeoBrush.getPercent60Pattern,\r\n        Percent70: GeoBrush.getPercent70Pattern,\r\n        Percent75: GeoBrush.getPercent75Pattern,\r\n        Percent80: GeoBrush.getPercent80Pattern,\r\n        Percent90: GeoBrush.getPercent90Pattern,\r\n    };\r\n    return GeoBrush;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack:///./src/style/geoBrush.ts?");

/***/ }),

/***/ "./src/style/geoLineStyle.ts":
/*!***********************************!*\
  !*** ./src/style/geoLineStyle.ts ***!
  \***********************************/
/*! exports provided: GeoLineStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoLineStyle\", function() { return GeoLineStyle; });\n/* harmony import */ var _geoStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoStyle */ \"./src/style/geoStyle.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar GeoLineStyle = /** @class */ (function (_super) {\r\n    __extends(GeoLineStyle, _super);\r\n    function GeoLineStyle(styleJson) {\r\n        var _this = _super.call(this, styleJson) || this;\r\n        _this.geometryLineCaps = [\r\n            \"triangle\",\r\n            \"squareanchor\",\r\n            \"roundanchor\",\r\n            \"diamondanchor\",\r\n            \"arrowanchor\"\r\n        ];\r\n        _this.olLineCapsMap = {\r\n            butt: \"butt\",\r\n            flat: \"square\",\r\n            square: \"square\",\r\n            round: \"round\",\r\n            noanchor: \"square\",\r\n            anchormask: \"square\",\r\n            custom: \"square\"\r\n        };\r\n        _this.convertedDashArray = new Array();\r\n        _this.convertedInnerDashArray = new Array();\r\n        _this.convertedCenterDashArray = new Array();\r\n        _this.lineStroke = new ol.style.Stroke();\r\n        _this.lineStyle = new ol.style.Style({ stroke: _this.lineStroke });\r\n        _this.lineCapFill = new ol.style.Fill();\r\n        _this.lineCapStyle = new ol.style.Style({ fill: _this.lineCapFill });\r\n        _this.lineInnerStroke = new ol.style.Stroke();\r\n        _this.lineInnerStyle = new ol.style.Style({ stroke: _this.lineInnerStroke });\r\n        _this.lineCapInnerFill = new ol.style.Fill();\r\n        _this.lineCapInnerStyle = new ol.style.Style({\r\n            fill: _this.lineCapInnerFill\r\n        });\r\n        _this.lineCenterStroke = new ol.style.Stroke();\r\n        _this.lineCenterStyle = new ol.style.Style({\r\n            stroke: _this.lineCenterStroke\r\n        });\r\n        _this.lineCapCenterFill = new ol.style.Fill();\r\n        _this.lineCapCenterStyle = new ol.style.Style({\r\n            fill: _this.lineCapCenterFill\r\n        });\r\n        if (styleJson) {\r\n            _this.lineCap = styleJson[\"line-cap\"];\r\n            _this.color = styleJson[\"line-color\"];\r\n            _this.dashArray = styleJson[\"line-dasharray\"];\r\n            _this.gamma = styleJson[\"line-gamma\"];\r\n            _this.geometryTransform = styleJson[\"line-geometry-transform\"];\r\n            _this.lineJoin = styleJson[\"line-join\"];\r\n            _this.miterLimit = styleJson[\"line-miterlimit\"];\r\n            _this.offset = styleJson[\"line-offset\"];\r\n            _this.opacity = styleJson[\"line-opacity\"];\r\n            _this.width = styleJson[\"line-width\"];\r\n            _this.lineCapInner = styleJson[\"line-cap-inner\"];\r\n            _this.colorInner = styleJson[\"line-color-inner\"];\r\n            _this.dashArrayInner = styleJson[\"line-dasharray-inner\"];\r\n            _this.lineJoinInner = styleJson[\"line-join-inner\"];\r\n            _this.miterLimitInner = styleJson[\"line-miterlimit-inner\"];\r\n            _this.widthInner = styleJson[\"line-width-inner\"];\r\n            _this.lineCapCenter = styleJson[\"line-cap-center\"];\r\n            _this.colorCenter = styleJson[\"line-color-center\"];\r\n            _this.dashArrayCenter = styleJson[\"line-dasharray-center\"];\r\n            _this.lineJoinCenter = styleJson[\"line-join-center\"];\r\n            _this.miterLimitCenter = styleJson[\"line-miterlimit-center\"];\r\n            _this.widthCenter = styleJson[\"line-width-center\"];\r\n            _this.onewaySymbol = styleJson[\"line-oneway-symbol\"];\r\n        }\r\n        return _this;\r\n    }\r\n    GeoLineStyle.prototype.initializeCore = function () {\r\n        if (this.color) {\r\n            this.olColor = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.color, this.opacity);\r\n            this.lineStroke.setColor(this.olColor);\r\n            this.lineCapFill.setColor(this.olColor);\r\n        }\r\n        if (this.dashArray) {\r\n            var tmpArray = this.dashArray.split(\",\");\r\n            for (var _i = 0, tmpArray_1 = tmpArray; _i < tmpArray_1.length; _i++) {\r\n                var a = tmpArray_1[_i];\r\n                this.convertedDashArray.push(parseFloat(a));\r\n            }\r\n        }\r\n        // Drawing inner\r\n        if (this.colorInner) {\r\n            this.olInnerColor = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.colorInner, this.opacity);\r\n            this.lineInnerStroke.setColor(this.olInnerColor);\r\n            this.lineCapInnerFill.setColor(this.olInnerColor);\r\n        }\r\n        if (this.dashArrayInner) {\r\n            var tmpArray = this.dashArrayInner.split(\",\");\r\n            for (var _a = 0, tmpArray_2 = tmpArray; _a < tmpArray_2.length; _a++) {\r\n                var a = tmpArray_2[_a];\r\n                this.convertedInnerDashArray.push(parseFloat(a));\r\n            }\r\n        }\r\n        // Drawing center\r\n        if (this.colorCenter) {\r\n            this.olCenterColor = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.colorCenter, this.opacity);\r\n            this.lineCenterStroke.setColor(this.olCenterColor);\r\n            this.lineCapCenterFill.setColor(this.olCenterColor);\r\n        }\r\n        if (this.dashArrayCenter) {\r\n            var tmpArray = this.dashArrayCenter.split(\",\");\r\n            for (var _b = 0, tmpArray_3 = tmpArray; _b < tmpArray_3.length; _b++) {\r\n                var a = tmpArray_3[_b];\r\n                this.convertedCenterDashArray.push(parseFloat(a));\r\n            }\r\n        }\r\n        if (this.onewaySymbol) {\r\n            this.onewayIcon = new ol.style.Icon({\r\n                src: this.onewaySymbol,\r\n                imgSize: [18, 5],\r\n                anchor: [0.5, 0.5],\r\n                rotateWithView: true\r\n            });\r\n            this.onewayStyle = new ol.style.Style({\r\n                image: this.onewayIcon\r\n            });\r\n        }\r\n    };\r\n    GeoLineStyle.prototype.getTransformValues = function (transform) {\r\n        // get transform values which look like transform(value1, value2)\r\n        var start = transform.indexOf(\"(\");\r\n        var end = transform.indexOf(\")\");\r\n        var valueString = transform.substring(start + 1, end);\r\n        var values = [];\r\n        if (valueString.includes(\",\")) {\r\n            values = valueString.split(\",\");\r\n        }\r\n        else {\r\n            values.push(valueString);\r\n        }\r\n        return values;\r\n    };\r\n    GeoLineStyle.prototype.getConvertedStyleCore = function (feature, resolution, options) {\r\n        var _this = this;\r\n        var length = 0;\r\n        this.styles = [];\r\n        if (this.color && this.width) {\r\n            if (this.olLineCapsMap[this.lineCap]) {\r\n                this.lineStroke.setLineCap(this.olLineCapsMap[this.lineCap]);\r\n            }\r\n            if (this.color) {\r\n                this.lineStroke.setColor(this.olColor);\r\n                this.lineCapFill.setColor(this.olColor);\r\n            }\r\n            if (this.dashArray) {\r\n                this.lineStroke.setLineDash(this.convertedDashArray);\r\n            }\r\n            if (this.lineJoin) {\r\n                this.lineStroke.setLineJoin(this.lineJoin);\r\n            }\r\n            if (this.miterLimit !== 4) {\r\n                this.lineStroke.setMiterLimit(this.miterLimit);\r\n            }\r\n            if (this.width) {\r\n                this.lineStroke.setWidth(this.width);\r\n            }\r\n            // Set inner\r\n            if (this.colorInner) {\r\n                this.lineInnerStroke.setColor(this.olInnerColor);\r\n                this.lineCapInnerFill.setColor(this.olInnerColor);\r\n            }\r\n            if (this.dashArrayInner) {\r\n                this.lineInnerStroke.setLineDash(this.convertedInnerDashArray);\r\n            }\r\n            if (this.lineJoinInner) {\r\n                this.lineInnerStroke.setLineJoin(this.lineJoinInner);\r\n            }\r\n            if (this.miterLimitInner !== 4) {\r\n                this.lineInnerStroke.setMiterLimit(this.miterLimitInner);\r\n            }\r\n            if (this.widthInner) {\r\n                this.lineInnerStroke.setWidth(this.widthInner);\r\n            }\r\n            // Set center\r\n            if (this.colorCenter) {\r\n                this.lineCenterStroke.setColor(this.olCenterColor);\r\n                this.lineCapCenterFill.setColor(this.olCenterColor);\r\n                this.lineCenterStroke.setLineCap(\"butt\");\r\n            }\r\n            if (this.dashArrayCenter) {\r\n                this.lineCenterStroke.setLineDash(this.convertedCenterDashArray);\r\n            }\r\n            if (this.lineJoinCenter) {\r\n                this.lineCenterStroke.setLineJoin(this.lineJoinCenter);\r\n            }\r\n            if (this.miterLimitCenter !== 4) {\r\n                this.lineCenterStroke.setMiterLimit(this.miterLimitCenter);\r\n            }\r\n            if (this.widthCenter) {\r\n                this.lineCenterStroke.setWidth(this.widthCenter);\r\n            }\r\n            var geometryFunction = function (feature) {\r\n                if (_this.geometryTransform) {\r\n                    var geometry = _this.getGeometry(feature);\r\n                    if (_this.geometryTransform) {\r\n                        var values = _this.getTransformValues(_this.geometryTransform);\r\n                        if (_this.geometryTransform.indexOf(\"translate\") === 0) {\r\n                            geometry.translate(+values[0].trim(), +values[1].trim());\r\n                        }\r\n                        else if (_this.geometryTransform.indexOf(\"scale\") === 0) {\r\n                            geometry.scale(+values[0].trim(), +values[1].trim());\r\n                        }\r\n                        else if (_this.geometryTransform.indexOf(\"rotate\") === 0) {\r\n                            var center = ol.extent.getCenter(geometry.getExtent());\r\n                            var angle = +values[0].trim() * Math.PI / 180;\r\n                            geometry.rotate(angle, center);\r\n                        }\r\n                        else if (_this.geometryTransform.indexOf(\"skew\") === 0) {\r\n                            _this.skewGeometry(geometry, +values[0].trim(), +values[1].trim());\r\n                        }\r\n                    }\r\n                }\r\n                return feature.getGeometry();\r\n            };\r\n            this.lineStyle.setGeometry(geometryFunction);\r\n            this.styles[length++] = this.lineStyle;\r\n            if (this.gamma !== undefined && options.layer) {\r\n                var styleGamma_1 = this.gamma;\r\n                options.layer.on(\"precompose\", function (evt) {\r\n                    evt.context.imageSmoothingEnabled = styleGamma_1;\r\n                    evt.context.webkitImageSmoothingEnabled = styleGamma_1;\r\n                    evt.context.mozImageSmoothingEnabled = styleGamma_1;\r\n                    evt.context.msImageSmoothingEnabled = styleGamma_1;\r\n                });\r\n            }\r\n            if (this.geometryLineCaps.includes(this.lineCap)) {\r\n                var geometryFunction_1 = function (feature) {\r\n                    var geometry = _this.getGeometry(feature);\r\n                    return GeoLineStyle.createAnchoredGeometry(geometry, _this.lineCap, _this.width, resolution);\r\n                };\r\n                this.lineCapStyle.setGeometry(geometryFunction_1);\r\n                this.styles[length++] = this.lineCapStyle;\r\n            }\r\n            // Drawing inner\r\n            if (this.colorInner && this.widthInner) {\r\n                var geometryFunction_2 = function (feature) {\r\n                    var geometry = _this.getGeometry(feature);\r\n                    if (_this.geometryTransform) {\r\n                        var values = _this.getTransformValues(_this.geometryTransform);\r\n                        if (_this.geometryTransform.indexOf(\"translate\") === 0) {\r\n                            geometry.translate(+values[0].trim(), +values[1].trim());\r\n                        }\r\n                        else if (_this.geometryTransform.indexOf(\"scale\") === 0) {\r\n                            geometry.scale(+values[0].trim(), +values[1].trim());\r\n                        }\r\n                        else if (_this.geometryTransform.indexOf(\"rotate\") === 0) {\r\n                            var center = ol.extent.getCenter(geometry.getExtent());\r\n                            var angle = +values[0].trim() * Math.PI / 180;\r\n                            geometry.rotate(angle, center);\r\n                        }\r\n                        else if (_this.geometryTransform.indexOf(\"skew\") === 0) {\r\n                            _this.skewGeometry(geometry, +values[0].trim(), +values[1].trim());\r\n                        }\r\n                    }\r\n                    return feature.getGeometry();\r\n                };\r\n                this.lineInnerStyle.setGeometry(geometryFunction_2);\r\n                this.styles[length++] = this.lineInnerStyle;\r\n                if (this.geometryLineCaps.includes(this.lineCapInner)) {\r\n                    var geometryFunction_3 = function (feature) {\r\n                        var geometry = _this.getGeometry(feature);\r\n                        return GeoLineStyle.createAnchoredGeometry(geometry, _this.lineCapInner, _this.widthInner, resolution);\r\n                    };\r\n                    this.lineCapInnerStyle.setGeometry(geometryFunction_3);\r\n                    this.styles[length++] = this.lineCapInnerStyle;\r\n                }\r\n            }\r\n            // Drawing center\r\n            if (this.colorCenter && this.widthCenter) {\r\n                var geometryFunction_4 = function (feature) {\r\n                    var geometry = _this.getGeometry(feature);\r\n                    if (_this.geometryTransform) {\r\n                        var values = _this.getTransformValues(_this.geometryTransform);\r\n                        if (_this.geometryTransform.indexOf(\"translate\") === 0) {\r\n                            geometry.translate(+values[0].trim(), +values[1].trim());\r\n                        }\r\n                        else if (_this.geometryTransform.indexOf(\"scale\") === 0) {\r\n                            geometry.scale(+values[0].trim(), +values[1].trim());\r\n                        }\r\n                        else if (_this.geometryTransform.indexOf(\"rotate\") === 0) {\r\n                            var center = ol.extent.getCenter(geometry.getExtent());\r\n                            var angle = +values[0].trim() * Math.PI / 180;\r\n                            geometry.rotate(angle, center);\r\n                        }\r\n                        else if (_this.geometryTransform.indexOf(\"skew\") === 0) {\r\n                            _this.skewGeometry(geometry, +values[0].trim(), +values[1].trim());\r\n                        }\r\n                    }\r\n                    return feature.getGeometry();\r\n                };\r\n                this.lineCenterStyle.setGeometry(geometryFunction_4);\r\n                this.styles[length++] = this.lineCenterStyle;\r\n                if (this.geometryLineCaps.includes(this.lineCapCenter)) {\r\n                    var geometryFunction_5 = function (feature) {\r\n                        var geometry = _this.getGeometry(feature);\r\n                        return GeoLineStyle.createAnchoredGeometry(geometry, _this.lineCapCenter, _this.widthCenter, resolution);\r\n                    };\r\n                    this.lineCapCenterStyle.setGeometry(geometryFunction_5);\r\n                    this.styles[length++] = this.lineCapCenterStyle;\r\n                }\r\n            }\r\n        }\r\n        if (this.onewaySymbol) {\r\n            var flatCoordinates = feature.getFlatCoordinates();\r\n            var longest = 0;\r\n            var longestIndex = void 0;\r\n            for (var i = 0; i <= flatCoordinates.length - 4; i += 2) {\r\n                var dX = Math.abs(flatCoordinates[i] - flatCoordinates[i + 2]);\r\n                var dY = Math.abs(flatCoordinates[i + 1] - flatCoordinates[i + 3]);\r\n                var distance = dX + dY;\r\n                if (distance > longest) {\r\n                    longest = distance;\r\n                    longestIndex = i;\r\n                }\r\n            }\r\n            var start = [flatCoordinates[longestIndex], flatCoordinates[longestIndex + 1]];\r\n            var end = [flatCoordinates[longestIndex + 2], flatCoordinates[longestIndex + 3]];\r\n            var dx = end[0] - start[0];\r\n            var dy = end[1] - start[1];\r\n            var rotation = Math.atan2(dy, dx);\r\n            var centerPoint = [(start[0] + end[0]) * 0.5, (start[1] + end[1]) * 0.5];\r\n            var geometry = new ol.geom.Point(centerPoint, \"XY\");\r\n            this.onewayIcon.rotation_ = -rotation;\r\n            this.onewayStyle.setGeometry(geometry);\r\n            this.styles[length++] = this.onewayStyle;\r\n        }\r\n        return this.styles;\r\n    };\r\n    GeoLineStyle.prototype.getGeometry = function (feature) {\r\n        var tmpFlatCoordinates = feature.getFlatCoordinates();\r\n        var tmpCoordinates = [];\r\n        for (var i = 0; i < tmpFlatCoordinates.length; i += 2) {\r\n            tmpCoordinates.push([tmpFlatCoordinates[i], tmpFlatCoordinates[i + 1]]);\r\n        }\r\n        return new ol.geom.LineString(tmpCoordinates);\r\n    };\r\n    GeoLineStyle.createAnchoredGeometry = function (geometry, lineCap, lineWidth, resolution) {\r\n        var segments = GeoLineStyle.getTerminalSegments(geometry);\r\n        var linearRing = undefined;\r\n        var multiPolygon = new ol.geom.MultiPolygon([]);\r\n        for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\r\n            var segment = segments_1[_i];\r\n            var first = segment[0];\r\n            var last = segment[1];\r\n            var delta = lineWidth * resolution / 2;\r\n            var translateDelta = (lineWidth - 1) * resolution / 2;\r\n            switch (lineCap) {\r\n                case \"triangle\":\r\n                    linearRing = new ol.geom.LinearRing([\r\n                        [last[0], last[1] + delta],\r\n                        [last[0] + delta, last[1]],\r\n                        [last[0], last[1] - delta],\r\n                        [last[0], last[1] + delta]\r\n                    ]);\r\n                    break;\r\n                case \"squareanchor\":\r\n                    delta *= 1.5;\r\n                    linearRing = new ol.geom.LinearRing([\r\n                        [last[0] - delta, last[1] + delta],\r\n                        [last[0] + delta, last[1] + delta],\r\n                        [last[0] + delta, last[1] - delta],\r\n                        [last[0] - delta, last[1] - delta],\r\n                        [last[0] - delta, last[1] + delta]\r\n                    ]);\r\n                    break;\r\n                case \"roundanchor\":\r\n                    delta *= 2;\r\n                    var radiusDelta = Math.PI / 18;\r\n                    var coordinates = [];\r\n                    var radius = 0;\r\n                    for (var i = 0; i < 36; i++) {\r\n                        coordinates.push([\r\n                            Math.cos(radius) * delta + last[0],\r\n                            Math.sin(radius) * delta + last[1]\r\n                        ]);\r\n                        radius += radiusDelta;\r\n                    }\r\n                    coordinates.push(coordinates[0]);\r\n                    linearRing = new ol.geom.LinearRing(coordinates);\r\n                    break;\r\n                case \"diamondanchor\":\r\n                    delta *= 1.5;\r\n                    linearRing = new ol.geom.LinearRing([\r\n                        [last[0] - delta, last[1] + delta],\r\n                        [last[0] + delta, last[1] + delta],\r\n                        [last[0] + delta, last[1] - delta],\r\n                        [last[0] - delta, last[1] - delta],\r\n                        [last[0] - delta, last[1] + delta]\r\n                    ]);\r\n                    linearRing.rotate(Math.PI / 4, last);\r\n                    break;\r\n                case \"arrowanchor\":\r\n                    delta *= 2;\r\n                    linearRing = new ol.geom.LinearRing([\r\n                        [last[0], last[1] + delta],\r\n                        [last[0] + delta * Math.cos(Math.PI / 6) * 2, last[1]],\r\n                        [last[0], last[1] - delta],\r\n                        [last[0], last[1] + delta]\r\n                    ]);\r\n                    break;\r\n            }\r\n            if (first[0] === last[0]) {\r\n                if (first[1] > last[1]) {\r\n                    linearRing.rotate(-Math.PI / 2, last);\r\n                    linearRing.translate(0, -translateDelta);\r\n                }\r\n                else {\r\n                    linearRing.rotate(Math.PI / 2, last);\r\n                    linearRing.translate(0, translateDelta);\r\n                }\r\n            }\r\n            else if (first[1] === last[1]) {\r\n                if (last[0] < first[0]) {\r\n                    linearRing.rotate(Math.PI, last);\r\n                    linearRing.translate(-translateDelta, 0);\r\n                }\r\n                else {\r\n                    linearRing.translate(translateDelta, 0);\r\n                }\r\n            }\r\n            else {\r\n                var dx = last[0] - first[0];\r\n                var dy = last[1] - first[1];\r\n                var radians = Math.atan(dy / dx);\r\n                if (last[0] > first[0]) {\r\n                    linearRing.rotate(radians, last);\r\n                    linearRing.translate(Math.cos(radians) * translateDelta, Math.sin(radians) * translateDelta);\r\n                }\r\n                else {\r\n                    linearRing.rotate(radians + Math.PI, last);\r\n                    linearRing.translate(-Math.cos(radians) * translateDelta, -Math.sin(radians) * translateDelta);\r\n                }\r\n            }\r\n            var polygon = new ol.geom.Polygon([]);\r\n            polygon.appendLinearRing(linearRing);\r\n            multiPolygon.appendPolygon(polygon);\r\n        }\r\n        return multiPolygon;\r\n    };\r\n    GeoLineStyle.getTerminalSegments = function (geometry) {\r\n        var type = geometry.getType();\r\n        var results = [];\r\n        var geometryType = ol.geom.GeometryType;\r\n        switch (type) {\r\n            case geometryType.LINE_STRING:\r\n                var coords = geometry.getCoordinates();\r\n                var start = [coords[1], coords[0]];\r\n                var end = [coords[coords.length - 2], coords[coords.length - 1]];\r\n                results.push(start);\r\n                results.push(end);\r\n                break;\r\n            case geometryType.MULTI_LINE_STRING:\r\n                var lines = geometry.getLineStrings();\r\n                for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\r\n                    var line = lines_1[_i];\r\n                    Array.prototype.push.apply(results, GeoLineStyle.getTerminalSegments(line));\r\n                }\r\n                break;\r\n            case geometryType.GEOMETRY_COLLECTION:\r\n                var geometries = geometry.getGeometries();\r\n                for (var _a = 0, geometries_1 = geometries; _a < geometries_1.length; _a++) {\r\n                    var geom = geometries_1[_a];\r\n                    Array.prototype.push.apply(results, GeoLineStyle.getTerminalSegments(geom));\r\n                }\r\n                break;\r\n        }\r\n        return results;\r\n    };\r\n    return GeoLineStyle;\r\n}(_geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/style/geoLineStyle.ts?");

/***/ }),

/***/ "./src/style/geoPointStyle.ts":
/*!************************************!*\
  !*** ./src/style/geoPointStyle.ts ***!
  \************************************/
/*! exports provided: GeoPointStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoPointStyle\", function() { return GeoPointStyle; });\n/* harmony import */ var _geoStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoStyle */ \"./src/style/geoStyle.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar GeoPointStyle = /** @class */ (function (_super) {\r\n    __extends(GeoPointStyle, _super);\r\n    function GeoPointStyle(styleJson) {\r\n        var _this = _super.call(this, styleJson) || this;\r\n        if (styleJson) {\r\n            _this.glyph = styleJson[\"point-glyph\"];\r\n            _this.linearGradient = styleJson[\"point-linear-gradient\"];\r\n            _this.radialGradient = styleJson[\"point-radial-gradient\"];\r\n            _this.fill = styleJson[\"point-fill\"];\r\n            _this.glyphName = styleJson[\"point-glyph-name\"];\r\n            _this.glyphMaskColor = styleJson[\"point-glyph-mask-color\"];\r\n            _this.glyphMaskMargin = styleJson[\"point-glyph-mask-margin\"];\r\n            _this.glyphMaskOutlineColor = styleJson[\"point-glyph-mask-outline-color\"];\r\n            _this.glyphMaskOutlineWidth = styleJson[\"point-glyph-mask-outline-width\"];\r\n            _this.glyphMaskType = styleJson[\"point-glyph-mask-type\"];\r\n            _this.outlineColor = styleJson[\"point-outline-color\"];\r\n            _this.outlineWidth = styleJson[\"point-outline-width\"];\r\n            _this.size = styleJson[\"point-size\"];\r\n            _this.angle = styleJson[\"point-rotate-angle\"] ? styleJson[\"point-rotate-angle\"] : 0;\r\n            _this.dx = styleJson[\"point-dx\"];\r\n            _this.dy = styleJson[\"point-dy\"];\r\n            _this.pointFile = styleJson[\"point-file\"];\r\n            _this.opacity = styleJson[\"point-opacity\"];\r\n            _this.symbolType = styleJson[\"point-symbol-type\"];\r\n            _this.transform = styleJson[\"point-transform\"];\r\n            _this.pointType = styleJson[\"point-type\"];\r\n            if (_this.outlineColor) {\r\n                _this.convertedGlyphOutLineColor = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(_this.outlineColor, _this.opacity);\r\n            }\r\n            if (_this.fill) {\r\n                _this.convertedGlyphFill = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(_this.fill, _this.opacity);\r\n            }\r\n            if (_this.linearGradient) {\r\n                if (GeoPointStyle.linearGradientDictionary.hasOwnProperty(_this.linearGradient)) {\r\n                    _this.convertedGlyphFill = GeoPointStyle.linearGradientDictionary[_this.linearGradient];\r\n                }\r\n                else {\r\n                    _this.convertedGlyphFill = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toOLLinearGradient(_this.linearGradient, _this.opacity, _this.size);\r\n                    GeoPointStyle.linearGradientDictionary[_this.linearGradient] = _this.convertedGlyphFill;\r\n                }\r\n            }\r\n            if (_this.radialGradient) {\r\n                if (GeoPointStyle.radialGradientDictionary.hasOwnProperty(_this.radialGradient)) {\r\n                    _this.convertedGlyphFill = GeoPointStyle.radialGradientDictionary[_this.radialGradient];\r\n                }\r\n                else {\r\n                    _this.convertedGlyphFill = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toOLRadialGradient(_this.radialGradient, _this.opacity, _this.size);\r\n                    GeoPointStyle.radialGradientDictionary[_this.radialGradient] = _this.convertedGlyphFill;\r\n                }\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    GeoPointStyle.prototype.initializeCore = function () {\r\n        this.style = new ol.style.Style();\r\n        switch (this.pointType) {\r\n            case \"symbol\":\r\n                this.initSymbolStyle();\r\n                break;\r\n            case \"image\":\r\n                this.initBitmapStyle();\r\n                break;\r\n            case \"glyph\":\r\n                this.initGlyphStyle();\r\n            default:\r\n                break;\r\n        }\r\n        if (this.pointType === \"glyph\") {\r\n            if (this.glyph && this.glyphName) {\r\n                this.textStyle.label = this.getGlyphImage(this.textStyle);\r\n                this.style.setImage(null);\r\n                this.style.setText(this.textStyle);\r\n            }\r\n        }\r\n        else {\r\n            this.style.setImage(this.imageStyle);\r\n        }\r\n    };\r\n    GeoPointStyle.prototype.getConvertedStyleCore = function (feature, resolution, options) {\r\n        if (this.pointType === \"glyph\") {\r\n            if (this.glyph && this.glyphName) {\r\n                this.textStyle.labelPosition = feature.getFlatCoordinates();\r\n            }\r\n        }\r\n        var featureZindex = feature[\"tempTreeZindex\"];\r\n        if (featureZindex === undefined) {\r\n            featureZindex = 0;\r\n        }\r\n        this.style.setZIndex(featureZindex);\r\n        this.styles = [];\r\n        this.styles[0] = this.style;\r\n        return this.styles;\r\n    };\r\n    GeoPointStyle.prototype.getGlyphImage = function (textState) {\r\n        var font = textState.font_;\r\n        var strokeColor;\r\n        var outlineWidth = 0;\r\n        var textStrok = textState.getStroke();\r\n        if (textStrok) {\r\n            strokeColor = textStrok.getColor();\r\n            outlineWidth = textStrok.getWidth();\r\n        }\r\n        var scale = window.devicePixelRatio;\r\n        // here\r\n        var width = ol.render.canvas.TextReplay.measureTextWidths(font, [textState.text_], []) + outlineWidth * 2;\r\n        var height = ol.render.canvas.measureTextHeight(font) + outlineWidth * 2;\r\n        var tmpMaskMargin = (this.glyphMaskMargin ? this.glyphMaskMargin : \"0\").split(',');\r\n        var tmpMaskHeightMargin = 0;\r\n        var tmpMaskWidthMargin = 0;\r\n        switch (tmpMaskMargin.length) {\r\n            case 1:\r\n                tmpMaskHeightMargin = parseInt(tmpMaskMargin[0]) * 2;\r\n                tmpMaskWidthMargin = parseInt(tmpMaskMargin[0]) * 2;\r\n                break;\r\n            case 2:\r\n                tmpMaskHeightMargin = parseInt(tmpMaskMargin[0]) * 2;\r\n                tmpMaskWidthMargin = parseInt(tmpMaskMargin[1]) * 2;\r\n                break;\r\n            case 3:\r\n                tmpMaskHeightMargin = parseInt(tmpMaskMargin[0]) + parseInt(tmpMaskMargin[2]);\r\n                tmpMaskWidthMargin = parseInt(tmpMaskMargin[1]) * 2;\r\n                break;\r\n            case 4:\r\n                tmpMaskHeightMargin = parseInt(tmpMaskMargin[0]) + parseInt(tmpMaskMargin[2]);\r\n                tmpMaskWidthMargin = parseInt(tmpMaskMargin[1]) + parseInt(tmpMaskMargin[3]);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        var tmpMaskOutlineWidth = (this.glyphMaskOutlineWidth ? this.glyphMaskOutlineWidth : 0) * 2;\r\n        var renderWidth = width + tmpMaskWidthMargin;\r\n        var renderHeight = height + tmpMaskWidthMargin;\r\n        var canvasWidth = width + tmpMaskWidthMargin + tmpMaskOutlineWidth;\r\n        var canvasHeight = height + tmpMaskHeightMargin + tmpMaskOutlineWidth;\r\n        var context = ol.dom.createCanvasContext2D(canvasWidth * scale, canvasHeight * scale);\r\n        if (scale !== 1) {\r\n            context.scale(scale, scale);\r\n        }\r\n        this.drawMask(context, 0, 0, renderWidth, renderHeight);\r\n        context.font = font;\r\n        context.textBaseline = \"middle\";\r\n        context.textAlign = \"center\";\r\n        if (textStrok) {\r\n            if (strokeColor && outlineWidth > 0) {\r\n                context.strokeStyle = strokeColor;\r\n                context.lineWidth = outlineWidth * (ol.has.SAFARI ? scale : 1);\r\n                context.strokeText(textState.text_, canvasWidth / 2, canvasHeight / 2);\r\n            }\r\n        }\r\n        var textFill = textState.getFill();\r\n        if (textFill) {\r\n            var color = textFill.getColor();\r\n            if (color) {\r\n                context.fillStyle = color;\r\n                context.fillText(textState.text_, canvasWidth / 2, canvasHeight / 2);\r\n            }\r\n        }\r\n        return context.canvas;\r\n    };\r\n    GeoPointStyle.prototype.drawMask = function (context, x, y, width, height) {\r\n        var fill = undefined;\r\n        var stroke = undefined;\r\n        if (this.glyphMaskColor) {\r\n            fill = new ol.style.Fill();\r\n            fill.setColor(_geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.glyphMaskColor, this.opacity ? this.opacity : 1));\r\n        }\r\n        if (this.glyphMaskOutlineColor && this.glyphMaskOutlineWidth) {\r\n            stroke = new ol.style.Stroke();\r\n            if (this.glyphMaskOutlineColor) {\r\n                stroke.setColor(_geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.glyphMaskOutlineColor, this.opacity ? this.opacity : 1));\r\n            }\r\n            if (this.glyphMaskOutlineWidth) {\r\n                stroke.setWidth(this.glyphMaskOutlineWidth ? this.glyphMaskOutlineWidth : 0);\r\n            }\r\n        }\r\n        switch (this.glyphMaskType) {\r\n            case \"default\":\r\n            case \"Default\":\r\n            case \"rectangle\":\r\n            case \"Rectangle\":\r\n                this.drawRectangle(context, x, y, width, height, fill, stroke);\r\n                break;\r\n            case \"roundedCorners\":\r\n            case \"RoundedCorners\":\r\n                this.drawRoundRectangle(context, x, y, width, height, fill, stroke);\r\n                break;\r\n            case \"roundedEnds\":\r\n            case \"RoundedEnds\":\r\n                this.drawRoundedEnds(context, x, y, width, height, fill, stroke);\r\n                break;\r\n            case \"circle\":\r\n            case \"Circle\":\r\n                this.drawCircle(context, x, y, width, height, fill, stroke);\r\n                break;\r\n        }\r\n    };\r\n    GeoPointStyle.prototype.drawRectangle = function (context, x, y, width, height, fill, stroke) {\r\n        if (fill) {\r\n            context.fillStyle = fill.getColor();\r\n            context.fillRect(x, y, width, height);\r\n        }\r\n        if (stroke) {\r\n            context.lineWidth = stroke.getWidth();\r\n            context.strokeStyle = stroke.getColor();\r\n            context.strokeRect(x + stroke.getWidth(), y + stroke.getWidth(), width, height);\r\n        }\r\n    };\r\n    GeoPointStyle.prototype.drawRoundRectangle = function (context, x, y, width, height, fill, stroke) {\r\n        var radius = (width < height ? width : height) * 0.3;\r\n        // width *= 0.9;\r\n        // height *= 0.8;\r\n        if (stroke) {\r\n            x = x + (stroke.getWidth() ? stroke.getWidth() : 0);\r\n            y = y + (stroke.getWidth() ? stroke.getWidth() : 0);\r\n        }\r\n        context.beginPath();\r\n        context.moveTo(x + radius, y);\r\n        context.lineTo(x + width - radius, y);\r\n        context.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n        context.lineTo(x + width, y + height - radius);\r\n        context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\r\n        context.lineTo(x + radius, y + height);\r\n        context.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n        context.lineTo(x, y + radius);\r\n        context.quadraticCurveTo(x, y, x + radius, y);\r\n        context.closePath();\r\n        if (fill) {\r\n            context.fillStyle = fill.getColor();\r\n            context.fill();\r\n        }\r\n        if (stroke) {\r\n            context.lineWidth = stroke.getWidth();\r\n            context.strokeStyle = stroke.getColor();\r\n            context.stroke();\r\n        }\r\n    };\r\n    GeoPointStyle.prototype.drawRoundedEnds = function (context, x, y, width, height, fill, stroke) {\r\n        var radius = (width < height ? width : height) * 0.2;\r\n        // width *= 0.9;\r\n        // height *= 0.8;\r\n        if (stroke) {\r\n            x = x + (stroke.getWidth() ? stroke.getWidth() : 0);\r\n            y = y + (stroke.getWidth() ? stroke.getWidth() : 0);\r\n        }\r\n        context.beginPath();\r\n        context.moveTo(x + radius, y);\r\n        context.lineTo(x + width - radius, y);\r\n        context.quadraticCurveTo(x + width, y + height * 0.5, x + width - radius, y + height);\r\n        context.lineTo(x + radius, y + height);\r\n        context.quadraticCurveTo(x, y + height * 0.5, x + radius, y);\r\n        context.closePath();\r\n        if (fill) {\r\n            context.fillStyle = fill.getColor();\r\n            context.fill();\r\n        }\r\n        if (stroke) {\r\n            context.lineWidth = stroke.getWidth();\r\n            context.strokeStyle = stroke.getColor();\r\n            context.stroke();\r\n        }\r\n    };\r\n    GeoPointStyle.prototype.drawCircle = function (context, x, y, width, height, fill, stroke) {\r\n        var radius = (width < height ? width : height) * 0.5;\r\n        // width *= 0.9;\r\n        // height *= 0.8;\r\n        if (stroke) {\r\n            x = x + (stroke.getWidth() ? stroke.getWidth() : 0);\r\n            y = y + (stroke.getWidth() ? stroke.getWidth() : 0);\r\n        }\r\n        context.beginPath();\r\n        context.arc(x + width * 0.5, y + height * 0.5, radius, 0, 2 * Math.PI, false);\r\n        context.closePath();\r\n        if (fill) {\r\n            context.fillStyle = fill.getColor();\r\n            context.fill();\r\n        }\r\n        if (stroke) {\r\n            context.lineWidth = stroke.getWidth();\r\n            context.strokeStyle = stroke.getColor();\r\n            context.stroke();\r\n        }\r\n    };\r\n    GeoPointStyle.prototype.initSymbolStyle = function () {\r\n        var radius = this.size / 2;\r\n        switch (this.symbolType) {\r\n            case \"circle\":\r\n                this.imageStyle = new ol.style.Circle({\r\n                    fill: this.convertedGlyphFill !== undefined ? new ol.style.Fill(({\r\n                        color: this.convertedGlyphFill\r\n                    })) : undefined,\r\n                    stroke: this.convertedGlyphOutLineColor !== undefined && this.outlineWidth > 0 ? new ol.style.Stroke(({\r\n                        color: this.convertedGlyphOutLineColor,\r\n                        width: this.outlineWidth\r\n                    })) : undefined,\r\n                    radius: radius\r\n                });\r\n                break;\r\n            case \"square\":\r\n                this.imageStyle = new ol.style.RegularShape({\r\n                    fill: this.convertedGlyphFill !== undefined ? new ol.style.Fill(({\r\n                        color: this.convertedGlyphFill\r\n                    })) : undefined,\r\n                    stroke: this.convertedGlyphOutLineColor !== undefined && this.outlineWidth > 0 ? new ol.style.Stroke(({\r\n                        color: this.convertedGlyphOutLineColor,\r\n                        width: this.outlineWidth\r\n                    })) : undefined,\r\n                    points: 4,\r\n                    radius: radius,\r\n                    angle: Math.PI / 4 + this.angle\r\n                });\r\n                break;\r\n            case \"triangle\":\r\n                this.imageStyle = new ol.style.RegularShape({\r\n                    fill: this.convertedGlyphFill !== undefined ? new ol.style.Fill(({\r\n                        color: this.convertedGlyphFill\r\n                    })) : undefined,\r\n                    stroke: this.convertedGlyphOutLineColor !== undefined && this.outlineWidth > 0 ? new ol.style.Stroke(({\r\n                        color: this.convertedGlyphOutLineColor,\r\n                        width: this.outlineWidth\r\n                    })) : undefined,\r\n                    points: 3,\r\n                    radius: radius,\r\n                    angle: this.angle\r\n                });\r\n                break;\r\n            case \"cross\":\r\n                this.imageStyle = new ol.style.RegularShape({\r\n                    fill: this.convertedGlyphFill !== undefined ? new ol.style.Fill(({\r\n                        color: this.convertedGlyphFill\r\n                    })) : undefined,\r\n                    stroke: this.convertedGlyphOutLineColor !== undefined && this.outlineWidth > 0 ? new ol.style.Stroke(({\r\n                        color: this.convertedGlyphOutLineColor,\r\n                        width: this.outlineWidth\r\n                    })) : undefined,\r\n                    points: 4,\r\n                    radius: radius,\r\n                    radius2: 0,\r\n                    angle: this.angle\r\n                });\r\n                break;\r\n            case \"diamond\":\r\n                break;\r\n            case \"diamond2\":\r\n                break;\r\n            case \"star\":\r\n                this.imageStyle = new ol.style.RegularShape({\r\n                    fill: this.convertedGlyphFill !== undefined ? new ol.style.Fill(({\r\n                        color: this.convertedGlyphFill\r\n                    })) : undefined,\r\n                    stroke: this.convertedGlyphOutLineColor !== undefined && this.outlineWidth > 0 ? new ol.style.Stroke(({\r\n                        color: this.convertedGlyphOutLineColor,\r\n                        width: this.outlineWidth\r\n                    })) : undefined,\r\n                    points: 5,\r\n                    radius: radius,\r\n                    radius2: radius / 2.5,\r\n                    angle: this.angle\r\n                });\r\n                break;\r\n            case \"star2\":\r\n                break;\r\n        }\r\n    };\r\n    GeoPointStyle.prototype.initBitmapStyle = function () {\r\n        if (this.pointFile) {\r\n            this.imageStyle = new ol.style.Icon(({\r\n                opacity: this.opacity || 1,\r\n                src: this.pointFile,\r\n                rotation: this.angle * Math.PI / 180,\r\n                offset: [this.dx, -this.dy]\r\n            }));\r\n        }\r\n    };\r\n    GeoPointStyle.prototype.initGlyphStyle = function () {\r\n        if (this.glyph) {\r\n            this.textStyle = new ol.style.Text(({\r\n                font: this.size + \"px \" + this.glyph,\r\n                offsetX: this.dx,\r\n                offsetY: this.dy,\r\n                text: this.glyphName,\r\n                fill: this.convertedGlyphFill !== undefined ? new ol.style.Fill(({\r\n                    color: this.convertedGlyphFill\r\n                })) : undefined,\r\n                stroke: this.convertedGlyphOutLineColor !== undefined && this.outlineWidth > 0 ? new ol.style.Stroke(({\r\n                    color: this.convertedGlyphOutLineColor,\r\n                    width: this.outlineWidth\r\n                })) : undefined,\r\n                rotation: this.angle * Math.PI / 180\r\n            }));\r\n        }\r\n    };\r\n    GeoPointStyle.prototype.applyTransForm = function (style) {\r\n        var transformRgx = /([a-z]+)\\((.*?)\\)/i;\r\n        if (this.transform && transformRgx.test(this.transform)) {\r\n            var matchedResults = this.transform.match(transformRgx);\r\n            var transFormType = matchedResults.length > 2 ? matchedResults[1] : \"\";\r\n            var transFormValue = matchedResults.length > 2 ? matchedResults[2] : \"\";\r\n            switch (transFormType) {\r\n                case \"rotate\":\r\n                    style.getImage() && style.getImage().setRotation(parseInt(transFormValue));\r\n                    style.getText() && style.getText().setRotation(parseInt(transFormValue));\r\n                    break;\r\n                case \"scale\":\r\n                    var scale = parseInt(transFormValue.split(\",\")[0]);\r\n                    style.getImage() && style.getImage().setScale(scale);\r\n                    style.getText() && style.getText().setScale(scale);\r\n                    break;\r\n                case \"translate\":\r\n                default:\r\n                    throw \"not support \" + this.transform;\r\n            }\r\n        }\r\n    };\r\n    GeoPointStyle.linearGradientDictionary = {};\r\n    GeoPointStyle.radialGradientDictionary = {};\r\n    return GeoPointStyle;\r\n}(_geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/style/geoPointStyle.ts?");

/***/ }),

/***/ "./src/style/geoShieldStyle.ts":
/*!*************************************!*\
  !*** ./src/style/geoShieldStyle.ts ***!
  \*************************************/
/*! exports provided: GeoShieldStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoShieldStyle\", function() { return GeoShieldStyle; });\n/* harmony import */ var _geoStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoStyle */ \"./src/style/geoStyle.ts\");\n/* harmony import */ var _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./textLabelingStrategy */ \"./src/style/textLabelingStrategy.ts\");\n/* harmony import */ var _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectTextLabelingStrategy */ \"./src/style/detectTextLabelingStrategy.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n\r\n\r\nvar GeoShieldStyle = /** @class */ (function (_super) {\r\n    __extends(GeoShieldStyle, _super);\r\n    function GeoShieldStyle(styleJson) {\r\n        var _this = _super.call(this, styleJson) || this;\r\n        _this.textAligns = [\"left\", \"right\", \"center\", \"end\", \"start\"];\r\n        _this.BATCH_CONSTRUCTORS_DEFAULT = {\r\n            Point: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_1__[\"TextLabelingStrategy\"],\r\n            MultiPoint: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_1__[\"TextLabelingStrategy\"],\r\n            LineString: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_1__[\"TextLabelingStrategy\"],\r\n            Circle: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_1__[\"TextLabelingStrategy\"],\r\n            MultiLineString: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_1__[\"TextLabelingStrategy\"],\r\n            Polygon: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_1__[\"TextLabelingStrategy\"],\r\n            MultiPolygon: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_1__[\"TextLabelingStrategy\"]\r\n        };\r\n        _this.BATCH_CONSTRUCTORS_DETECT = {\r\n            Point: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"DetectTextLabelingStrategy\"],\r\n            MultiPoint: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"DetectTextLabelingStrategy\"],\r\n            LineString: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"DetectTextLabelingStrategy\"],\r\n            Circle: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"DetectTextLabelingStrategy\"],\r\n            MultiLineString: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"DetectTextLabelingStrategy\"],\r\n            Polygon: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"DetectTextLabelingStrategy\"],\r\n            MultiPolygon: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"DetectTextLabelingStrategy\"]\r\n        };\r\n        _this.imageCache = [];\r\n        _this.labelInfos = new ol.structs.LRUCache(512);\r\n        _this.charWidths = {};\r\n        if (styleJson) {\r\n            _this.iconType = styleJson[\"shield-icon-type\"];\r\n            _this.iconSymbolType = styleJson[\"shield-icon-symbol-type\"];\r\n            _this.iconSize = styleJson[\"shield-icon-size\"] ? styleJson[\"shield-icon-size\"] : 0;\r\n            _this.iconSrc = styleJson[\"shield-icon-src\"];\r\n            _this.iconColor = styleJson[\"shield-icon-color\"];\r\n            _this.iconOutlineColor = styleJson[\"shield-icon-outline-color\"];\r\n            _this.iconOutlineWidth = styleJson[\"shield-icon-outline-width\"] ? styleJson[\"shield-icon-outline-width\"] : 0;\r\n            if (_this.iconSrc) {\r\n                if (!GeoShieldStyle.poiCache[_this.iconSrc]) {\r\n                    var imageElement = document.createElement(\"img\");\r\n                    imageElement.src = _this.iconSrc;\r\n                    GeoShieldStyle.poiCache[_this.iconSrc] = imageElement;\r\n                }\r\n            }\r\n            _this.name = styleJson[\"shield-name\"];\r\n            _this.font = styleJson[\"shield-font\"];\r\n            _this.align = styleJson[\"shield-align\"];\r\n            _this.angle = styleJson[\"shield-rotate-angle\"] ? styleJson[\"shield-rotate-angle\"] : 0;\r\n            // this.avoidEdges = styleJson[\"shield-avoid-edges\"];\r\n            _this.dateFormat = styleJson[\"shield-date-format\"];\r\n            // TODO\r\n            _this.dx = styleJson[\"shield-dx\"] ? styleJson[\"shield-dx\"] : 0;\r\n            _this.dy = styleJson[\"shield-dy\"] ? styleJson[\"shield-dy\"] : 0;\r\n            _this.faceName = styleJson[\"shield-face-name\"];\r\n            _this.fill = styleJson[\"shield-fill\"];\r\n            // this.forceHorizontalForLine = styleJson[\"shield-force-horizontal-for-line\"];\r\n            _this.haloFill = styleJson[\"shield-halo-fill\"] ? styleJson[\"shield-halo-fill\"] : \"Transparent\";\r\n            _this.haloRadius = styleJson[\"shield-halo-radius\"] ? styleJson[\"shield-halo-radius\"] : 0;\r\n            // using in strategy\r\n            _this.margin = styleJson[\"shield-margin\"];\r\n            // this.maxCharAngleDelta = styleJson[\"shield-max-char-angle-delta\"];\r\n            // using in strategy\r\n            _this.minDistance = styleJson[\"shield-min-distance\"];\r\n            // using in strategy\r\n            _this.minPadding = styleJson[\"shield-min-padding\"];\r\n            _this.name = styleJson[\"shield-name\"];\r\n            _this.numericFormat = styleJson[\"shield-numeric-format\"];\r\n            _this.opacity = styleJson[\"shield-opacity\"];\r\n            _this.orientation = styleJson[\"shield-orientation\"];\r\n            // using in strategy\r\n            _this.placements = styleJson[\"shield-placements\"] ? styleJson[\"shield-placements\"] : \"UR,U,UL,B,BR,BL,L,R\";\r\n            // using in strategy\r\n            _this.placementType = styleJson[\"shield-placement-type\"] ? styleJson[\"shield-placement-type\"] : \"default\";\r\n            _this.size = styleJson[\"shield-size\"];\r\n            // using in strategy\r\n            _this.spacing = styleJson[\"shield-spacing\"] !== undefined ? styleJson[\"shield-spacing\"] : 10;\r\n            _this.textFormat = styleJson[\"shield-text-format\"];\r\n            _this.wrap = styleJson[\"shield-wrap-before\"] ? true : styleJson[\"shield-wrap-before\"];\r\n            _this.wrapWidth = styleJson[\"shield-wrap-width\"];\r\n        }\r\n        return _this;\r\n    }\r\n    GeoShieldStyle.prototype.initializeCore = function () {\r\n        var font;\r\n        var size;\r\n        this.textStyle = new ol.style.Text({\r\n            stroke: new ol.style.Stroke()\r\n        });\r\n        if (this.textAligns.indexOf(this.align) >= 0) {\r\n            this.textStyle.setTextAlign(this.align);\r\n        }\r\n        if (this.font) {\r\n            this.textStyle.setFont(this.font ? this.font : \"10px sans-serif\");\r\n        }\r\n        if (this.fill) {\r\n            this.textStyle.getFill().setColor(_geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.fill, this.opacity));\r\n        }\r\n        if (this.haloFill) {\r\n            this.textStyle.getStroke().setColor(_geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.haloFill, this.opacity));\r\n        }\r\n        if (this.haloRadius) {\r\n            this.textStyle.getStroke().setWidth(this.haloRadius);\r\n        }\r\n        if (this.orientation) {\r\n            this.textStyle.setRotation(this.orientation);\r\n        }\r\n        if (this.iconColor) {\r\n            this.convertSymbolColor = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.iconColor);\r\n        }\r\n        if (this.iconOutlineColor) {\r\n            this.convertSymbolOutlineColor = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.iconOutlineColor);\r\n        }\r\n        this.style = new ol.style.Style({\r\n            text: this.textStyle\r\n        });\r\n        var chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n        for (var i = 0; i < chars.length; i++) {\r\n            this.charWidths[chars[i]] = ol.render.canvas.measureTextWidth(this.font, chars[i]);\r\n        }\r\n        this.charWidths[\" \"] = ol.render.canvas.measureTextWidth(this.font, \" \");\r\n        for (var i = 0; i <= 9; i++) {\r\n            this.charWidths[i] = ol.render.canvas.measureTextWidth(this.font, i);\r\n        }\r\n        switch (this.iconType) {\r\n            case \"image\":\r\n            case \"Image\":\r\n                this.setShiledImageIcon();\r\n                break;\r\n            case \"symbol\":\r\n            case \"Symbol\":\r\n                this.setShieldSymbolIcon();\r\n                break;\r\n        }\r\n    };\r\n    GeoShieldStyle.prototype.getConvertedStyleCore = function (feature, resolution, options) {\r\n        var featureText = \"\";\r\n        if (this.name) {\r\n            featureText = feature.get(this.name);\r\n        }\r\n        featureText = this.formatText(featureText);\r\n        if (featureText === undefined || featureText === \"\") {\r\n            return;\r\n        }\r\n        this.textStyle.setText(featureText);\r\n        var labelInfo = this.getLabelInfo(featureText);\r\n        var flatCoordinates = this.setLabelPosition(feature, resolution, labelInfo, options.strategyTree, options.frameState);\r\n        if (flatCoordinates === undefined || flatCoordinates.length < 2) {\r\n            return;\r\n        }\r\n        this.style.setGeometry(new ol.geom.Point(flatCoordinates, \"XY\"));\r\n        var labelimage = this.getImage(labelInfo);\r\n        this.textStyle.label = labelimage;\r\n        this.textStyle.labelPosition = flatCoordinates;\r\n        if (this.imageCache[featureText] === undefined) {\r\n            this.imageCache[featureText] = [];\r\n        }\r\n        var featureZindex = feature[\"tempTreeZindex\"];\r\n        if (featureZindex === undefined) {\r\n            featureZindex = 0;\r\n        }\r\n        this.style.setZIndex(featureZindex);\r\n        return [this.style];\r\n    };\r\n    GeoShieldStyle.prototype.setShieldSymbolIcon = function () {\r\n        if (this.iconSymbolType !== undefined) {\r\n            switch (this.iconSymbolType) {\r\n                case \"circle\":\r\n                    this.setCircleIcon();\r\n                    break;\r\n                case \"square\":\r\n                    this.setSquareIcon();\r\n                    break;\r\n                case \"triangle\":\r\n                    this.setTriangleIcon();\r\n                    break;\r\n                case \"cross\":\r\n                    this.setCrossIcon();\r\n                    break;\r\n                case \"star\":\r\n                    this.setStarIcon();\r\n                    break;\r\n            }\r\n            this.style.setImage(this.image);\r\n        }\r\n    };\r\n    GeoShieldStyle.prototype.setStarIcon = function () {\r\n        var fill = undefined;\r\n        var stroke = undefined;\r\n        var radius = this.iconSize * 0.5;\r\n        if (this.iconColor) {\r\n            fill = new ol.style.Fill(({ color: this.convertSymbolColor }));\r\n        }\r\n        if (this.iconOutlineColor || this.iconOutlineWidth) {\r\n            stroke = new ol.style.Stroke(({\r\n                color: this.convertSymbolOutlineColor,\r\n                width: this.iconOutlineWidth\r\n            }));\r\n        }\r\n        this.image = new ol.style.RegularShape({\r\n            fill: fill,\r\n            stroke: stroke,\r\n            points: 5,\r\n            radius: radius,\r\n            radius2: radius / 2.5,\r\n            angle: this.angle\r\n        });\r\n    };\r\n    GeoShieldStyle.prototype.setCrossIcon = function () {\r\n        var fill = undefined;\r\n        var stroke = undefined;\r\n        var radius = this.iconSize * 0.5;\r\n        if (this.iconColor) {\r\n            fill = new ol.style.Fill(({ color: this.convertSymbolColor }));\r\n        }\r\n        if (this.iconOutlineColor || this.iconOutlineWidth) {\r\n            stroke = new ol.style.Stroke(({\r\n                color: this.convertSymbolOutlineColor,\r\n                width: this.iconOutlineWidth\r\n            }));\r\n        }\r\n        this.image = new ol.style.RegularShape({\r\n            fill: fill,\r\n            stroke: stroke,\r\n            points: 4,\r\n            radius: radius,\r\n            radius2: 0,\r\n            angle: this.angle\r\n        });\r\n    };\r\n    GeoShieldStyle.prototype.setTriangleIcon = function () {\r\n        var fill = undefined;\r\n        var stroke = undefined;\r\n        var radius = this.iconSize * 0.5;\r\n        if (this.iconColor) {\r\n            fill = new ol.style.Fill(({ color: this.convertSymbolColor }));\r\n        }\r\n        if (this.iconOutlineColor || this.iconOutlineWidth) {\r\n            stroke = new ol.style.Stroke(({\r\n                color: this.convertSymbolOutlineColor,\r\n                width: this.iconOutlineWidth\r\n            }));\r\n        }\r\n        this.image = new ol.style.RegularShape({\r\n            fill: fill,\r\n            stroke: stroke,\r\n            points: 3,\r\n            radius: radius,\r\n            angle: this.angle\r\n        });\r\n    };\r\n    GeoShieldStyle.prototype.setSquareIcon = function () {\r\n        var fill = undefined;\r\n        var stroke = undefined;\r\n        var radius = this.iconSize * 0.5;\r\n        if (this.iconColor) {\r\n            fill = new ol.style.Fill(({ color: this.convertSymbolColor }));\r\n        }\r\n        if (this.iconOutlineColor || this.iconOutlineWidth) {\r\n            stroke = new ol.style.Stroke(({\r\n                color: this.convertSymbolOutlineColor,\r\n                width: this.iconOutlineWidth\r\n            }));\r\n        }\r\n        this.image = new ol.style.RegularShape({\r\n            fill: fill,\r\n            stroke: stroke,\r\n            points: 4,\r\n            radius: radius,\r\n            angle: Math.PI / 4 + this.angle\r\n        });\r\n    };\r\n    GeoShieldStyle.prototype.setCircleIcon = function () {\r\n        var fill = undefined;\r\n        var stroke = undefined;\r\n        var radius = this.iconSize * 0.5;\r\n        if (this.iconColor) {\r\n            fill = new ol.style.Fill(({ color: this.convertSymbolColor }));\r\n        }\r\n        if (this.iconOutlineColor || this.iconOutlineWidth) {\r\n            stroke = new ol.style.Stroke(({\r\n                color: this.convertSymbolOutlineColor,\r\n                width: this.iconOutlineWidth\r\n            }));\r\n        }\r\n        this.image = new ol.style.Circle({\r\n            fill: fill,\r\n            stroke: stroke,\r\n            radius: radius\r\n        });\r\n    };\r\n    GeoShieldStyle.prototype.setShiledImageIcon = function () {\r\n        if (this.iconSrc !== undefined) {\r\n            var poiImg = GeoShieldStyle.poiCache[this.iconSrc];\r\n            if (poiImg.complete) {\r\n                if (poiImg.naturalWidth !== 0) {\r\n                    this.image = new ol.style.Icon({\r\n                        img: poiImg,\r\n                        imgSize: [poiImg.width, poiImg.height],\r\n                        rotation: this.angle * Math.PI / 180\r\n                    });\r\n                    this.style.setImage(this.image);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    GeoShieldStyle.prototype.getLabelInfo = function (text) {\r\n        var key = text;\r\n        if (!this.labelInfos.containsKey(key)) {\r\n            var font = this.formatFont(this.textStyle.getFont());\r\n            text = this.wrapText(text, font);\r\n            var fillState = this.textStyle.getFill();\r\n            var strokeState = this.textStyle.getStroke();\r\n            var pixelRatio = window.devicePixelRatio;\r\n            var scale = this.textStyle.getScale();\r\n            scale = (scale ? scale : 1) * pixelRatio;\r\n            var align = ol.render.replay.TEXT_ALIGN[this.textStyle.getTextAlign() || ol.render.canvas.defaultTextAlign];\r\n            var strokeWidth = strokeState && strokeState.getWidth() ? strokeState.getWidth() : 0;\r\n            var lines = text.split(\"\\n\");\r\n            var numLines = lines.length;\r\n            var widths = [];\r\n            // let width = (<any>ol.render.canvas).TextReplay.measureTextWidths(font, lines, widths);\r\n            var width = this.getEstimatedWidth(font, lines, widths);\r\n            var renderWidth = width + strokeWidth;\r\n            var lineHeight = ol.render.canvas.measureTextHeight(font);\r\n            var height = lineHeight * numLines;\r\n            // if (this.dx) { this.textStyle.setOffsetX(this.dx + height / 2); }\r\n            if (this.dx) {\r\n                this.textStyle.setOffsetX(this.dx);\r\n            }\r\n            // if (this.dy) { this.textStyle.setOffsetY(this.dy + height / 2); }\r\n            if (this.dy) {\r\n                this.textStyle.setOffsetY(this.dy);\r\n            }\r\n            var labelWidth = Math.ceil(renderWidth * scale);\r\n            var labelHeight = Math.ceil((height + strokeWidth) * scale);\r\n            var labelInfo = {\r\n                width: labelWidth,\r\n                height: labelHeight,\r\n                scale: scale,\r\n                numLines: numLines,\r\n                lines: lines,\r\n                widths: widths,\r\n                lineHeight: lineHeight,\r\n                font: font\r\n            };\r\n            this.labelInfos.set(key, labelInfo);\r\n        }\r\n        return this.labelInfos.get(key);\r\n    };\r\n    GeoShieldStyle.prototype.setLabelPosition = function (geometry, resolution, labelInfo, strategyTree, frameState) {\r\n        var geometryType = geometry.getType();\r\n        var flatCoordinates;\r\n        var i, ii;\r\n        var Constructor;\r\n        if (this.placementType === \"default\") {\r\n            Constructor = this.BATCH_CONSTRUCTORS_DEFAULT[geometryType];\r\n        }\r\n        else if (this.placementType === \"detect\") {\r\n            Constructor = this.BATCH_CONSTRUCTORS_DETECT[geometryType];\r\n        }\r\n        var textLabelingStrategy = new Constructor();\r\n        var width = labelInfo.width;\r\n        var height = labelInfo.height;\r\n        switch (geometryType) {\r\n            case ol.geom.GeometryType.POINT:\r\n            case ol.geom.GeometryType.MULTI_POINT:\r\n                flatCoordinates = geometry.getFlatCoordinates();\r\n                break;\r\n            case ol.geom.GeometryType.LINE_STRING:\r\n                flatCoordinates = /** @type {ol.geom.LineString} */ (geometry).getFlatMidpoint();\r\n                break;\r\n            case ol.geom.GeometryType.CIRCLE:\r\n                flatCoordinates = /** @type {ol.geom.Circle} */ (geometry).getCenter();\r\n                break;\r\n            case ol.geom.GeometryType.MULTI_LINE_STRING:\r\n                flatCoordinates = /** @type {ol.geom.MultiLineString} */ (geometry).getFlatMidpoints();\r\n                break;\r\n            case ol.geom.GeometryType.POLYGON:\r\n                flatCoordinates = /** @type {ol.geom.Polygon} */ (geometry).getFlatInteriorPoint();\r\n                break;\r\n            case ol.geom.GeometryType.MULTI_POLYGON:\r\n                var interiorPoints = /** @type {ol.geom.MultiPolygon} */ (geometry).getFlatInteriorPoints();\r\n                flatCoordinates = [];\r\n                for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {\r\n                    if (this.textStyle.overflow || interiorPoints[i + 2] / resolution >= width) {\r\n                        flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n        }\r\n        flatCoordinates = textLabelingStrategy.markLocation(flatCoordinates, width, height, resolution, geometryType, this, strategyTree, frameState);\r\n        return flatCoordinates;\r\n    };\r\n    GeoShieldStyle.prototype.getEstimatedWidth = function (font, lines, widths) {\r\n        var numLines = lines.length;\r\n        var width = 0;\r\n        var currentWidth, i;\r\n        for (i = 0; i < numLines; ++i) {\r\n            currentWidth = 0;\r\n            for (var j = 0; j < lines[i].length; j++) {\r\n                var charWidth = this.charWidths[lines[i][j]];\r\n                if (charWidth) {\r\n                    currentWidth += charWidth;\r\n                }\r\n                else {\r\n                    currentWidth += this.charWidths[\"W\"];\r\n                }\r\n            }\r\n            width = Math.max(width, currentWidth);\r\n            widths.push(currentWidth);\r\n        }\r\n        return width;\r\n    };\r\n    GeoShieldStyle.prototype.getImage = function (labelInfo) {\r\n        if (labelInfo.label === undefined) {\r\n            var context = ol.dom.createCanvasContext2D(labelInfo.width, labelInfo.height);\r\n            var label = context.canvas;\r\n            if (labelInfo.scale !== 1) {\r\n                context.scale(labelInfo.scale, labelInfo.scale);\r\n            }\r\n            context.font = labelInfo.font;\r\n            var strokeState = this.textStyle.getStroke();\r\n            var strokeWidth = strokeState && strokeState.getWidth() ? strokeState.getWidth() : 0;\r\n            var fillState = this.textStyle.getFill();\r\n            if (strokeState) {\r\n                context.strokeStyle = strokeState.getColor() ? strokeState.getColor() : \"Transparent\";\r\n                context.lineWidth = strokeWidth * (ol.has.SAFARI ? labelInfo.scale : 1);\r\n                context.lineCap = strokeState.getLineCap();\r\n                context.lineJoin = strokeState.getLineJoin();\r\n                context.miterLimit = strokeState.getMiterLimit();\r\n                var lineDash = strokeState.getLineDash();\r\n                lineDash = lineDash ? lineDash.slice() : ol.render.canvas.defaultLineDash;\r\n                if (ol.has.CANVAS_LINE_DASH && lineDash.length) {\r\n                    context.setLineDash(strokeState.getLineDash());\r\n                    context.lineDashOffset = strokeState.getLineDashOffset();\r\n                }\r\n            }\r\n            if (fillState) {\r\n                context.fillStyle = fillState.getColor();\r\n            }\r\n            context.textBaseline = \"middle\";\r\n            context.textAlign = \"center\";\r\n            var align = ol.render.replay.TEXT_ALIGN[this.textStyle.getTextAlign() || ol.render.canvas.defaultTextAlign];\r\n            var leftRight = (0.5 - align);\r\n            var x = align * label.width / labelInfo.scale + leftRight * strokeWidth;\r\n            var i = void 0;\r\n            if (strokeState) {\r\n                for (i = 0; i < labelInfo.numLines; ++i) {\r\n                    context.strokeText(labelInfo.lines[i], x + leftRight * labelInfo.widths[i], 0.5 * (strokeWidth + labelInfo.lineHeight) + i * labelInfo.lineHeight);\r\n                }\r\n            }\r\n            if (fillState) {\r\n                for (i = 0; i < labelInfo.numLines; ++i) {\r\n                    context.fillText(labelInfo.lines[i], x + leftRight * labelInfo.widths[i], 0.5 * (strokeWidth + labelInfo.lineHeight) + i * labelInfo.lineHeight);\r\n                }\r\n            }\r\n            labelInfo[\"label\"] = label;\r\n        }\r\n        return labelInfo[\"label\"];\r\n    };\r\n    GeoShieldStyle.prototype.formatText = function (featureText) {\r\n        if (this.numericFormat) {\r\n            featureText = this.getTextWithNumericFormat(featureText);\r\n        }\r\n        if (this.dateFormat) {\r\n            featureText = this.getTextWithDateFormat(featureText);\r\n        }\r\n        if (this.textFormat) {\r\n            featureText = this.getTextWithFormat(featureText);\r\n        }\r\n        return featureText;\r\n    };\r\n    GeoShieldStyle.prototype.getTextWithNumericFormat = function (featureText) {\r\n        var tmpArguments = this.numericFormat.split(\",\");\r\n        var numericFormatOptions = {};\r\n        for (var _i = 0, tmpArguments_1 = tmpArguments; _i < tmpArguments_1.length; _i++) {\r\n            var tmpArgument = tmpArguments_1[_i];\r\n            var keyValuePair = tmpArgument.split(\":\");\r\n            switch (keyValuePair[0].trim()) {\r\n                case \"localeMatcher\":\r\n                    numericFormatOptions.localeMatcher = keyValuePair[1].trim();\r\n                    break;\r\n                case \"style\":\r\n                    numericFormatOptions.style = keyValuePair[1].trim();\r\n                    break;\r\n                case \"currency\":\r\n                    numericFormatOptions.currency = keyValuePair[1].trim();\r\n                    break;\r\n                case \"currencyDisplay\":\r\n                    numericFormatOptions.currencyDisplay = keyValuePair[1].trim();\r\n                    break;\r\n                case \"useGrouping\":\r\n                    numericFormatOptions.useGrouping = keyValuePair[1].trim();\r\n                    break;\r\n                case \"minimumIntegerDigits\":\r\n                    numericFormatOptions.minimumIntegerDigits = keyValuePair[1].trim();\r\n                    break;\r\n                case \"minimumFractionDigits\":\r\n                    numericFormatOptions.minimumFractionDigits = keyValuePair[1].trim();\r\n                    break;\r\n                case \"maximumFractionDigits\":\r\n                    numericFormatOptions.maximumFractionDigits = keyValuePair[1].trim();\r\n                    break;\r\n                case \"minimumSignificantDigits\":\r\n                    numericFormatOptions.minimumSignificantDigits = keyValuePair[1].trim();\r\n                    break;\r\n                case \"maximumSignificantDigits\":\r\n                    numericFormatOptions.maximumSignificantDigits = keyValuePair[1].trim();\r\n                    break;\r\n            }\r\n        }\r\n        var numeric = new Intl.NumberFormat(tmpArguments[0], numericFormatOptions);\r\n        return numeric.format(Number(featureText));\r\n    };\r\n    GeoShieldStyle.prototype.getTextWithDateFormat = function (featureText) {\r\n        return (new Date(featureText)).format(this.dateFormat);\r\n    };\r\n    GeoShieldStyle.prototype.getTextWithFormat = function (featureText) {\r\n        return String.format(featureText, this.textFormat);\r\n    };\r\n    GeoShieldStyle.prototype.getPointGeometry = function (feature) {\r\n        return feature.getGeometry();\r\n    };\r\n    GeoShieldStyle.prototype.wrapText = function (text, font) {\r\n        var resultText;\r\n        if (text !== \"\") {\r\n            var lines = [text];\r\n            var widths = [];\r\n            // let width = (<any>ol.render.canvas).TextReplay.measureTextWidths(font, lines, widths);\r\n            var width = this.getEstimatedWidth(font, lines, widths);\r\n            var wrapWidth = this.wrapWidth;\r\n            var wrapCharacter = \" \";\r\n            var isWrapBefore = this.wrap;\r\n            if (wrapWidth > 0 && width > wrapWidth && text.includes(wrapCharacter)) {\r\n                var textLines = [];\r\n                lines = text.split(wrapCharacter);\r\n                var wrapLines = [];\r\n                var wrapWidthSum = 0;\r\n                var tmpWrapWidth = void 0;\r\n                if (isWrapBefore) {\r\n                    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\r\n                        var line = lines_1[_i];\r\n                        var tmpLine = [line];\r\n                        // tmpWrapWidth = (<any>ol.render.canvas).TextReplay.measureTextWidths(font, tmpLine, widths);\r\n                        tmpWrapWidth = this.getEstimatedWidth(font, tmpLine, widths);\r\n                        wrapWidthSum += tmpWrapWidth;\r\n                        if (tmpWrapWidth > wrapWidth) {\r\n                            wrapLines = [];\r\n                            textLines = [];\r\n                            wrapWidthSum = 0;\r\n                            break;\r\n                        }\r\n                        if (wrapLines.length > 0) {\r\n                            if (wrapWidthSum > wrapWidth) {\r\n                                wrapLines.push(\"\\n\");\r\n                                textLines.push(wrapLines.join(\"\"));\r\n                                wrapLines = [];\r\n                                wrapWidthSum = 0;\r\n                            }\r\n                        }\r\n                        wrapLines.push(\" \" + line);\r\n                    }\r\n                    if (wrapLines.length > 0) {\r\n                        textLines.push(wrapLines.join(\"\"));\r\n                    }\r\n                }\r\n                else {\r\n                    for (var _a = 0, lines_2 = lines; _a < lines_2.length; _a++) {\r\n                        var line = lines_2[_a];\r\n                        wrapLines.push(\" \" + line);\r\n                        var tmpLine = [line];\r\n                        // tmpWrapWidth = (<any>ol.render.canvas).TextReplay.measureTextWidths(font, tmpLine, widths);\r\n                        tmpWrapWidth = this.getEstimatedWidth(font, tmpLine, widths);\r\n                        wrapWidthSum += tmpWrapWidth;\r\n                        if (wrapWidthSum > wrapWidth) {\r\n                            wrapLines.push(\"\\n\");\r\n                            textLines.push(wrapLines.join(\"\"));\r\n                            wrapLines = [];\r\n                            wrapWidthSum = 0;\r\n                        }\r\n                    }\r\n                    if (wrapLines.length > 0) {\r\n                        textLines.push(wrapLines.join(\"\"));\r\n                    }\r\n                }\r\n                resultText = textLines.join(\"\");\r\n                if (resultText.lastIndexOf(\"\\n\") === resultText.length - 1) {\r\n                    resultText = resultText.substr(0, resultText.length - 1);\r\n                }\r\n            }\r\n            else {\r\n                resultText = text;\r\n            }\r\n        }\r\n        return resultText;\r\n    };\r\n    GeoShieldStyle.prototype.formatFont = function (font) {\r\n        var tmpFonts = font.split(\" \");\r\n        var formatedFont = [];\r\n        if (tmpFonts[tmpFonts.length - 1].includes(\"bold\") || tmpFonts[tmpFonts.length - 1].includes(\"italic\")) {\r\n            formatedFont.push(tmpFonts[tmpFonts.length - 1] + \" \");\r\n            for (var i = 0; i < tmpFonts.length - 1; i++) {\r\n                formatedFont.push(tmpFonts[i] + \" \");\r\n            }\r\n        }\r\n        else {\r\n            return font;\r\n        }\r\n        return formatedFont.join(\"\").trim();\r\n    };\r\n    GeoShieldStyle.poiCache = [];\r\n    return GeoShieldStyle;\r\n}(_geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"]));\r\n\r\n\n\n//# sourceURL=webpack:///./src/style/geoShieldStyle.ts?");

/***/ }),

/***/ "./src/style/geoStyle.ts":
/*!*******************************!*\
  !*** ./src/style/geoStyle.ts ***!
  \*******************************/
/*! exports provided: GeoStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoStyle\", function() { return GeoStyle; });\nvar GeoStyle = /** @class */ (function () {\r\n    function GeoStyle(styleJson) {\r\n        this.styles = [];\r\n        if (styleJson) {\r\n            this.id = styleJson[\"id\"];\r\n            this.uid = ol.getUid(this);\r\n            this.visible = styleJson[\"visible\"] === undefined ? true : styleJson[\"visible\"];\r\n        }\r\n    }\r\n    GeoStyle.prototype.initialize = function () {\r\n        if (!this.initialized) {\r\n            this.initializeCore();\r\n            this.initialized = true;\r\n        }\r\n    };\r\n    GeoStyle.prototype.initializeCore = function () {\r\n    };\r\n    GeoStyle.prototype.getStyles = function (feature, resolution, options) {\r\n        var results = [];\r\n        if (this.visible) {\r\n            results = this.getConvertedStyle(feature, resolution, options);\r\n        }\r\n        return results;\r\n    };\r\n    GeoStyle.prototype.getConvertedStyle = function (feature, resolution, options) {\r\n        this.initialize();\r\n        return this.getConvertedStyleCore(feature, resolution, options);\r\n    };\r\n    GeoStyle.prototype.getConvertedStyleCore = function (feature, resolution, options) {\r\n        return [];\r\n    };\r\n    GeoStyle.prototype.skewGeometry = function (geometry, xDeg, yDeg) {\r\n        var center = ol.extent.getCenter(geometry.getExtent());\r\n        for (var i = 0; i < geometry.flatCoordinates.length; i += 2) {\r\n            var x = geometry.flatCoordinates[i];\r\n            var y = geometry.flatCoordinates[i + 1];\r\n            var rx = this.skewX(x, y, center[0], center[1], xDeg);\r\n            var ry = this.skewY(x, y, center[0], center[1], yDeg);\r\n            geometry.flatCoordinates[i] = rx;\r\n            geometry.flatCoordinates[i + 1] = ry;\r\n        }\r\n    };\r\n    GeoStyle.prototype.skewX = function (x, y, cx, cy, xDeg) {\r\n        var rx = x;\r\n        if (xDeg !== 0) {\r\n            var xResolution = Math.tan(1.0 * xDeg * Math.PI / 180);\r\n            var distance = void 0;\r\n            if (x > cx) {\r\n                if (y > cy) {\r\n                    distance = xResolution * Math.abs(y - cy);\r\n                }\r\n                else {\r\n                    distance = 0 - xResolution * Math.abs(y - cy);\r\n                }\r\n            }\r\n            else {\r\n                if (y > cy) {\r\n                    distance = xResolution * Math.abs(y - cy);\r\n                }\r\n                else {\r\n                    distance = 0 - xResolution * Math.abs(y - cy);\r\n                }\r\n            }\r\n            rx += Math.round(distance);\r\n        }\r\n        return rx;\r\n    };\r\n    GeoStyle.prototype.skewY = function (x, y, cx, cy, yDeg) {\r\n        var ry = y;\r\n        if (yDeg !== 0) {\r\n            var yResolution = Math.tan(1.0 * yDeg * Math.PI / 180);\r\n            var distance = void 0;\r\n            if (y > cy) {\r\n                if (x > cx) {\r\n                    distance = yResolution * Math.abs(x - cx);\r\n                }\r\n                else {\r\n                    distance = 0 - yResolution * Math.abs(x - cx);\r\n                }\r\n            }\r\n            else {\r\n                if (x > cx) {\r\n                    distance = yResolution * Math.abs(x - cx);\r\n                }\r\n                else {\r\n                    distance = 0 - yResolution * Math.abs(x - cx);\r\n                }\r\n            }\r\n            ry += Math.round(distance);\r\n        }\r\n        return ry;\r\n    };\r\n    GeoStyle.toRGBAColor = function (color, opacity) {\r\n        if (opacity === void 0) { opacity = 1; }\r\n        if (color.indexOf(\"#\") === 0) {\r\n            var array = void 0;\r\n            var r = void 0;\r\n            var g = void 0;\r\n            var b = void 0;\r\n            var a = void 0;\r\n            if (color.length === 4) {\r\n                r = +(\"0x\" + color.substr(1, 1) + color.substr(1, 1));\r\n                g = +(\"0x\" + color.substr(2, 1) + color.substr(2, 1));\r\n                b = +(\"0x\" + color.substr(3, 1) + color.substr(3, 1));\r\n                a = opacity;\r\n            }\r\n            else {\r\n                r = +(\"0x\" + color.substr(1, 2));\r\n                g = +(\"0x\" + color.substr(3, 2));\r\n                b = +(\"0x\" + color.substr(5, 2));\r\n                a = opacity;\r\n            }\r\n            array = [r, g, b, a];\r\n            if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {\r\n                return \"rgba(\" + array.join(\",\") + \")\";\r\n            }\r\n            else {\r\n                return \"rgba(0,0,0,0)\";\r\n            }\r\n        }\r\n        if (color.indexOf(\"rgb(\") === 0) {\r\n            color = color.replace(\"rgb(\", \"rgba(\");\r\n            color = color.substring(0, color.length - 1) + \",\" + opacity + \")\";\r\n        }\r\n        if (color.indexOf(\"argb(\") === 0) {\r\n            color = color.replace(\"argb(\", \"\").replace(\")\", \"\");\r\n            var array = color.split(\",\");\r\n            var a = array.shift();\r\n            array.push(a);\r\n            color = \"rgba(\" + array.join(\",\") + \")\";\r\n        }\r\n        return color;\r\n    };\r\n    GeoStyle.toOLLinearGradient = function (color, opacity, size) {\r\n        if (opacity === void 0) { opacity = 1; }\r\n        var canvas = document.createElement(\"canvas\");\r\n        var context = canvas.getContext(\"2d\");\r\n        context.rect(0, 0, size, size);\r\n        var grd = context.createLinearGradient(0, 0, size, size);\r\n        var colorStops = color.split(\",\");\r\n        for (var _i = 0, colorStops_1 = colorStops; _i < colorStops_1.length; _i++) {\r\n            var colorStop = colorStops_1[_i];\r\n            colorStop = colorStop.trim();\r\n            var tmpColorStop = colorStop.substr(1, colorStop.length - 2);\r\n            var cs = tmpColorStop.split(\":\");\r\n            grd.addColorStop(Number(cs[0].trim()), this.toRGBAColor(cs[1].trim(), opacity));\r\n        }\r\n        return grd;\r\n    };\r\n    GeoStyle.toOLRadialGradient = function (color, opacity, size) {\r\n        if (opacity === void 0) { opacity = 1; }\r\n        var canvas = document.createElement(\"canvas\");\r\n        var context = canvas.getContext(\"2d\");\r\n        context.rect(0, 0, size, size);\r\n        var grd = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);\r\n        var colorStops = color.split(\",\");\r\n        for (var _i = 0, colorStops_2 = colorStops; _i < colorStops_2.length; _i++) {\r\n            var colorStop = colorStops_2[_i];\r\n            colorStop = colorStop.trim();\r\n            var tmpColorStop = colorStop.substr(1, colorStop.length - 2);\r\n            var cs = tmpColorStop.split(\":\");\r\n            grd.addColorStop(Number(cs[0].trim()), this.toRGBAColor(cs[1].trim(), opacity));\r\n        }\r\n        return grd;\r\n    };\r\n    return GeoStyle;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack:///./src/style/geoStyle.ts?");

/***/ }),

/***/ "./src/style/geoStyleProperty.ts":
/*!***************************************!*\
  !*** ./src/style/geoStyleProperty.ts ***!
  \***************************************/
/*! exports provided: GeoStyleProperty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoStyleProperty\", function() { return GeoStyleProperty; });\n/* harmony import */ var _filter_geoFilterItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filter/geoFilterItem */ \"./src/filter/geoFilterItem.ts\");\n/* harmony import */ var _filter_geoZoomFilter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../filter/geoZoomFilter */ \"./src/filter/geoZoomFilter.ts\");\n/* harmony import */ var _filter_geoStringAttributeFilter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../filter/geoStringAttributeFilter */ \"./src/filter/geoStringAttributeFilter.ts\");\n/* harmony import */ var _filter_geoRegexFilter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../filter/geoRegexFilter */ \"./src/filter/geoRegexFilter.ts\");\n/* harmony import */ var _filter_geoNumberAttributeFilter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../filter/geoNumberAttributeFilter */ \"./src/filter/geoNumberAttributeFilter.ts\");\n\r\n\r\n\r\n\r\n\r\nvar GeoStyleProperty = /** @class */ (function () {\r\n    function GeoStyleProperty(styleJsonValue, defaultValue) {\r\n        this.styleJsonValue = styleJsonValue;\r\n        this.defaultValue = defaultValue;\r\n    }\r\n    GeoStyleProperty.prototype.initialize = function () {\r\n        if (this.styleJsonValue !== undefined) {\r\n            if (typeof this.styleJsonValue === \"object\") {\r\n                this.conditions = [];\r\n                this.values = [];\r\n                for (var name_1 in this.styleJsonValue) {\r\n                    var filters = this.createFilter(name_1);\r\n                    this.conditions.push(filters);\r\n                    this.values.push(this.initializeValue(this.styleJsonValue[name_1]));\r\n                }\r\n            }\r\n        }\r\n        this.value = this.initializeValue(this.defaultValue);\r\n    };\r\n    GeoStyleProperty.prototype.initializeValue = function (value) {\r\n        return value;\r\n    };\r\n    GeoStyleProperty.prototype.isCondition = function () {\r\n        return this.conditions && this.conditions.length > 0;\r\n    };\r\n    GeoStyleProperty.prototype.getValue = function (columnValue) {\r\n        if (this.conditions && this.conditions.length > 0) {\r\n            if (columnValue) {\r\n                var i = 0;\r\n                var matched = false;\r\n                for (i = 0; i < this.conditions.length; i++) {\r\n                    var filterGroup = this.conditions[i];\r\n                    for (var j = 0; j < filterGroup.length; j++) {\r\n                        var filters = filterGroup[j];\r\n                        var groupMatched = true;\r\n                        for (var k = 0; k < filters.length; k++) {\r\n                            var filter = filters[k];\r\n                            var rawFeature = { properties: columnValue };\r\n                            if (!filter.matchOLFeature(rawFeature, 0)) {\r\n                                groupMatched = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (groupMatched) {\r\n                            matched = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (matched) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (matched) {\r\n                    return this.values[i];\r\n                }\r\n            }\r\n            else {\r\n                return this.value;\r\n            }\r\n        }\r\n        else {\r\n            return this.value;\r\n        }\r\n    };\r\n    GeoStyleProperty.prototype.createFilter = function (filterString) {\r\n        var filterGroup = [];\r\n        if (filterString) {\r\n            var filterStrings = filterString.split(\"|\");\r\n            for (var i = 0; i < filterStrings.length; i++) {\r\n                var filterStr = filterStrings[i];\r\n                var expression = \"(\\\\w+?=~'.+?')|(\\\\w+?[<>!=]*'[^;]+?')|(\\\\w+?[<>!=]*[^;]+)\";\r\n                var regex = new RegExp(expression, \"g\");\r\n                var results = filterStr.match(regex);\r\n                var rangeFilters = {};\r\n                var filters = [];\r\n                var geoZoomFilter = void 0;\r\n                for (var i_1 = 0; i_1 < results.length; i_1++) {\r\n                    if (results[i_1]) {\r\n                        var filterItem = _filter_geoFilterItem__WEBPACK_IMPORTED_MODULE_0__[\"GeoFilterItem\"].createFilterItem(results[i_1]);\r\n                        if (filterItem.value.indexOf(\"~'\") === 0) {\r\n                            filters.push(new _filter_geoRegexFilter__WEBPACK_IMPORTED_MODULE_3__[\"GeoRegexFilter\"]([filterItem]));\r\n                        }\r\n                        else if (filterItem.key === \"zoom\") {\r\n                            if (geoZoomFilter === undefined) {\r\n                                geoZoomFilter = new _filter_geoZoomFilter__WEBPACK_IMPORTED_MODULE_1__[\"GeoZoomFilter\"]([]);\r\n                            }\r\n                            geoZoomFilter.addFilterItem(filterItem);\r\n                        }\r\n                        else if (filterItem.value.includes(\"'\")) {\r\n                            filters.push(new _filter_geoStringAttributeFilter__WEBPACK_IMPORTED_MODULE_2__[\"GeoStringAttributeFilter\"]([filterItem]));\r\n                        }\r\n                        else {\r\n                            rangeFilters[filterItem.key] = rangeFilters[filterItem.key] || new _filter_geoNumberAttributeFilter__WEBPACK_IMPORTED_MODULE_4__[\"GeoNumberAttributeFilter\"]([]);\r\n                            rangeFilters[filterItem.key].addFilterItem(filterItem);\r\n                        }\r\n                    }\r\n                }\r\n                for (var name_2 in rangeFilters) {\r\n                    filters.push(rangeFilters[name_2]);\r\n                }\r\n                filterGroup.push(filters);\r\n            }\r\n        }\r\n        return filterGroup;\r\n    };\r\n    return GeoStyleProperty;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack:///./src/style/geoStyleProperty.ts?");

/***/ }),

/***/ "./src/style/geoTextStyle.ts":
/*!***********************************!*\
  !*** ./src/style/geoTextStyle.ts ***!
  \***********************************/
/*! exports provided: GeoTextStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoTextStyle\", function() { return GeoTextStyle; });\n/* harmony import */ var _geoStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geoStyle */ \"./src/style/geoStyle.ts\");\n/* harmony import */ var _geoStyleProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geoStyleProperty */ \"./src/style/geoStyleProperty.ts\");\n/* harmony import */ var _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./textLabelingStrategy */ \"./src/style/textLabelingStrategy.ts\");\n/* harmony import */ var _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./detectTextLabelingStrategy */ \"./src/style/detectTextLabelingStrategy.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    }\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n\r\n\r\n\r\nvar GeoTextStyle = /** @class */ (function (_super) {\r\n    __extends(GeoTextStyle, _super);\r\n    function GeoTextStyle(styleJson) {\r\n        var _this = _super.call(this, styleJson) || this;\r\n        _this.textAligns = [\"left\", \"right\", \"center\", \"end\", \"start\"];\r\n        _this.textBaseline = [\"bottom\", \"top\", \"middle\", \"alphabetic\", \"hanging\", \"ideographic\"];\r\n        _this.textTransforms = [\"default\", \"uppercase\", \"lowercase\"];\r\n        _this.drawnMask = false;\r\n        _this.BATCH_CONSTRUCTORS_DEFAULT = {\r\n            Point: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"TextLabelingStrategy\"],\r\n            MultiPoint: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"TextLabelingStrategy\"],\r\n            LineString: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"TextLabelingStrategy\"],\r\n            Circle: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"TextLabelingStrategy\"],\r\n            MultiLineString: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"TextLabelingStrategy\"],\r\n            Polygon: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"TextLabelingStrategy\"],\r\n            MultiPolygon: _textLabelingStrategy__WEBPACK_IMPORTED_MODULE_2__[\"TextLabelingStrategy\"]\r\n        };\r\n        _this.BATCH_CONSTRUCTORS_DETECT = {\r\n            Point: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_3__[\"DetectTextLabelingStrategy\"],\r\n            MultiPoint: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_3__[\"DetectTextLabelingStrategy\"],\r\n            LineString: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_3__[\"DetectTextLabelingStrategy\"],\r\n            Circle: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_3__[\"DetectTextLabelingStrategy\"],\r\n            MultiLineString: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_3__[\"DetectTextLabelingStrategy\"],\r\n            Polygon: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_3__[\"DetectTextLabelingStrategy\"],\r\n            MultiPolygon: _detectTextLabelingStrategy__WEBPACK_IMPORTED_MODULE_3__[\"DetectTextLabelingStrategy\"]\r\n        };\r\n        _this.labelInfos = new ol.structs.LRUCache(512);\r\n        _this.charWidths = {};\r\n        if (styleJson) {\r\n            _this.align = styleJson[\"text-align\"];\r\n            _this.baseline = styleJson[\"text-base-line\"];\r\n            _this.dx = styleJson[\"text-dx\"];\r\n            _this.dy = styleJson[\"text-dy\"];\r\n            _this.font = styleJson[\"text-font\"];\r\n            _this.fill = styleJson[\"text-fill\"];\r\n            _this.forceHorizontalForLine = styleJson[\"text-force-horizontal-for-line\"];\r\n            _this.haloFill = styleJson[\"text-halo-fill\"];\r\n            _this.haloRadius = styleJson[\"text-halo-radius\"];\r\n            _this.margin = styleJson[\"text-margin\"];\r\n            _this.maskColor = styleJson[\"text-mask-color\"];\r\n            _this.maskMargin = styleJson[\"text-mask-margin\"];\r\n            _this.maskOutlineColor = styleJson[\"text-mask-outline-color\"];\r\n            _this.maskOutlineWidth = styleJson[\"text-mask-outline-width\"];\r\n            _this.maskType = styleJson[\"text-mask-type\"];\r\n            _this.maxCharAngle = styleJson[\"text-max-char-angle\"];\r\n            _this.minDistance = styleJson[\"text-min-distance\"];\r\n            _this.minPadding = styleJson[\"text-min-padding\"];\r\n            _this.name = styleJson[\"text-name\"];\r\n            _this.opacity = styleJson[\"text-opacity\"];\r\n            _this.rotateAngle = styleJson[\"text-rotate-angle\"];\r\n            _this.propertyPlacements = new _geoStyleProperty__WEBPACK_IMPORTED_MODULE_1__[\"GeoStyleProperty\"](styleJson[GeoTextStyle.placementsName], \"U,B,L,R\");\r\n            _this.placementType = styleJson[\"text-placement-type\"] ? styleJson[\"text-placement-type\"] : \"default\";\r\n            _this.spacing = styleJson[\"text-spacing\"] !== undefined ? styleJson[\"text-spacing\"] : 10;\r\n            _this.wrapBefore = styleJson[\"text-wrap-before\"] ? true : styleJson[\"text-wrap-before\"];\r\n            _this.wrapWidth = styleJson[\"text-wrap-width\"];\r\n            _this.textFormat = styleJson[\"text-text-format\"];\r\n            _this.dateFormat = styleJson[\"text-date-format\"];\r\n            _this.numericFormat = styleJson[\"text-numeric-format\"];\r\n            _this.textTransform = styleJson[\"text-letter-case\"];\r\n            _this.letterSpacing = styleJson[\"text-letter-spacing\"];\r\n            // TODO\r\n            _this.avoidEdge = styleJson[\"text-avoid-edge\"];\r\n            // TODO\r\n            _this.splineType = styleJson[\"text-spline-type\"];\r\n            // TODO\r\n            _this.polygonLabelingLocation = styleJson[\"text-polygon-labeling-location\"];\r\n            var chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n            for (var i = 0; i < chars.length; i++) {\r\n                _this.charWidths[chars[i]] = ol.render.canvas.measureTextWidth(_this.font, chars[i]);\r\n            }\r\n            _this.charWidths[\" \"] = ol.render.canvas.measureTextWidth(_this.font, \" \");\r\n            for (var i = 0; i <= 9; i++) {\r\n                _this.charWidths[i] = ol.render.canvas.measureTextWidth(_this.font, i);\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    GeoTextStyle.prototype.initializeCore = function () {\r\n        this.propertyPlacements.initialize();\r\n        this.placements = this.propertyPlacements.getValue();\r\n        if (this.fill) {\r\n            this.fillColor = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.fill, this.opacity);\r\n        }\r\n        if (this.haloFill) {\r\n            this.haloFillColor = _geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.haloFill, this.opacity);\r\n        }\r\n        var fill = new ol.style.Fill();\r\n        var stroke = new ol.style.Stroke();\r\n        var textStyle = new ol.style.Text({\r\n            fill: fill,\r\n            stroke: stroke\r\n        });\r\n        this.style = new ol.style.Style({\r\n            text: textStyle\r\n        });\r\n        if (this.textAligns.indexOf(this.align) >= 0) {\r\n            textStyle.setTextAlign(this.align);\r\n        }\r\n        if (this.textBaseline.indexOf(this.baseline) >= 0) {\r\n            textStyle.setTextBaseline(this.baseline);\r\n        }\r\n        if (this.dx) {\r\n            textStyle.setOffsetX(this.dx);\r\n        }\r\n        if (this.dy) {\r\n            textStyle.setOffsetY(this.dy);\r\n        }\r\n        if (this.font) {\r\n            textStyle.setFont(this.font);\r\n        }\r\n        if (this.fillColor) {\r\n            fill.setColor(this.fillColor);\r\n        }\r\n        if (this.haloFillColor) {\r\n            stroke.setColor(this.haloFillColor);\r\n        }\r\n        if (this.haloRadius) {\r\n            stroke.setWidth(this.haloRadius);\r\n        }\r\n        if (this.haloFillColor === undefined && this.haloRadius === undefined) {\r\n            textStyle.setStroke(undefined);\r\n        }\r\n        if (this.rotateAngle) {\r\n            textStyle.setRotation(this.rotateAngle);\r\n        }\r\n        if (this.maxCharAngle >= 0) {\r\n            textStyle.setMaxAngle(this.maxCharAngle);\r\n        }\r\n        if (this.textTransforms.includes(this.textTransform)) {\r\n        }\r\n        else {\r\n            // TODO: invalid inputs.\r\n            this.textTransform = this.textTransforms[0];\r\n        }\r\n    };\r\n    GeoTextStyle.prototype.getConvertedStyleCore = function (feature, resolution, options) {\r\n        var textStyles = [];\r\n        var featureText = \"\";\r\n        var featureProperties = feature.getProperties();\r\n        if (this.name) {\r\n            featureText = feature.get(this.name);\r\n        }\r\n        // A workaround for the language, remove the data update\r\n        if ((featureText === undefined || featureText === \"\") && this.name.indexOf(\"name_\") === 0) {\r\n            featureText = feature.get(\"name\");\r\n        }\r\n        if (this.numericFormat) {\r\n            featureText = this.getTextWithNumericFormat(featureText);\r\n        }\r\n        if (this.dateFormat) {\r\n            featureText = this.getTextWithDateFormat(featureText);\r\n        }\r\n        if (this.textFormat) {\r\n            featureText = this.getTextWithFormat(featureText);\r\n        }\r\n        if (featureText === undefined || featureText === \"\") {\r\n            return textStyles;\r\n        }\r\n        featureText = this.getTextTransform(featureText);\r\n        this.placements = this.propertyPlacements.getValue(featureProperties);\r\n        this.style.getText().setText(featureText);\r\n        if (this.setLabelPosition(featureText, feature, resolution, this.style.getText(), options.strategyTree, options.frameState)) {\r\n            var featureZindex = feature[\"tempTreeZindex\"];\r\n            if (featureZindex === undefined) {\r\n                featureZindex = 0;\r\n            }\r\n            this.style.setZIndex(featureZindex);\r\n            textStyles.push(this.style);\r\n        }\r\n        return textStyles;\r\n    };\r\n    GeoTextStyle.prototype.setLabelPosition = function (text, geometry, resolution, textState, strategyTree, frameState) {\r\n        var flatCoordinates;\r\n        var geometryType = geometry.getType();\r\n        if ((geometryType === ol.geom.GeometryType.LINE_STRING || geometryType === ol.geom.GeometryType.MULTI_LINE_STRING) && !this.forceHorizontalForLine) {\r\n            var geometryType_1 = geometry.getType();\r\n            flatCoordinates = geometry.getFlatCoordinates();\r\n            if (flatCoordinates === undefined) {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            var labelInfo = this.getLabelInfo(text, textState);\r\n            var labelWidth = labelInfo.labelWidth;\r\n            var labelHeight = labelInfo.labelHeight;\r\n            var scale = labelInfo.scale;\r\n            var font = labelInfo.font;\r\n            var strokeWidth = labelInfo.strokeWidth;\r\n            var numLines = labelInfo.numLines;\r\n            var lines = labelInfo.lines;\r\n            var lineHeight = labelInfo.lineHeight;\r\n            var renderWidth = labelInfo.renderWidth;\r\n            var height = labelInfo.height;\r\n            var widths = labelInfo.widths;\r\n            var Constructor = void 0;\r\n            if (this.placementType === \"default\") {\r\n                Constructor = this.BATCH_CONSTRUCTORS_DEFAULT[geometryType];\r\n            }\r\n            else if (this.placementType === \"detect\") {\r\n                Constructor = this.BATCH_CONSTRUCTORS_DETECT[geometryType];\r\n            }\r\n            var textLabelingStrategy = new Constructor();\r\n            var tmpLabelWidth = labelWidth / window.devicePixelRatio;\r\n            var tmpLabelHeight = labelHeight / window.devicePixelRatio;\r\n            switch (geometryType) {\r\n                case ol.geom.GeometryType.POINT:\r\n                    flatCoordinates = geometry.getFlatCoordinates();\r\n                    break;\r\n                case ol.geom.GeometryType.MULTI_POINT:\r\n                    flatCoordinates = geometry.getCenter();\r\n                    break;\r\n                case ol.geom.GeometryType.LINE_STRING:\r\n                    flatCoordinates = /** @type {ol.geom.LineString} */ (geometry).getFlatMidpoint();\r\n                    break;\r\n                case ol.geom.GeometryType.CIRCLE:\r\n                    flatCoordinates = /** @type {ol.geom.Circle} */ (geometry).getCenter();\r\n                    break;\r\n                case ol.geom.GeometryType.MULTI_LINE_STRING:\r\n                    flatCoordinates = /** @type {ol.geom.MultiLineString} */ (geometry).getFlatMidpoints();\r\n                    break;\r\n                case ol.geom.GeometryType.POLYGON:\r\n                    flatCoordinates = /** @type {ol.geom.Polygon} */ (geometry).getFlatInteriorPoint();\r\n                    break;\r\n                case ol.geom.GeometryType.MULTI_POLYGON:\r\n                    var interiorPoints = /** @type {ol.geom.MultiPolygon} */ (geometry).getFlatMidpoint();\r\n                    break;\r\n                default:\r\n            }\r\n            flatCoordinates = textLabelingStrategy.markLocation(flatCoordinates, tmpLabelWidth, tmpLabelHeight, resolution, geometryType, this, strategyTree, frameState);\r\n            if (flatCoordinates === undefined) {\r\n                return false;\r\n            }\r\n            var labelImage = this.getImage(textState, labelWidth, labelHeight, scale, font, strokeWidth, numLines, lines, lineHeight, renderWidth, height, widths);\r\n            if (labelImage === undefined) {\r\n                return;\r\n            }\r\n            textState.label = labelImage;\r\n        }\r\n        textState.labelPosition = flatCoordinates;\r\n        return true;\r\n    };\r\n    GeoTextStyle.prototype.getLabelInfo = function (text, textState) {\r\n        var key = text + this.uid;\r\n        if (!this.labelInfos.containsKey(key)) {\r\n            var font = textState.getFont();\r\n            text = this.wrapText(text, font);\r\n            var strokeState = textState.getStroke();\r\n            var strokeWidth = strokeState && strokeState.getWidth() ? strokeState.getWidth() : 0;\r\n            var lines = text.split(\"\\n\");\r\n            var numLines = lines.length;\r\n            var textScale = textState.getScale();\r\n            textScale = textScale === undefined ? 1 : textScale;\r\n            var scale = textScale * window.devicePixelRatio;\r\n            var widths = [];\r\n            var width = this.getEstimatedWidth(font, lines, widths, this.letterSpacing);\r\n            var lineHeight = ol.render.canvas.measureTextHeight(font);\r\n            var tmpMaskMargin = (this.maskMargin ? this.maskMargin : \"0\").split(',');\r\n            var tmpMaskHeightMargin = 0;\r\n            var tmpMaskWidthMargin = 0;\r\n            switch (tmpMaskMargin.length) {\r\n                case 1:\r\n                    tmpMaskHeightMargin = parseInt(tmpMaskMargin[0]) * 2;\r\n                    tmpMaskWidthMargin = parseInt(tmpMaskMargin[0]) * 2;\r\n                    break;\r\n                case 2:\r\n                    tmpMaskHeightMargin = parseInt(tmpMaskMargin[0]) * 2;\r\n                    tmpMaskWidthMargin = parseInt(tmpMaskMargin[1]) * 2;\r\n                    break;\r\n                case 3:\r\n                    tmpMaskHeightMargin = parseInt(tmpMaskMargin[0]) + parseInt(tmpMaskMargin[2]);\r\n                    tmpMaskWidthMargin = parseInt(tmpMaskMargin[1]) * 2;\r\n                    break;\r\n                case 4:\r\n                    tmpMaskHeightMargin = parseInt(tmpMaskMargin[0]) + parseInt(tmpMaskMargin[2]);\r\n                    tmpMaskWidthMargin = parseInt(tmpMaskMargin[1]) + parseInt(tmpMaskMargin[3]);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            if (this.maskType) {\r\n                if (this.maskType.toLowerCase() === \"circle\") {\r\n                    tmpMaskHeightMargin = tmpMaskHeightMargin > tmpMaskWidthMargin ? tmpMaskHeightMargin : tmpMaskWidthMargin;\r\n                    tmpMaskWidthMargin = tmpMaskHeightMargin;\r\n                }\r\n            }\r\n            var height = lineHeight * numLines + strokeWidth + tmpMaskHeightMargin;\r\n            var renderWidth = width + strokeWidth + tmpMaskWidthMargin;\r\n            var tmpMaskOutlineWidth = (this.maskOutlineWidth ? this.maskOutlineWidth : 0);\r\n            var labelWidth = Math.ceil((renderWidth + tmpMaskOutlineWidth * 3) * 1.1 * scale);\r\n            var labelHeight = Math.ceil((height + tmpMaskOutlineWidth * 3) * 1.1 * scale);\r\n            var labelInfo = {\r\n                labelWidth: labelWidth,\r\n                labelHeight: labelHeight,\r\n                scale: scale,\r\n                font: font,\r\n                strokeWidth: strokeWidth,\r\n                numLines: numLines,\r\n                lines: lines,\r\n                lineHeight: lineHeight,\r\n                renderWidth: renderWidth,\r\n                height: height,\r\n                widths: widths\r\n            };\r\n            this.labelInfos.set(key, labelInfo);\r\n        }\r\n        return this.labelInfos.get(key);\r\n    };\r\n    GeoTextStyle.prototype.getEstimatedWidth = function (font, lines, widths, letterSpacing) {\r\n        var numLines = lines.length;\r\n        var width = 0;\r\n        var currentWidth, i;\r\n        for (i = 0; i < numLines; ++i) {\r\n            currentWidth = 0;\r\n            for (var j = 0; j < lines[i].length; j++) {\r\n                var charWidth = this.charWidths[lines[i][j]];\r\n                if (charWidth) {\r\n                    currentWidth += charWidth;\r\n                }\r\n                else {\r\n                    currentWidth += this.charWidths[\"W\"];\r\n                }\r\n            }\r\n            if (letterSpacing) {\r\n                currentWidth = currentWidth + (lines[i].length - 1) * letterSpacing;\r\n            }\r\n            width = Math.max(width, currentWidth);\r\n            widths.push(currentWidth);\r\n        }\r\n        return width;\r\n    };\r\n    GeoTextStyle.prototype.getImage = function (textState, labelWidth, labelHeight, scale, font, strokeWidth, numLines, lines, lineHeight, renderWidth, height, widths) {\r\n        var labelCache = ol.render.canvas.labelCache;\r\n        var key = this.uid !== undefined ? this.uid : ol.getUid(this);\r\n        key += lines.toString();\r\n        if (!labelCache.containsKey(key)) {\r\n            var fillState = textState.getFill();\r\n            var strokeState = textState.getStroke();\r\n            var label = void 0;\r\n            var align = ol.render.replay.TEXT_ALIGN[textState.getTextAlign() || ol.render.canvas.defaultTextAlign];\r\n            var context = ol.dom.createCanvasContext2D(labelWidth, labelHeight);\r\n            label = context.canvas;\r\n            labelCache.set(key, label);\r\n            label.style.display = \"none\";\r\n            // For letterSpacing we need app\r\n            var body = void 0;\r\n            if (this.letterSpacing) {\r\n                body = document.getElementsByTagName(\"body\")[0];\r\n                if (body) {\r\n                    label.style.display = \"none\";\r\n                    body.appendChild(label);\r\n                }\r\n                label.style.letterSpacing = this.letterSpacing + \"px\";\r\n                context = label.getContext(\"2d\");\r\n            }\r\n            if (scale !== 1) {\r\n                context.scale(scale, scale);\r\n            }\r\n            context.font = font;\r\n            if (strokeState) {\r\n                context.strokeStyle = strokeState.getColor();\r\n                context.lineWidth = strokeWidth * (ol.has.SAFARI ? scale : 1);\r\n                context.lineCap = strokeState.getLineCap();\r\n                context.lineJoin = strokeState.getLineJoin();\r\n                context.miterLimit = strokeState.getMiterLimit();\r\n                var lineDash = strokeState.getLineDash();\r\n                lineDash = lineDash ? lineDash.slice() : ol.render.canvas.defaultLineDash;\r\n                if (ol.has.CANVAS_LINE_DASH && lineDash.length) {\r\n                    context.setLineDash(strokeState.getLineDash());\r\n                    context.lineDashOffset = strokeState.getLineDashOffset();\r\n                }\r\n            }\r\n            this.drawMask(context, 0, 0, renderWidth, height);\r\n            if (this.maskType) {\r\n                if (this.maskType.toLowerCase() === \"circle\") {\r\n                    if (scale !== 1) {\r\n                        context.scale(scale, scale);\r\n                    }\r\n                    context.font = font;\r\n                    if (strokeState) {\r\n                        context.strokeStyle = strokeState.getColor();\r\n                        context.lineWidth = strokeWidth * (ol.has.SAFARI ? scale : 1);\r\n                        context.lineCap = strokeState.getLineCap();\r\n                        context.lineJoin = strokeState.getLineJoin();\r\n                        context.miterLimit = strokeState.getMiterLimit();\r\n                        var lineDash = strokeState.getLineDash();\r\n                        lineDash = lineDash ? lineDash.slice() : ol.render.canvas.defaultLineDash;\r\n                        if (ol.has.CANVAS_LINE_DASH && lineDash.length) {\r\n                            context.setLineDash(strokeState.getLineDash());\r\n                            context.lineDashOffset = strokeState.getLineDashOffset();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            context.textBaseline = \"middle\";\r\n            context.textAlign = \"center\";\r\n            var leftRight = 0.5 - align;\r\n            var x = align * label.width / scale + leftRight * strokeWidth;\r\n            var i = void 0;\r\n            var tmpMaskMargin = (this.maskMargin ? this.maskMargin : \"0\").split(',');\r\n            var tmpMaskOutlineWidth = this.maskOutlineWidth ? this.maskOutlineWidth : 0;\r\n            if (strokeState) {\r\n                if (strokeState.getColor() !== null) {\r\n                    context.strokeStyle = strokeState.getColor();\r\n                    context.lineWidth = this.haloRadius ? this.haloRadius : 0;\r\n                    for (i = 0; i < numLines; ++i) {\r\n                        if (this.drawnMask) {\r\n                            context.strokeText(lines[i], x + leftRight * widths[i] * 1.2 - strokeWidth * 1.2 + tmpMaskOutlineWidth * 0.5 / 1.2 - (tmpMaskMargin[3] ? parseInt(tmpMaskMargin[1]) - parseInt(tmpMaskMargin[3]) : 0) * 0.5, this.maskType.toLowerCase() === \"circle\" ? context.canvas.height / scale * 0.5 - (tmpMaskMargin[2] ? parseInt(tmpMaskMargin[2]) - parseInt(tmpMaskMargin[0]) : 0) : strokeWidth + (i + 1) * lineHeight * 0.5 + parseInt(tmpMaskMargin[0]) + tmpMaskOutlineWidth);\r\n                        }\r\n                        else {\r\n                            context.strokeText(lines[i], x + leftRight * widths[i] * 1.2 - (tmpMaskMargin[3] ? parseInt(tmpMaskMargin[1]) - parseInt(tmpMaskMargin[3]) : 0) * 0.5, 0.5 * (strokeWidth + lineHeight) + i * lineHeight * 1.2 - +parseInt(tmpMaskMargin[0]) + (this.maskOutlineWidth ? this.maskOutlineWidth : 0));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (fillState) {\r\n                if (fillState.getColor() !== null) {\r\n                    context.fillStyle = fillState.getColor();\r\n                    for (i = 0; i < numLines; ++i) {\r\n                        if (this.drawnMask) {\r\n                            context.fillText(lines[i], x + leftRight * widths[i] * 1.2 - strokeWidth * 1.2 + tmpMaskOutlineWidth * 0.5 / 1.2 - (tmpMaskMargin[3] ? parseInt(tmpMaskMargin[1]) - parseInt(tmpMaskMargin[3]) : 0) * 0.5, this.maskType.toLowerCase() === \"circle\" ? context.canvas.height / scale * 0.5 - (tmpMaskMargin[2] ? parseInt(tmpMaskMargin[2]) - parseInt(tmpMaskMargin[0]) : 0) : strokeWidth + (i + 1) * lineHeight * 0.5 + parseInt(tmpMaskMargin[0]) + tmpMaskOutlineWidth);\r\n                        }\r\n                        else {\r\n                            context.fillText(lines[i], x + leftRight * widths[i] * 1.2 - (tmpMaskMargin[3] ? parseInt(tmpMaskMargin[1]) - parseInt(tmpMaskMargin[3]) : 0) * 0.5, 0.5 * (strokeWidth + lineHeight) + i * lineHeight * 1.2 + parseInt(tmpMaskMargin[0]) + (this.maskOutlineWidth ? this.maskOutlineWidth : 0));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (this.letterSpacing && body) {\r\n                body.removeChild(label);\r\n            }\r\n        }\r\n        return labelCache.get(key);\r\n    };\r\n    GeoTextStyle.prototype.wrapText = function (text, font) {\r\n        var resultText;\r\n        if (text !== \"\") {\r\n            var lines = [text];\r\n            var widths = [];\r\n            var width = this.getEstimatedWidth(font, lines, widths, this.letterSpacing);\r\n            var wrapWidth = this.wrapWidth;\r\n            var wrapCharacter = \" \";\r\n            var isWrapBefore = this.wrapBefore;\r\n            if (wrapWidth > 0 && width > wrapWidth && text.includes(wrapCharacter)) {\r\n                var textLines = [];\r\n                lines = text.split(wrapCharacter);\r\n                var wrapLines = [];\r\n                var wrapWidthSum = 0;\r\n                var tmpWrapWidth = void 0;\r\n                if (isWrapBefore) {\r\n                    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\r\n                        var line = lines_1[_i];\r\n                        var tmpLine = [line];\r\n                        tmpWrapWidth = this.getEstimatedWidth(font, tmpLine, widths, this.letterSpacing);\r\n                        wrapWidthSum += tmpWrapWidth;\r\n                        if (tmpWrapWidth > wrapWidth) {\r\n                            wrapLines = [];\r\n                            textLines = [];\r\n                            wrapWidthSum = 0;\r\n                            break;\r\n                        }\r\n                        if (wrapLines.length > 0) {\r\n                            if (wrapWidthSum > wrapWidth) {\r\n                                wrapLines.push(\"\\n\");\r\n                                textLines.push(wrapLines.join(\"\"));\r\n                                wrapLines = [];\r\n                                wrapWidthSum = 0;\r\n                            }\r\n                        }\r\n                        wrapLines.push(\" \" + line);\r\n                    }\r\n                    if (wrapLines.length > 0) {\r\n                        textLines.push(wrapLines.join(\"\"));\r\n                    }\r\n                }\r\n                else {\r\n                    for (var _a = 0, lines_2 = lines; _a < lines_2.length; _a++) {\r\n                        var line = lines_2[_a];\r\n                        wrapLines.push(\" \" + line);\r\n                        var tmpLine = [line];\r\n                        tmpWrapWidth = this.getEstimatedWidth(font, tmpLine, widths, this.letterSpacing);\r\n                        wrapWidthSum += tmpWrapWidth;\r\n                        if (wrapWidthSum > wrapWidth) {\r\n                            wrapLines.push(\"\\n\");\r\n                            textLines.push(wrapLines.join(\"\"));\r\n                            wrapLines = [];\r\n                            wrapWidthSum = 0;\r\n                        }\r\n                    }\r\n                    if (wrapLines.length > 0) {\r\n                        textLines.push(wrapLines.join(\"\"));\r\n                    }\r\n                }\r\n                resultText = textLines.join(\"\");\r\n                if (resultText.lastIndexOf(\"\\n\") === resultText.length - 1) {\r\n                    resultText = resultText.substr(0, resultText.length - 1);\r\n                }\r\n            }\r\n            else {\r\n                resultText = text;\r\n            }\r\n        }\r\n        return resultText;\r\n    };\r\n    GeoTextStyle.prototype.drawMask = function (context, x, y, width, height) {\r\n        var fill = undefined;\r\n        var stroke = undefined;\r\n        if (this.maskColor) {\r\n            fill = new ol.style.Fill();\r\n            fill.setColor(_geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.maskColor, this.opacity ? this.opacity : 1));\r\n        }\r\n        if (this.maskOutlineColor && this.maskOutlineWidth) {\r\n            stroke = new ol.style.Stroke();\r\n            if (this.maskOutlineColor) {\r\n                stroke.setColor(_geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"].toRGBAColor(this.maskOutlineColor, this.opacity ? this.opacity : 1));\r\n            }\r\n            if (this.maskOutlineWidth) {\r\n                stroke.setWidth(this.maskOutlineWidth ? this.maskOutlineWidth : 0);\r\n            }\r\n        }\r\n        if (this.maskType) {\r\n            this.drawnMask = true;\r\n        }\r\n        else {\r\n            this.drawnMask = false;\r\n        }\r\n        switch (this.maskType) {\r\n            case \"default\":\r\n            case \"Default\":\r\n            case \"rectangle\":\r\n            case \"Rectangle\":\r\n                this.drawRectangle(context, x, y, width, height, fill, stroke);\r\n                break;\r\n            case \"roundedCorners\":\r\n            case \"RoundedCorners\":\r\n                this.drawRoundRectangle(context, x, y, width, height, fill, stroke);\r\n                break;\r\n            case \"roundedEnds\":\r\n            case \"RoundedEnds\":\r\n                this.drawRoundedEnds(context, x, y, width, height, fill, stroke);\r\n                break;\r\n            case \"circle\":\r\n            case \"Circle\":\r\n                this.drawCircle(context, x, y, width, height, fill, stroke);\r\n                break;\r\n        }\r\n    };\r\n    GeoTextStyle.prototype.drawRectangle = function (context, x, y, width, height, fill, stroke) {\r\n        if (fill) {\r\n            context.fillStyle = fill.getColor();\r\n            context.fillRect(x + stroke.getWidth(), y + stroke.getWidth(), width + stroke.getWidth() * 2, height);\r\n        }\r\n        if (stroke) {\r\n            context.lineWidth = stroke.getWidth();\r\n            context.strokeStyle = stroke.getColor();\r\n            context.strokeRect(x + stroke.getWidth(), y + stroke.getWidth(), width + stroke.getWidth() * 2, height);\r\n        }\r\n    };\r\n    GeoTextStyle.prototype.drawRoundRectangle = function (context, x, y, width, height, fill, stroke) {\r\n        var radius = (width < height ? width : height) * 0.3;\r\n        // width *= 0.9;\r\n        // height *= 0.8;\r\n        if (stroke) {\r\n            x = x + (stroke.getWidth() ? stroke.getWidth() : 0);\r\n            y = y + (stroke.getWidth() ? stroke.getWidth() : 0);\r\n        }\r\n        context.beginPath();\r\n        context.moveTo(x + radius + stroke.getWidth() * 2, y);\r\n        context.lineTo(x + width - radius + stroke.getWidth() * 2, y);\r\n        context.quadraticCurveTo(x + width + stroke.getWidth() * 2, y, x + width + stroke.getWidth() * 2, y + radius);\r\n        context.lineTo(x + width + stroke.getWidth() * 2, y + height - radius);\r\n        context.quadraticCurveTo(x + width + stroke.getWidth() * 2, y + height, x + width - radius + stroke.getWidth() * 2, y + height);\r\n        context.lineTo(x + radius, y + height);\r\n        context.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n        context.lineTo(x, y + radius);\r\n        context.quadraticCurveTo(x, y, x + radius, y);\r\n        context.closePath();\r\n        if (fill) {\r\n            context.fillStyle = fill.getColor();\r\n            context.fill();\r\n        }\r\n        if (stroke) {\r\n            context.lineWidth = stroke.getWidth();\r\n            context.strokeStyle = stroke.getColor();\r\n            context.stroke();\r\n        }\r\n    };\r\n    GeoTextStyle.prototype.drawRoundedEnds = function (context, x, y, width, height, fill, stroke) {\r\n        var radius = (width < height ? width : height) * 0.2;\r\n        // width *= 0.9;\r\n        // height *= 0.8;\r\n        var strokeWidth = (stroke.getWidth() ? stroke.getWidth() : 0);\r\n        if (stroke) {\r\n            x = x + strokeWidth;\r\n            y = y + strokeWidth;\r\n        }\r\n        context.beginPath();\r\n        context.moveTo(x + radius, y);\r\n        context.lineTo(x + width - radius + strokeWidth * 2, y);\r\n        context.quadraticCurveTo(x + width + strokeWidth * 2, y + height * 0.5, x + width - radius + strokeWidth * 2, y + height);\r\n        context.lineTo(x + radius, y + height);\r\n        context.quadraticCurveTo(x, y + height * 0.5, x + radius, y);\r\n        context.closePath();\r\n        if (fill) {\r\n            context.fillStyle = fill.getColor();\r\n            context.fill();\r\n        }\r\n        if (stroke) {\r\n            context.lineWidth = stroke.getWidth();\r\n            context.strokeStyle = stroke.getColor();\r\n            context.stroke();\r\n        }\r\n    };\r\n    GeoTextStyle.prototype.drawCircle = function (context, x, y, width, height, fill, stroke) {\r\n        context.canvas.width = context.canvas.width > context.canvas.height ? context.canvas.width : context.canvas.height;\r\n        context.canvas.height = context.canvas.width;\r\n        var radius = 0;\r\n        if (stroke) {\r\n            radius -= stroke.getWidth();\r\n        }\r\n        radius += context.canvas.width * 0.5;\r\n        context.beginPath();\r\n        context.arc(x + context.canvas.width * 0.5, y + context.canvas.width * 0.5, radius, 0, 2 * Math.PI, false);\r\n        context.closePath();\r\n        if (fill) {\r\n            context.fillStyle = fill.getColor();\r\n            context.fill();\r\n        }\r\n        if (stroke) {\r\n            context.lineWidth = stroke.getWidth() * window.devicePixelRatio;\r\n            context.strokeStyle = stroke.getColor();\r\n            context.stroke();\r\n        }\r\n    };\r\n    GeoTextStyle.prototype.getTextWithNumericFormat = function (featureText) {\r\n        var tmpArguments = this.numericFormat.split(\",\");\r\n        var numericFormatOptions = {};\r\n        for (var _i = 0, tmpArguments_1 = tmpArguments; _i < tmpArguments_1.length; _i++) {\r\n            var tmpArgument = tmpArguments_1[_i];\r\n            var keyValuePair = tmpArgument.split(\":\");\r\n            switch (keyValuePair[0].trim()) {\r\n                case \"localeMatcher\":\r\n                    numericFormatOptions.localeMatcher = keyValuePair[1].trim();\r\n                    break;\r\n                case \"style\":\r\n                    numericFormatOptions.style = keyValuePair[1].trim();\r\n                    break;\r\n                case \"currency\":\r\n                    numericFormatOptions.currency = keyValuePair[1].trim();\r\n                    break;\r\n                case \"currencyDisplay\":\r\n                    numericFormatOptions.currencyDisplay = keyValuePair[1].trim();\r\n                    break;\r\n                case \"useGrouping\":\r\n                    numericFormatOptions.useGrouping = keyValuePair[1].trim();\r\n                    break;\r\n                case \"minimumIntegerDigits\":\r\n                    numericFormatOptions.minimumIntegerDigits = keyValuePair[1].trim();\r\n                    break;\r\n                case \"minimumFractionDigits\":\r\n                    numericFormatOptions.minimumFractionDigits = keyValuePair[1].trim();\r\n                    break;\r\n                case \"maximumFractionDigits\":\r\n                    numericFormatOptions.maximumFractionDigits = keyValuePair[1].trim();\r\n                    break;\r\n                case \"minimumSignificantDigits\":\r\n                    numericFormatOptions.minimumSignificantDigits = keyValuePair[1].trim();\r\n                    break;\r\n                case \"maximumSignificantDigits\":\r\n                    numericFormatOptions.maximumSignificantDigits = keyValuePair[1].trim();\r\n                    break;\r\n            }\r\n        }\r\n        var numeric = new Intl.NumberFormat(tmpArguments[0], numericFormatOptions);\r\n        return numeric.format(Number(featureText));\r\n    };\r\n    GeoTextStyle.prototype.getTextWithDateFormat = function (featureText) {\r\n        return (new Date(featureText)).format(this.dateFormat);\r\n    };\r\n    GeoTextStyle.prototype.getTextWithFormat = function (featureText) {\r\n        return String.format(this.textFormat, featureText);\r\n    };\r\n    GeoTextStyle.prototype.getTextTransform = function (featureText) {\r\n        if (featureText !== undefined) {\r\n            switch (this.textTransform) {\r\n                case \"uppercase\":\r\n                    featureText = featureText.toLocaleUpperCase();\r\n                    break;\r\n                case \"lowercase\":\r\n                    featureText = featureText.toLocaleLowerCase();\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n        return featureText;\r\n    };\r\n    GeoTextStyle.placementsName = \"text-placements\";\r\n    return GeoTextStyle;\r\n}(_geoStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoStyle\"]));\r\n\r\nString.format = function () {\r\n    var s = arguments[0];\r\n    for (var i = 0; i < arguments.length - 1; i++) {\r\n        var reg = new RegExp(\"\\\\{\" + i + \"\\\\}\", \"gm\");\r\n        s = s.replace(reg, arguments[i + 1]);\r\n    }\r\n    return s;\r\n};\r\nDate.prototype.format = function (fmt) {\r\n    var o = {\r\n        \"M+\": this.getMonth() + 1,\r\n        \"d+\": this.getDate(),\r\n        \"h+\": this.getHours(),\r\n        \"m+\": this.getMinutes(),\r\n        \"s+\": this.getSeconds(),\r\n        \"q+\": Math.floor((this.getMonth() + 3) / 3),\r\n        \"S\": this.getMilliseconds()\r\n    };\r\n    if (/(y+)/.test(fmt))\r\n        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\r\n    for (var k in o)\r\n        if (new RegExp(\"(\" + k + \")\").test(fmt))\r\n            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\r\n    return fmt;\r\n};\r\n\n\n//# sourceURL=webpack:///./src/style/geoTextStyle.ts?");

/***/ }),

/***/ "./src/style/textLabelingStrategy.ts":
/*!*******************************************!*\
  !*** ./src/style/textLabelingStrategy.ts ***!
  \*******************************************/
/*! exports provided: TextLabelingStrategy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextLabelingStrategy\", function() { return TextLabelingStrategy; });\nvar TextLabelingStrategy = /** @class */ (function () {\r\n    function TextLabelingStrategy() {\r\n    }\r\n    TextLabelingStrategy.prototype.markLocation = function (flatCoordinates, width, height, resolution, geometryType, textStyle, strategyTree, frameState) {\r\n        return this.markLocationCore(flatCoordinates, width, height, resolution, geometryType, textStyle, strategyTree, frameState);\r\n    };\r\n    TextLabelingStrategy.prototype.markLocationCore = function (flatCoordinates, width, height, resolution, geometryType, textStyle, strategyTree, frameState) {\r\n        if (this.isOverlapping(flatCoordinates, width, height, textStyle.margin, textStyle.minDistance, textStyle.minPadding, textStyle.spacing, strategyTree, frameState)) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            return flatCoordinates;\r\n        }\r\n    };\r\n    TextLabelingStrategy.prototype.isOverlapping = function (flatCoordinates, width, height, margin, minDistance, minPadding, spacing, strategyTree, frameState) {\r\n        if (flatCoordinates === undefined) {\r\n            return true;\r\n        }\r\n        var distance = (margin ? margin : 0) + (minDistance ? minDistance : 0) + (minPadding ? minPadding : 0) + (spacing ? spacing : 0);\r\n        var coordinate = [flatCoordinates[0], flatCoordinates[1]];\r\n        var screenCoordinates = this.convertPixelFromCoordinate(coordinate, frameState);\r\n        var minX = screenCoordinates[0] - width / 2 - distance * 0.5;\r\n        var minY = screenCoordinates[1] - height / 2 - distance * 0.5;\r\n        var maxX = minX + width + distance;\r\n        var maxY = minY + height + distance;\r\n        var box = {\r\n            minX: minX,\r\n            minY: minY,\r\n            maxX: maxX,\r\n            maxY: maxY\r\n        };\r\n        if (!strategyTree.collides(box)) {\r\n            strategyTree.insert(box);\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    };\r\n    TextLabelingStrategy.prototype.convertPixelFromCoordinate = function (coordinate, frameState) {\r\n        if (!frameState) {\r\n            return null;\r\n        }\r\n        return ol.transform.apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\r\n    };\r\n    return TextLabelingStrategy;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack:///./src/style/textLabelingStrategy.ts?");

/***/ }),

/***/ "./src/tree/TreeNode.ts":
/*!******************************!*\
  !*** ./src/tree/TreeNode.ts ***!
  \******************************/
/*! exports provided: TreeNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreeNode\", function() { return TreeNode; });\nvar TreeNode = /** @class */ (function () {\r\n    function TreeNode(data) {\r\n        this.data = data;\r\n        this.children = [];\r\n    }\r\n    return TreeNode;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack:///./src/tree/TreeNode.ts?");

/***/ }),

/***/ "./src/tree/styleJsonCache.ts":
/*!************************************!*\
  !*** ./src/tree/styleJsonCache.ts ***!
  \************************************/
/*! exports provided: StyleJsonCache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StyleJsonCache\", function() { return StyleJsonCache; });\n/* harmony import */ var _style_geoTextStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../style/geoTextStyle */ \"./src/style/geoTextStyle.ts\");\n\r\nvar StyleJsonCache = /** @class */ (function () {\r\n    function StyleJsonCache() {\r\n        this.geoStyleGroupByZoom = [];\r\n        this.styleJson = {};\r\n        this.geoStyles = {};\r\n        this.geoTextStyleInfo = {};\r\n    }\r\n    StyleJsonCache.prototype.add = function (zoom, dataLayerName, tree) {\r\n        if (this.geoStyleGroupByZoom[zoom] === undefined) {\r\n            this.geoStyleGroupByZoom[zoom] = {};\r\n        }\r\n        if (this.geoStyleGroupByZoom[zoom] === undefined) {\r\n            this.geoStyleGroupByZoom[zoom] = {};\r\n        }\r\n        if (this.geoStyleGroupByZoom[zoom][dataLayerName] === undefined) {\r\n            this.geoStyleGroupByZoom[zoom][dataLayerName] = [];\r\n        }\r\n        this.geoStyleGroupByZoom[zoom][dataLayerName].push(tree);\r\n        this.readGeoStyleFromTree(tree);\r\n    };\r\n    StyleJsonCache.prototype.readGeoStyleFromTree = function (tree) {\r\n        return this.readGeoStyleFromTreeNode(tree.root);\r\n    };\r\n    StyleJsonCache.prototype.readGeoStyleFromTreeNode = function (node) {\r\n        var result = [];\r\n        if (node.data.geoStyle) {\r\n            this.geoStyles[node.data.geoStyle.id] = node.data.geoStyle;\r\n            // get the widths of GeoTextStyle\r\n            if (node.data.geoStyle instanceof _style_geoTextStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoTextStyle\"]) {\r\n                this.geoTextStyleInfo[node.data.geoStyle.id] = node.data.geoStyle.charWidths;\r\n            }\r\n        }\r\n        if (node.data.childrenGeoStyles && node.data.childrenGeoStyles.length > 0) {\r\n            for (var i = 0; i < node.data.childrenGeoStyles.length; i++) {\r\n                this.geoStyles[node.data.childrenGeoStyles[i].id] = node.data.childrenGeoStyles[i];\r\n                if (node.data.childrenGeoStyles[i] instanceof _style_geoTextStyle__WEBPACK_IMPORTED_MODULE_0__[\"GeoTextStyle\"]) {\r\n                    this.geoTextStyleInfo[node.data.childrenGeoStyles[i].id] = node.data.childrenGeoStyles[i];\r\n                }\r\n            }\r\n        }\r\n        if (node.children && node.children.length > 0) {\r\n            for (var i = 0; i < node.children.length; i++) {\r\n                this.readGeoStyleFromTreeNode(node.children[i]);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    StyleJsonCache.prototype.clear = function () {\r\n        this.geoStyleGroupByZoom.length = 0;\r\n    };\r\n    return StyleJsonCache;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack:///./src/tree/styleJsonCache.ts?");

/***/ }),

/***/ "./src/tree/styleJsonCacheItem.ts":
/*!****************************************!*\
  !*** ./src/tree/styleJsonCacheItem.ts ***!
  \****************************************/
/*! exports provided: StyleJsonCacheItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StyleJsonCacheItem\", function() { return StyleJsonCacheItem; });\n/* harmony import */ var _filter_geoFilterItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filter/geoFilterItem */ \"./src/filter/geoFilterItem.ts\");\n/* harmony import */ var _filter_geoZoomFilter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../filter/geoZoomFilter */ \"./src/filter/geoZoomFilter.ts\");\n/* harmony import */ var _filter_geoStringAttributeFilter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../filter/geoStringAttributeFilter */ \"./src/filter/geoStringAttributeFilter.ts\");\n/* harmony import */ var _filter_geoRegexFilter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../filter/geoRegexFilter */ \"./src/filter/geoRegexFilter.ts\");\n/* harmony import */ var _filter_geoNumberAttributeFilter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../filter/geoNumberAttributeFilter */ \"./src/filter/geoNumberAttributeFilter.ts\");\n/* harmony import */ var _style_geoAreaStyle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style/geoAreaStyle */ \"./src/style/geoAreaStyle.ts\");\n/* harmony import */ var _style_geoLineStyle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../style/geoLineStyle */ \"./src/style/geoLineStyle.ts\");\n/* harmony import */ var _style_geoPointStyle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../style/geoPointStyle */ \"./src/style/geoPointStyle.ts\");\n/* harmony import */ var _style_geoTextStyle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../style/geoTextStyle */ \"./src/style/geoTextStyle.ts\");\n/* harmony import */ var _style_geoShieldStyle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../style/geoShieldStyle */ \"./src/style/geoShieldStyle.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar StyleJsonCacheItem = /** @class */ (function () {\r\n    function StyleJsonCacheItem(styleJson, minZoom, maxZoom, dataLayerColumnName) {\r\n        this.childrenGeoStyles = [];\r\n        this.subStyleCacheItems = [];\r\n        this.minZoom = minZoom;\r\n        this.maxZoom = maxZoom;\r\n        this.zIndex = styleJson[\"z-index\"];\r\n        this.styleFirst = styleJson[\"style-first\"];\r\n        this.filterGroup = this.createFilters(styleJson.filter, dataLayerColumnName) || [];\r\n        this.createSubItems(styleJson, dataLayerColumnName);\r\n        this.geoStyle = this.createGeoStyle(styleJson);\r\n        this.createChildrenGeoStyle(styleJson);\r\n    }\r\n    StyleJsonCacheItem.prototype.createFilters = function (filterString, dataLayerColumnName) {\r\n        var filterGroup = [];\r\n        var tempMinZoom = this.maxZoom;\r\n        var tempMaxZoom = this.minZoom;\r\n        if (filterString) {\r\n            var filterStrings = filterString.split(\"|\");\r\n            for (var i = 0; i < filterStrings.length; i++) {\r\n                var filterStr = filterStrings[i];\r\n                var expression = \"(\\\\w+?=~'.+?')|(\\\\w+?[<>!=]*'[^;]+?')|(\\\\w+?[<>!=]*[^;]+)\";\r\n                var regex = new RegExp(expression, \"g\");\r\n                var results = filterStr.match(regex);\r\n                var rangeFilters = {};\r\n                var filters = [];\r\n                var geoZoomFilter = void 0;\r\n                var dataLayerNameFilter = void 0;\r\n                for (var i_1 = 0; i_1 < results.length; i_1++) {\r\n                    if (results[i_1]) {\r\n                        var filterItem = _filter_geoFilterItem__WEBPACK_IMPORTED_MODULE_0__[\"GeoFilterItem\"].createFilterItem(results[i_1]);\r\n                        if (filterItem.value.indexOf(\"~'\") === 0) {\r\n                            filters.push(new _filter_geoRegexFilter__WEBPACK_IMPORTED_MODULE_3__[\"GeoRegexFilter\"]([filterItem]));\r\n                        }\r\n                        else if (filterItem.key === \"zoom\") {\r\n                            if (geoZoomFilter === undefined) {\r\n                                geoZoomFilter = new _filter_geoZoomFilter__WEBPACK_IMPORTED_MODULE_1__[\"GeoZoomFilter\"]([]);\r\n                            }\r\n                            geoZoomFilter.addFilterItem(filterItem);\r\n                        }\r\n                        else if (filterItem.value.includes(\"'\")) {\r\n                            if (filterItem.key === dataLayerColumnName) {\r\n                                if (dataLayerNameFilter === undefined) {\r\n                                    dataLayerNameFilter = new _filter_geoStringAttributeFilter__WEBPACK_IMPORTED_MODULE_2__[\"GeoStringAttributeFilter\"]([filterItem]);\r\n                                }\r\n                            }\r\n                            else {\r\n                                filters.push(new _filter_geoStringAttributeFilter__WEBPACK_IMPORTED_MODULE_2__[\"GeoStringAttributeFilter\"]([filterItem]));\r\n                            }\r\n                        }\r\n                        else {\r\n                            rangeFilters[filterItem.key] = rangeFilters[filterItem.key] || new _filter_geoNumberAttributeFilter__WEBPACK_IMPORTED_MODULE_4__[\"GeoNumberAttributeFilter\"]([]);\r\n                            rangeFilters[filterItem.key].addFilterItem(filterItem);\r\n                        }\r\n                    }\r\n                }\r\n                // update the minZoom and maxZoom by ZoomFilter\r\n                if (geoZoomFilter) {\r\n                    filters.push(geoZoomFilter);\r\n                    geoZoomFilter.initialize();\r\n                    if (geoZoomFilter.ranges.length > 0) {\r\n                        var minZ = +geoZoomFilter.ranges[0][0];\r\n                        var maxZ = +geoZoomFilter.ranges[0][1];\r\n                        if (minZ <= tempMinZoom) {\r\n                            tempMinZoom = minZ;\r\n                        }\r\n                        if (maxZ >= tempMaxZoom) {\r\n                            tempMaxZoom = maxZ;\r\n                        }\r\n                    }\r\n                    else {\r\n                        var z = +geoZoomFilter.allowedValues[0];\r\n                        if (z <= tempMinZoom) {\r\n                            tempMinZoom = z;\r\n                        }\r\n                        if (z >= tempMaxZoom) {\r\n                            tempMaxZoom = z;\r\n                        }\r\n                    }\r\n                }\r\n                // update the dataLayerName\r\n                if (dataLayerNameFilter) {\r\n                    dataLayerNameFilter.initialize();\r\n                    this.dataLayerName = dataLayerNameFilter.expectedValues[0];\r\n                }\r\n                for (var name_1 in rangeFilters) {\r\n                    filters.push(rangeFilters[name_1]);\r\n                }\r\n                filterGroup.push(filters);\r\n            }\r\n        }\r\n        if (tempMaxZoom !== this.minZoom || tempMinZoom !== this.maxZoom) {\r\n            this.maxZoom = tempMaxZoom;\r\n            this.minZoom = tempMinZoom;\r\n        }\r\n        return filterGroup;\r\n    };\r\n    StyleJsonCacheItem.prototype.createSubItems = function (styleJson, dataLayerColumnName) {\r\n        if (styleJson.style) {\r\n            // apply the property to sub style.\r\n            for (var key in styleJson) {\r\n                if (key !== \"style\" && key !== \"filter\") {\r\n                    for (var i = 0; i < styleJson.style.length; i++) {\r\n                        // Apply the property to sub style if the sub style does not included.\r\n                        if (styleJson.style[i][key] === undefined) {\r\n                            if (key === \"id\") {\r\n                                styleJson.style[i][key] = styleJson[key] + \"#\" + i;\r\n                            }\r\n                            else {\r\n                                styleJson.style[i][key] = styleJson[key];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            var subItemMinZoom = void 0;\r\n            var subItemMaxZoom = void 0;\r\n            for (var _i = 0, _a = styleJson.style; _i < _a.length; _i++) {\r\n                var subStyle = _a[_i];\r\n                var styleJsonCacheSubItem = new StyleJsonCacheItem(subStyle, this.minZoom, this.maxZoom, dataLayerColumnName);\r\n                if (subItemMaxZoom === undefined || styleJsonCacheSubItem.maxZoom > subItemMaxZoom) {\r\n                    subItemMaxZoom = styleJsonCacheSubItem.maxZoom;\r\n                }\r\n                if (subItemMinZoom === undefined || styleJsonCacheSubItem.minZoom < subItemMinZoom) {\r\n                    subItemMinZoom = styleJsonCacheSubItem.minZoom;\r\n                }\r\n                this.subStyleCacheItems.push(styleJsonCacheSubItem);\r\n            }\r\n            if (subItemMinZoom && subItemMinZoom > this.minZoom) {\r\n                this.minZoom = subItemMinZoom;\r\n            }\r\n            if (subItemMaxZoom && subItemMaxZoom < this.maxZoom) {\r\n                this.maxZoom = subItemMaxZoom;\r\n            }\r\n        }\r\n    };\r\n    StyleJsonCacheItem.prototype.createGeoStyle = function (styleJson) {\r\n        var geoStyle;\r\n        for (var key in styleJson) {\r\n            if (key !== \"style\" && key !== \"filter\") {\r\n                var keys = key.split(\"-\");\r\n                if (keys.length > 1) {\r\n                    switch (keys[0]) {\r\n                        case \"polygon\":\r\n                            geoStyle = new _style_geoAreaStyle__WEBPACK_IMPORTED_MODULE_5__[\"GeoAreaStyle\"](styleJson);\r\n                            break;\r\n                        case \"line\":\r\n                            geoStyle = new _style_geoLineStyle__WEBPACK_IMPORTED_MODULE_6__[\"GeoLineStyle\"](styleJson);\r\n                            break;\r\n                        case \"text\":\r\n                            geoStyle = new _style_geoTextStyle__WEBPACK_IMPORTED_MODULE_8__[\"GeoTextStyle\"](styleJson);\r\n                            break;\r\n                        case \"point\":\r\n                            geoStyle = new _style_geoPointStyle__WEBPACK_IMPORTED_MODULE_7__[\"GeoPointStyle\"](styleJson);\r\n                            break;\r\n                        case \"shield\":\r\n                            geoStyle = new _style_geoShieldStyle__WEBPACK_IMPORTED_MODULE_9__[\"GeoShieldStyle\"](styleJson);\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return geoStyle;\r\n    };\r\n    StyleJsonCacheItem.prototype.createChildrenGeoStyle = function (styleJson) {\r\n        if (styleJson[\"children\"]) {\r\n            for (var i = 0; i < styleJson[\"children\"].length; i++) {\r\n                var childrenGeoStyleJson = styleJson[\"children\"][i];\r\n                if (childrenGeoStyleJson[\"id\"] === undefined) {\r\n                    childrenGeoStyleJson[\"id\"] = styleJson[\"id\"] + \"#c\" + i;\r\n                }\r\n                this.childrenGeoStyles.push(this.createGeoStyle(childrenGeoStyleJson));\r\n            }\r\n        }\r\n    };\r\n    return StyleJsonCacheItem;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack:///./src/tree/styleJsonCacheItem.ts?");

/***/ }),

/***/ "./src/tree/tree.ts":
/*!**************************!*\
  !*** ./src/tree/tree.ts ***!
  \**************************/
/*! exports provided: Tree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tree\", function() { return Tree; });\nvar Tree = /** @class */ (function () {\r\n    function Tree(node, treeIndex) {\r\n        this.node = node;\r\n        this.root = node;\r\n        this.treeIndex = treeIndex;\r\n    }\r\n    Tree.prototype.traverseNode = function (callback, select) {\r\n        (function recurse(currentNode) {\r\n            if (callback(currentNode)) {\r\n                if (currentNode.children.length > 0) {\r\n                    for (var i = 0, length_1 = currentNode.children.length; i < length_1; i++) {\r\n                        if (recurse(currentNode.children[i])) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // current node is matched, and without children\r\n                    select(currentNode);\r\n                }\r\n                // true: the currentNode is matched.\r\n                return true;\r\n            }\r\n            // false: the currentNode is not matched.\r\n            return false;\r\n        })(this.root);\r\n    };\r\n    return Tree;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack:///./src/tree/tree.ts?");

/***/ }),

/***/ "./src/worker/vectorTileLayerThreadMode.ts":
/*!*************************************************!*\
  !*** ./src/worker/vectorTileLayerThreadMode.ts ***!
  \*************************************************/
/*! exports provided: VectorTileLayerThreadMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VectorTileLayerThreadMode\", function() { return VectorTileLayerThreadMode; });\nvar VectorTileLayerThreadMode;\r\n(function (VectorTileLayerThreadMode) {\r\n    VectorTileLayerThreadMode[VectorTileLayerThreadMode[\"Default\"] = 1] = \"Default\";\r\n    VectorTileLayerThreadMode[VectorTileLayerThreadMode[\"SingleThread\"] = 2] = \"SingleThread\";\r\n    VectorTileLayerThreadMode[VectorTileLayerThreadMode[\"SingleBackgroundWorker\"] = 3] = \"SingleBackgroundWorker\";\r\n    VectorTileLayerThreadMode[VectorTileLayerThreadMode[\"MultiBackgroundWorker\"] = 4] = \"MultiBackgroundWorker\";\r\n})(VectorTileLayerThreadMode || (VectorTileLayerThreadMode = {}));\r\n\n\n//# sourceURL=webpack:///./src/worker/vectorTileLayerThreadMode.ts?");

/***/ }),

/***/ "./src/worker/workerManager.ts":
/*!*************************************!*\
  !*** ./src/worker/workerManager.ts ***!
  \*************************************/
/*! exports provided: WorkerManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WorkerManager\", function() { return WorkerManager; });\n/* harmony import */ var _vectorTileLayerThreadMode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vectorTileLayerThreadMode */ \"./src/worker/vectorTileLayerThreadMode.ts\");\n\r\nvar WorkerManager = /** @class */ (function () {\r\n    function WorkerManager(threadMode, workerCount) {\r\n        if (threadMode === _vectorTileLayerThreadMode__WEBPACK_IMPORTED_MODULE_0__[\"VectorTileLayerThreadMode\"].SingleBackgroundWorker) {\r\n            this.workerCount = 1;\r\n        }\r\n        else {\r\n            if (isNaN(workerCount) || workerCount <= 0) {\r\n                this.workerCount = Math.max(Math.floor(window.navigator.hardwareConcurrency / 2), 1);\r\n            }\r\n            else {\r\n                // passed by parm\r\n                this.workerCount = workerCount;\r\n            }\r\n        }\r\n        this.currentWorkerIndex = 0;\r\n        this.workers = [];\r\n        this.workerCallback = {};\r\n    }\r\n    WorkerManager.prototype.initWorkers = function () {\r\n        try {\r\n            var callbacks_1 = this.workerCallback;\r\n            for (var i = 0; i < this.workerCount; i++) {\r\n                var source = '(' + window[\"olInit\"] + ')()';\r\n                var blob = new Blob([source]);\r\n                var worker = new Worker(window.URL.createObjectURL(blob));\r\n                worker.onmessage = function (e) {\r\n                    var methodInfo = e.data[\"methodInfo\"];\r\n                    var messageData = e.data[\"messageData\"];\r\n                    var uid = methodInfo.uid;\r\n                    var callback = callbacks_1[uid];\r\n                    if (callback) {\r\n                        callback(messageData, methodInfo);\r\n                    }\r\n                    delete callbacks_1[uid];\r\n                };\r\n                this.workers.push(worker);\r\n            }\r\n            this.inited = true;\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            this.inited = false;\r\n            return false;\r\n        }\r\n    };\r\n    WorkerManager.prototype.postMessage = function (uid, methodName, messageData, callbackInfo, workerIndex) {\r\n        if (typeof workerIndex !== \"number\" || isNaN(workerIndex) || workerIndex >= this.workers.length) {\r\n            workerIndex = this.currentWorkerIndex = (this.currentWorkerIndex + 1) % this.workers.length;\r\n        }\r\n        var methodInfo = {\r\n            uid: uid,\r\n            methodName: methodName,\r\n            workerId: workerIndex\r\n        };\r\n        if (callbackInfo) {\r\n            this.workerCallback[uid] = callbackInfo;\r\n        }\r\n        var postMessage = {\r\n            methodInfo: methodInfo,\r\n            messageData: messageData\r\n        };\r\n        this.workers[workerIndex].postMessage(postMessage);\r\n        return workerIndex;\r\n    };\r\n    WorkerManager.prototype.close = function () {\r\n        this.workerCallback = {};\r\n        for (var index = 0; index < this.workers.length; index++) {\r\n            this.workers[index].terminate();\r\n        }\r\n    };\r\n    return WorkerManager;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack:///./src/worker/workerManager.ts?");

/***/ })

/******/ });